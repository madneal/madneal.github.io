<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Neal&#39;s Blog</title>
    <link>https://madneal.com/post/</link>
    <description>Recent content in Posts on Neal&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Sat, 29 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://madneal.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Home Assistant 小米门铃视频本地存储</title>
      <link>https://madneal.com/post/xiaomi/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/xiaomi/</guid>
      <description>小米的门铃，免费的云存储时间只有 72 小时，希望保存更多时间的视频，只能去充钱。后来网上搜了一下，通过 Home Assistant 的小米插件可以实现这样的功能。刚好家里有一台闲置的 Macbook 用来发挥余热不是刚好。其实我之前已经安装好了，只不过手残把镜像文件删掉了，这样刚好出个教程从头来一次。
Home Assistant 安装 Home Assistant 支持多种安装方案，不过他们主推的是他们自己的一款软硬件一体的方案。其实家里是有一台软路由的，不过软路由担心把网络搞出问题，还是选择使用那台闲置的 Mac。官网里面也包含了 MacOS 的安装方案。因为 Home Assistant 用的是比较低版本的 Linux 系统，所以基本都还是需要使用虚拟机。首先需要安装 VirtualBox。另外就是需要下载 Home Assistant 的镜像文件。对于虚机，有一个推荐的配置，下面都以贴图的形式展现。
这个步骤里面的虚拟硬盘，记得需要使用前面下载下来的 vdi 文件。
接着需要把虚机的网络里面去配置桥接，官方文档里面说必须要使用有线连接网络，但是我的笔记本使用 WIFI 也没有什么问题。
系统全都配置好了之后，就直接启动系统，等待系统初始化好后即可。系统初始化好后，即可进入页面 http://homeassistant.local:8123/ 。一般进入页面的时候可能还需要等待一段时间初始化。
初始化完成后，创建账户。
选择家庭地址
进入主页
以上就是 Home Assistant 的安装，主要就是一个虚机的配置，其它基本只要下一步就可以。不过这个还是只是第一步，还需要安装 HACS，它是一个插件商店，通过这个商店才可以去安装小米的插件。
HACS 安装 HACS 需要尝试通过终端去安装，我尝试过直接在虚机里面去直接执行命令，但是是不可以的。需要安装终端插件去执行命令，这里我推荐使用 Terminal &amp;amp; SSH 插件，比另外一款插件好用，另外一款插件总是初始化失败。在设置里面，找到 Add-ons，然后在 ADD-ON 商店里面去搜索，不过这里有一个坑是默认搜不到这个插件的，需要在设置里面把高级模式打开。
插件安装好了，可以参考官方文档去安装 HACS。按照 Terminal 插件之后就可以直接执行命令：
wget -O - https://get.hacs.xyz | bash - 安装完毕后，需要重启一下 Home Assistant，可以直接在终端里面通过 reboot 来进行重启。安装重启之后，还需要在 Settings &amp;gt; Devices and Services &amp;gt; Add Integration &amp;gt; HACS 里面添加一下。因为 HACS 需要使用 github 去更新，你可能还需要一个 github 账号来进行配置，输入验证码后，即配置成功。</description>
    </item>
    
    <item>
      <title>大佬，您这是在借鉴嘛</title>
      <link>https://madneal.com/post/export-to-markdown/</link>
      <pubDate>Thu, 27 Jun 2024 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/export-to-markdown/</guid>
      <description>今天闲来没事看到一篇文章，感觉质量挺好的，就想翻译一下。之前写过一个将文档导出成 markdown 的插件，因为这个插件一开始是为了翻译 Medium 文章开发的，但是后来因为 Medium 的 json 接口启用了，所以这个插件后面也不怎么维护了。不搜不知道，一搜吓一跳，居然发现一个和插件差不多的插件，不会吧，这么烂的插件也有人抄？后来仔细看了一看，这个大佬应该是在借鉴我的插件，辛苦地改了几个中文。
两款插件名名字几乎一模一样，只是这个借鉴者加了一个后缀：掘金翻译计划版。不确定和掘金有没有关系，我知道掘金是有一个翻译项目的，以前我也参与过。
对比 插件介绍 我的插件 李鬼插件 代码对比 上面的简洁基本上已经展现了浓重的李鬼味道，本着客观严谨的态度，我还是去看了一下代码。
我的插件 李鬼插件 除了一个 js 文件的引用，几乎可以说是一模一样了。核心的文件是 widget.js 这个文件，这个属于插件自身的 js 文件。
从这代码对比，可以看得出这个借鉴者巨大的工作量。
总结 鄙人的这款插件是在 GitHub 上开源的，当时也是出于个人需求搞得这么个小玩意，但是没想到居然还有李鬼借鉴，还真是离谱他妈给离谱开门。大家如果有空的话，还是动一下发财的小手点一下 Report，这个李鬼插件还是下架比较好。我也联系了这个开发同学，希望他能及时下架。</description>
    </item>
    
    <item>
      <title>如何使用 Git 撤消（几乎）任何操作</title>
      <link>https://madneal.com/post/git-undo/</link>
      <pubDate>Sun, 12 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/git-undo/</guid>
      <description>原文：How to undo (almost) anything with Git
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 任何版本控制系统最有用的功能之一就是能够“撤消”错误。在 Git 中，“撤消”可能意味着许多略有不同的事情。
当你进行新的 commit 时，Git 会及时存储你的仓库在该特定时刻的快照；之后，你可以使用 Git 返回到项目的早期版本。
在这篇文章中，我将介绍一些你可能想要“撤消”所做更改的常见场景，以及使用 Git 执行此操作的最佳方法。
撤销一个“public”修改 场景： 你刚刚运行了 git push，将你的修改 push 到 GitHub，现在意识到有一个 commit 有问题。你想把这个 commit 撤销。
撤销： git revert &amp;lt;SHA&amp;gt;
结果： git revert 将创建一个与给定 SHA 相反的新 commit。如果旧 commit 是“matter”，则新 commit 是“anti-matter”——旧 commit 中删除的任何内容都将添加到新 commit 中，而旧 commit 中添加的任何内容都将在新 commit 中删除。</description>
    </item>
    
    <item>
      <title>Google Drive 的信息检索</title>
      <link>https://madneal.com/post/drive/</link>
      <pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/drive/</guid>
      <description>对于使用 Google 全家桶的公司，Google 文档类的信息泄露也时常发生。出现这种情况主要的原因是文档的权限设置问题，用户可能将文档配置为 anyoneCanFind, anyoneWithLink, domainCanFind, domainWithLink，这四种权限都属于比较公开的权限。后两个属于在域内可以查看到文档，一般来说也是不提倡如此设置，尤其是文档中包含敏感信息的。
Auth 如果要使用 Google Drive 的 API，毫无疑问，Google Workspace 的 Auth 则是第一步。对于 Auth，一般可以通过 OAuth 或者 service account 来进行实现，但是 service account 有一个问题是，默认这个 service acount 并没有赋予这个 servive account 这个域内所有资源的访问权限。必须要将这个文档分享给 service account，它才可以访问。这将会影响到对于 domainCanFind 以及 domainWithLink 的文档的搜索。解决办法是需要 delegate domain-wide authority,相当于是对于这个 service account 进行额外的授权，详细的介绍可以参考这个文档。当然，这个授权需要管理员账号来进行，如果申请比较麻烦的话，还可以通过使用 OAuth 的方式来进行认证，这也是 Google Drive API 文档指引中介绍使用的方式。
通过 OAuth 来使用 Drive API 也需要三个步骤：
 启用 API 配置 OAuth 应用 生成 Credentials  详细介绍可以参考谷歌的文档介绍，基本上每一步都有详细的介绍。建议可以按照文档的方式来进行操作，OAuth 生成方式会用到一个 credentials.json 文件。如果对 OAuth 流程比较了解的话，应该知道流程中会有一个授权的流程。Go 的官方文档已经提供了一个授权的 demo，通过运行代码可以获取 autorization code，通过 aurhorization code 可以生成 token.</description>
    </item>
    
    <item>
      <title>菜腿的骑行通勤</title>
      <link>https://madneal.com/post/%E9%AA%91%E8%A1%8C/</link>
      <pubDate>Sat, 12 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%AA%91%E8%A1%8C/</guid>
      <description>现在，自行车骑行越来越流行。B 站上经常可以刷到各种骑行的视频。当时，就想着平常上下班开车特别堵车，骑自行车既可以通勤，还可以减肥，一举两得。选车的时候也没有特别讲究，都说迪卡侬售后比较好，平常也喜欢在迪卡侬瞎逛，在店里也稍微试骑了一下。三月份的时候就直接在迪卡侬买了最基础的公路入门车 rc100。选的是到店自提，有 100 块的优惠券，加上安装了站脚和水壶架，差不多 1700 多一点。虽然说这个车一直涨价到 1799，但还是非常火的入门公路车之一。推荐到店自提，自己安装可能还是有一点麻烦，自提会省心不少，还可以帮你把配件也一起安装了。
好多人一买车了，就各种装备，比如码表、自行车灯、手机支架等等。考虑到自己只是上下班通勤而已，才买的时候还偶尔出去骑行一下，但是后面除了上下班，基本也不骑。高德地图足够使用了，可以记录速度和里程，用来统计骑行继续就基本够用了。自行车灯买过一个，可是还没用几天，就被人偷了。手机支架就多多买了一个很便宜的硅胶支架，还挺稳，手机没有掉过。在迪卡侬买过一个骑行裤，但我感觉似乎并没有什么用，穿着也不是特别舒服，不知道是不是因为买的不够贵的原因。一般如果骑行不超过两个多小时的话，应该也不太需要骑行裤，而且骑行裤通勤的话也不太方便。
对于我个人而言，自行车在通勤上更加有优势一点。如果开车去公司的话，路程15公里左右，大多数情况早上基本都要 50 分钟多，遇到更堵的时候甚至要一个多小时，也是家常便饭。遇到最夸张的一次是堵了我将近两个小时。另外，开车去公司还要交停车费。自行车通勤，现在基本稳定在40分钟左右，最快的记录 36 分钟，通勤距离将近 12 公里。通勤时间上来说，自行车比开车其实还更节约时间。
后来从三月份开始就基本断断续续用自行车通勤，一般不下雨的时候骑自行车，下雨就开车。梅雨季那段时间，雨水比较多，那段时间基本都是开车。下雨的时候骑自行车还是挺不方便的，后来买过一款迪卡侬的徒步的雨衣，99.9，使用过一次，基本还能用。但是如果是那种大雨，其实本身骑行雨衣基本就不太管用了。另外，骑行的比较重要的装备就是手套了。不仅可以防晒，握车把会舒服一些，而且万一摔了的话，对于手掌还有一点保护。骑行一共就摔过两次，一次是前面的电动车突然急刹车，另外一次是电动车自己骑太快滑到了把我撞到了，还好两次我基本都没有受伤。骑行的时候还是需要注意安全，不要骑行过快，和他人要保持安全距离。另外就是往旁边移动的时候，一定要先往后面看看。
市区通勤的话，路况还是比较重要的。公路车比较吃路况，但是现在路面经常各种各样的补丁，导致骑起来非常不舒服。另外就是红绿灯多的话也非常影响配速，后来自己摸索了一条路，基本是最快的，这个是地图导航没有的路线。大部分的公路车用的都是法式嘴，也是这一次我知道了有法式嘴、英式嘴、以及美式嘴。英式嘴比较古老，以前那种老式自行车使用的，美式嘴最通用，汽车以及一般的电动车都是美式嘴，而公路车一般用的都是法式嘴。法式嘴的特点就是细长，并且把塑料帽拧下来之后还要把上面的金属帽拧松。之前一开始补气的时候一直打不进去，后来才知道是这个原因。
夏季骑行最大的困难就是太阳比较大，比较热。前面的一段时间基本都放弃不骑了，太热就不想骑。后面，上海的一场大雨把我四个轮子和两个轮子的电动车都跑坏了，就只能骑自行车了。现在习惯了，感觉骑行太舒服了，那种破风疾驰的感觉实在太爽。早上六点多的时候是骑行最舒服的时候，不热并且太阳也基本没有，我偶尔起来的早的话，就直接出发去公司了。本来是买了迪卡侬的渔夫帽遮阳，但这个渔夫帽有一个问题就是帽檐经常被风吹到上面或者下面，吹到上面不能遮阳，吹到下面遮挡视线，不太好用。后面入了洛克兄弟的骑行帽，可以把脸部和脖子全部遮挡。有了悍匪造型的加成，现在骑行感觉没有一点问题。
如果你的通勤距离和我类似，建议你可以试试自行车通勤。可能比开车或者地铁更加方便快捷。当然说到最开始的初衷，减肥，反正我是一点也没瘦，自从骑车后，就比以前更饿，吃得更多，没有长胖就已经不错了。</description>
    </item>
    
    <item>
      <title>GitHub 更新了 RSA SSH host key</title>
      <link>https://madneal.com/post/github-rsa/</link>
      <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/github-rsa/</guid>
      <description>今天在 push 自己 GitHub 仓库代码的时候遇到了报错，后来发现是 GitHub 已经将 RSA SSH host key 进行了更新。依据官方博客，GitHub 于 3月24日 05:00 UTC 时间 由于安全原因将 RSA SSH host key 进行了更新。主要是为了避免 GitHub 用户的 git 操作被任何不法分子监听。这个变更仅影响基于 RSA 的 SSH 协议使用 GitHub 进行 git 操作的用户。变更也只影响 RSA 算法，不影响 ECDSA 或者 Ed25519 用户。
GitHub 这周发现了他们的 RSA SSH 密钥在公共仓库中暴露。根据他们的调查结果，这个问题暂不涉及 GitHub 任何系统或者用户信息被窃取。依据他们的解释是保险起见进行 host key 的更新。
报错信息可能如下：
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</description>
    </item>
    
    <item>
      <title>行车记录仪对比 - 盯盯拍mini5 vs 海康威视C8</title>
      <link>https://madneal.com/post/%E8%A1%8C%E8%BD%A6%E8%AE%B0%E5%BD%95%E4%BB%AA/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%A1%8C%E8%BD%A6%E8%AE%B0%E5%BD%95%E4%BB%AA/</guid>
      <description>最近把之前的盯盯拍 mini5 行车记录仪换下来了，换了海康威视 C8。这两款行车记录仪都是小鹏官方商城里面的行车记录仪，之前卖的是盯盯拍 mini5 和 mini3，但后来不知道盯盯拍就下架了。下架之后只有海康威视的这个型号。我算行车记录仪的重度用户，经常拿来举报违章，所以好用的行车记录仪非常重要。盯盯拍是市面上比较受欢迎的 4K 行车记录仪之一。使用将近两年的时间，基本没有什么特别大的毛病，不过前段时间在老家行车记录仪经常重启，可是回到上海之后又莫名其妙正常了。不过还是购入新的海康威视的让售后帮忙安装，因为网上关于这两款行车记录仪的对比评测不算特别多，所以分享一下对于这两款行车记录仪的使用对比。
外形 盯盯拍：⭐⭐⭐⭐⭐
海康威视：⭐⭐⭐
因为网上都有两款行车记录仪的照片，这里就不再贴图。行车记录仪的屏幕个人觉得特别鸡肋，因为行车记录仪只是作为记录使用，屏幕并没有什么作用，可能还会干扰视线，浪费电能。这两款行车记录仪都是不带屏幕的。盯盯拍 mini5 体型比较小，外形比较好看，质感比较好一些。不过这样带来的负面影响就是散热比较差，夏天特别烫手。有的时候可能会因为高温重启。海康威视相对来说体积大一些，散热好一些，镜头可以上下调节。但这一点基本上也没大的区别，因为行车记录仪一旦安装之后也不需要调整镜头。
新的行车记录仪是让小鹏的售后安装的，安装的比较整洁，线材都埋在了摄像头的盒子里面。当然也是因为三目摄像头的原因，记录仪也安装在比较靠下的位置。但是颠簸路面的状况会有一点点异响，可以接受。
APP 海康威视：⭐⭐⭐⭐⭐
盯盯拍：⭐⭐⭐
行车记录仪的 APP 对于行车记录仪来说特别重要，因为这是使用行车记录仪最频繁的场景。海康威视有一个独特的优势就是小鹏车机里面集成了 APP，可以在车机里面使用行车记录仪。不过限制只有 P 档的时候才能使用，我觉得是比较鸡肋。因为我之前使用行车记录仪的场景基本都是打开 APP，连接行车记录仪，然后 APP 就自动下载违章视频，有空的时候再去举报。盯盯拍的 APP UI 方面设计的比较精细一点，海康威视的相对来说就比较古老一点。但是，盯盯拍每次打开还有开屏广告，没有海康威视干净。虽然看起来丑了一点，但是明显干净了很多。盯盯拍之前 APP 经常无法连接强制退出，不过后面某个版本修复之后就没遇到过这种问题了。因为两款行车记录仪都是支持 5G WIFI 的，所以下载速度还是比较 OK 的。
因为 APP 的连接原理都是手机连上记录仪的 WIFI，从连接速度上面来说，海康威视要比盯盯拍快，而且盯盯拍还经常有连接失败的情况。视频预览的形式也不一样，盯盯拍是把回放视屏连接在了一起，而海康威视则是一段段的视频，这一点盯盯拍更好一点，预览视频更直观。
成像 盯盯拍：⭐⭐⭐⭐⭐
海康威视：⭐⭐⭐⭐
专业的参数评测可能网上已经有对比了。按照之前盯盯拍的使用体验来说，虽然是 4K 的行车记录仪，但是如果想拍清楚车牌的话，基本上必须一个车身位的距离才能拍清楚。强光环境，或者夜晚环境，可能都会差一点。还有就是那种车速特别快的，基本也是拍不清楚的。两款记录仪参数上来说基本上一致，只不过海康威视的光圈大一些而已。成像质量最好的一般都是在隧道里面，有稳定光源的。如果希望进行违章举报的话，必须要拍清楚车牌。所以一般为了拍清楚违章车辆的车牌，可以稍微靠近违章车辆，拍清楚车牌，这样举报成功率才会高一些。
不过两款行车记录仪的图片角度来看，盯盯拍的似乎更好一点，海康威视不知道是不是因为镜头角度的问题，拍出来的画面有一点点畸形的感觉，没有盯盯拍看起来那么自然。从画面成像的角度来看我更喜欢盯盯拍。另一方面盯盯拍的图片的水印看起来也更舒服一些。
停车监控 海康威视：⭐⭐⭐⭐
盯盯拍：⭐⭐⭐
因为这两款行车记录仪小鹏商城里面都是降压线版本，所以都有停车监控的功能的。盯盯拍的停车监控有两种功能，一种是缩时录影，另外一种是持续录像。缩时录影就是隔几十秒拍一张，这种主要是避免行车记录仪消耗太多电量，导致小电瓶没电。但有一次我我车在停车场被蹭，通过缩时录影拍到了别人的车牌，但因为不是实时的录像，也不能作为直接的证据。所以缩时录影也比较鸡肋，基本上只能简单的录一下。持续录像的话，主要的问题就是 4K 视频占用存储比较大，可能录不了多长时间就被覆盖了。另外就是小电瓶可能经常就没电了。海康威视是只有持续录制的选项，可以选择录制的时间，但是默认也是缩时录影的形式。不过感觉海康威视的停车监控似乎比盯盯拍稳定一些，盯盯拍之前经常因为小电瓶电压的问题关闭了。
可拓展性 海康威视：⭐⭐⭐⭐
盯盯拍：⭐⭐⭐
这两款行车记录仪都是支持 4G 模块的。通过 4G 模块可以远程查看行车记录仪摄像头的实时画面。之前大多数新能源汽车可以远程查看的，不过去年因为数据安全的问题就被政府叫停了，现在市面上车辆的摄像头都不能直接查看了，虽然我觉得特别不合理，因噎废食。海康威视的 4G 模块可以外接，可拓展性相对来说更强一点。盯盯拍则是集成到支架上面，如果要升级的话，相对来说更麻烦一点，需要将原有的支架拆除，更换为新的支架。
存储方面，盯盯拍只支持内置存储，这也是更换行车记录仪的原因之一。因为之前买的是64 GB 的版本，64 GB 对于 4K 行车记录仪来说还是太小了，不够用。海康威视使用 SD 卡来进行存储，拓展性相对来说好一点。不过最大也就只支持 128 GB，如果可以支持到 256 就好了。</description>
    </item>
    
    <item>
      <title>为什么 2022 年是漏洞赏金奖破纪录的一年</title>
      <link>https://madneal.com/post/github-bug-bounty/</link>
      <pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/github-bug-bounty/</guid>
      <description>为什么 2022 年是漏洞赏金奖破纪录的一年  原文：Why 2022 was a record-breaking year in bug bounty awards
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 每年，GitLab 的应用安全团队 都会回顾 GitLab 漏洞赏金计划的亮点。
对于整个行业的安全团队来说，2022 年是忙碌的一年，我们很幸运收到了大量出色的报告，帮助我们确保 GitLab 及其客户的安全。 随着我们在 2021 年 11 月 增加我们的漏洞赏金奖励金额和研究人员参与度的提高，我们在 2022 年期间奖励超过 100 万美元，打破了新纪录！
如果没有我们的漏洞赏金社区的合作，我们就不会取得今天的成就，我们认为这些奖励非常有益，而且钱花得值。
2022 年的数字  在 221 份有效报告中获得总计 1,055,770 美元的奖金，高于去年的 337,780 美元！ 三名研究人员在他们的多份报告中获得了 10 万美元以上的收入，另外七名研究人员的收入超过了 2 万美元。 2022年共收到424名研究人员的920份报告。 解决了 158 份有效报告并公开了 94 份 - 今年，我们收到了一些信息泄漏报告，与漏洞不同，这些报告不需要公开 GitLab 问题。 今年有 138 名安全研究人员提交了一份以上的报告，表明他们对我们的计划做出了积极的贡献。 向提交三份或更多有效报告的研究人员授予八份 GitLab Ultimate 许可证。  注：数据为截至 2022 年 12 月 16 日。</description>
    </item>
    
    <item>
      <title>CircleCI 20230104 安全事件报告</title>
      <link>https://madneal.com/post/circleci-incident/</link>
      <pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/circleci-incident/</guid>
      <description>CircleCI 20230104 安全事件报告  原文：CircleCI incident report for January 4, 2023 security incident
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 2023 年 1 月 4 日，我们提醒客户 一起安全事件。 今天，我们想与您分享发生的事情、我们学到的知识以及我们未来不断改善安全态势的计划。
我们要感谢我们的客户对于重置密钥的关注，并对此次事件可能对您的工作造成的任何干扰表示歉意。我们鼓励尚未采取行动的客户采取行动，以防止未经授权访问第三方系统和存储。此外，我们要感谢我们的客户和社区在我们进行彻底调查期间的耐心等待。为了实现负责任的披露，我们已尽最大努力在共享信息的速度与保持调查的完整性之间取得平衡。
本报告包含:
 发生了什么？ 我们怎么知道这个攻击向量已经关闭并且可以安全构建？ 与客户的沟通和支持 如何判断我是否受影响？ 可能有助于您的团队进行内部调查的详细信息 我们从这次事件中学到了什么以及我们下一步将做什么 关于员工责任与系统保障措施的说明 安全最佳实践 结语  发生了什么？ 除非另有说明，否则所有日期和时间均以 UTC 报告。
2022 年 12 月 29 日，我们的一位客户提醒我们注意可疑的 GitHub OAuth 活动。此通知启动了 CircleCI 的安全团队与 GitHub 的更深入审查。</description>
    </item>
    
    <item>
      <title>CPE 获取指南</title>
      <link>https://madneal.com/post/cpe/</link>
      <pubDate>Fri, 02 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/cpe/</guid>
      <description>在我们考取 ICS 的认证之后，是需要通过 CPE(Countinuing Professional Education) 来进行证书的维持的。以 CISSP 为例，3年是需要 120 CPE 来进行证书的维持的。官方的文档已经详细说明了获取 CPE 的各种途径，如果按照官方的说明，满足要求的难度是比较低的。我在取得 CISSP 认证之后，不到一年的时间已经获得 98 CPE 了，距离要求已经很接近了。所以就分享自己一些获取 CPE 的手段来进行分享。
Webinars 基本上是一些讲座或者分享之类的，听一次基本都可以获取一个 CPE。而且现在目前 ISC 上面大多数在线的会议或者课程学习，如果可以获取 CPE 的话，你只要填了你的 ID 的话，过一段时间就会帮你自主申报，不需要你自己来申报的。不过这种在线分享，一般很多没有在线字幕，而且内容也比较杂，所以我就听说一两次，不是特别的感冒。我自己的话不是特别推荐，虽然说这是获取 CPE 的手段之一，但好歹自己也在这个过程中学点东西，这样也更有价值。
Professional Development Institute 这是我最为推荐的部分。在 PDI 里面提供了各种各样的课程，这些课程一般是英文为主，涉及的方向也比较多，比如应用安全、安全运营之类的，制作一般都比较精良。虽然里面的内容大多数都是偏理论的居多，但是如果拿去写材料什么的还是比较好的。课程可能会随着内容的多少，其 CPE 分值也不相同，有的 5 分，有的可能只有 1 分。不过这些课程都需要经过考试的，基本上分数达到 70% 以上就可以过关了。
其它 其它像回答 InforSecurity Professional 杂志上面的 quiz 也可以去获取 CPE 的，不过我觉得还挺麻烦的，因为答案可能还不太好找。参加一些安全会议也是可以获取 CPE 的。另外值得分享的是，参加 ISC 的一些志愿活动也是可以获取 CPE 的。我有次参加了一次志愿活动，一共持续了 3 天，一次性给了 21 个 CPE，还是比较多的。</description>
    </item>
    
    <item>
      <title>小鹏 P7 之殤</title>
      <link>https://madneal.com/post/xp-problem/</link>
      <pubDate>Sun, 25 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/xp-problem/</guid>
      <description>不知道这会不会是我最后一次写关于小鹏的文章。虽然我算不上是小鹏的狂热粉丝，但之前也算是好感多一点，之前也分享过几篇文章关于车辆使用以及辅助驾驶方面的经历。但是最近的售后问题实在是我对小鹏失望加失望。
事情经过 首先描述一下问题发生的一个比较完整的时间线：
2022.08.13 去上海闵行小鹏服务中心检查辅助驾驶方向盘一直微调的问题，售后技师借口无法试车，不了了之。小鹏闵行服务中心一位女性售后人员在车辆交付之后没有直接交付给顾客，让顾客白白等了将近一个小时，她说她以为我已经走了，她车子都没有交付给我。
2022.08.22 辅助驾驶出现不可启用的问题，又向远程技术支持反馈问题。远程技术支持反馈是软件 BUG，未得到合理解决。
2022.08.27 去闵行服务中心继续排查辅助驾驶 NGP 使用时方向盘持续修正的问题，陪同技师经历两个小时左右的试车，最后观察到了问题现象。后技师说可能是软件问题，安装了软件补丁，但实际效果暂未知。
2022.09.12 辅助驾驶第二次不可用，且无法恢复。电机异响（电机异响的问题其实早就出现了，后面是特别严重，基本上就跟地铁运行的声音一致），去上海闵行小鹏服务中心检查确认电机问题以及辅助驾驶问题，当时售后技师说电机的问题已经非常严重了，需要留店检查维修。当时售后接待人员承诺的代步车权益是每天 3000 积分的补偿方案，从我交车的时间到我提车的时间（这也是后面埋下的伏笔之一）。
2022.09.18 售后这边提出的维修意见是需要更换电机，更换电机还需要用户去车管所登记去变更电机编号。而且辅助驾驶的问题没有根本解决。打客服电话投诉，投诉受理。
2022.09.19 售后给出车辆维修表，需要同时更换电机以及辅助驾驶芯片。对于赔偿方案闭口不提，和400客服踢皮球。期间配合进行车管所预约，预约到最早的变更日期是10月24号。期间咨询售后人员，不变更电机号，汽车无法合法上路。
2022.09.24 售后提出车辆要开始维修，询问代步车权益问题。他说车辆维修之后先拿回去，可是车子换过电机之后需要及时去车管所变更，否则是不可以上路的。售后提出让消费者把一个电机有问题的车子开回去，后面再来修，就为了不承担他们承诺赔付的代步车权益。不知道他们有没有考虑过消费者的生命安全，有没有考虑过道路行人的生命安全。
下面放上两段9月24日和售后的录音，总结概括就是预约的时间太长了，我们不想赔你代步车权益，你把车子先开回去吧。
问题总结 其实这一次的问题主要是包括两个问题，一个是电机的质量问题，第二个就是辅助驾驶的问题。小鹏 P7 的电机质量问题，出现这个问题的我并不是唯一的车主，网上搜一搜应该也有很多类似的方案。但是小鹏在解决问题的时候总是非常被动，总是消费者要花费巨大的时间和经历去推动他们去处理。车辆提车不到一年半的时间，行驶里程不足两万五千公里，就出现电机质量问题和辅助驾驶问题，需要更换电机以及辅助驾驶芯片。
第二个就是辅助驾驶的问题。一直我的观点都是辅助驾驶仅仅就只是辅助驾驶，并不能代替人完全去接管车辆。所以我在使用辅助驾驶的过程中一直都是握着方向盘去使用的。自从提车辅助驾驶使用以来，也一直陆陆续续出现过各种问题。包括出匝道突然靠近马路沿，各种幽灵刹车，使用过程中方向盘一直在不断微调，到最后的辅助驾驶不可用的阶段。当然，一种新兴技术在出现的过程中肯定在所难免会出现一些 Bug，我也经常积极反馈这些问题，并向他们上传日志，甚至配合提供行车记录仪视频。但是，小鹏往往给的答复往往都是模棱两可的，也并没有彻底的修复问题，就说可能是什么 Bug。
下面这段视频是当初提车没多久，NGP 在使用过程中突然有撞墙的一个举动，在快出匝道的时候突然往墙壁靠拢。还好当时及时接管了。当时也反馈给了他们的远程技术支持，​后来一段时间我都不敢使用 NGP 了。
后面 ACC 在北横通道又出现两次幽灵刹车的问题：
后面 ACC 在另外一个地道又连续出现两次幽灵刹车：
以上基本上就是我三次向他们反馈的问题，其实期间辅助驾驶也是各种小问题不断，比如 NGP 突然降级，速度从80降到60，幽灵刹车问题，莫名其妙勒安全带，以及上面提到的使用过程中方向盘持续调整以及辅助驾驶不可用的问题。而小鹏在解决问题的过程中似乎没有一点点主动性，能听到最多的也就是抱歉。
小鹏售后处理问题非常有意思的一点是，就是一定要求消费者拍视频举证。如果消费者无法提供举证视频的话，那就不能帮你维修。比如之前喜闻乐见的门把手收不回去的问题，辅助驾驶方向盘调整的问题。特别有意思的是他们要求一定要清楚拍摄辅助驾驶出现问题的时候去拍摄问题，完全没有考虑到可操作性，可能我需要在开车的时候头上一直顶着手机去录影才可以。他们在解决问题的时候从来不想着自己主动去排查问题，而一味地让消费者提供视频证据，并且不考虑实际可行的程度。每次地提问，也只能得到不痛不痒的，毫无帮助的回答。
这个视频是 9 月 24 号当时拍摄的视频，包括当时出现的辅助驾驶不可启用的问题。并且如果你注意听一下的话，已经可以听到电机的声音非常大了，即使在车辆在高架上行驶，有风噪胎噪的情况下，电机的声音依然非常明显，和地铁行驶的声音差不多。
总体而言，之前在辅助驾驶使用过程中遇到的问题，我都是积极反馈，上报日志，提供视频证据，从来没有进行过投诉，也没有要过赔偿。可是这次电机质量问题以及辅助驾驶的问题让我真的对小鹏的售后简直是无语加无语，处理问题不主动，出了事情就往消费者身上一推，没有一丝一毫的担当。从来没有站在消费者的角度考虑过问题。
总结 毫无疑问，目前的新势力造车搞得如火如荼。小鹏在新能源汽车上面的确有自己厉害的地方，P7 当然也有它身上很多的优点。但是如果一个厂家没有办法保证产品质量，没有办法保证售后服务，那么这个品牌在未来的路上可能走得也不会太远，其口碑也会越来越差。</description>
    </item>
    
    <item>
      <title>关于招人的那点小事</title>
      <link>https://madneal.com/post/hr/</link>
      <pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/hr/</guid>
      <description>今天在 ISC2 里面的 「Building a High-Performing Cybersecurity Team」 课程里面看到一个很有意思的视频。一个资深的 HR 分享了关于招人的一些看法，我觉得是非常有道理。现在不管是作为招聘方还是求职者都感觉很困难，招聘方觉得很难招到满意的人，求职者觉得找不到满意的工作。似乎双方都没有招到自己满意的点，而且现在的招聘市场鱼龙混杂。
对于招聘方来说，制定好预算，计划好 headcount，把能考虑的东西都考虑进去。当然，这是一种比较理想的情况，而往往在实际中往往可能会有各种各样的意外。但是做好预算，制定好计划，毫无疑问是非常有帮助的。HR 也说她能能够 JD 快速计算出这个岗位在市场上面的价值。
视频过程中也提到了现实招聘过程中一个比较常见的问题。求职者往往希望要求比预算更高的薪水。虽然这个 HR 的回答我感觉也不太好，但实际上这个问题我觉得也并没有一个很好的解决办法，或者来说根本就没有解决办法。HR 首先承认金钱非常重要，但她认为还是应该避重就轻，尽量避免涉及到这一点。并可以强调企业为这个岗位的预算就在这个特定的区间范围内。显然，HR 也并不同意直接去提高预算的做法。
HR 也提到了招聘负责人经常存在的一些错误做法：
  不与 HR 积极合作。很多招聘方写的 JD 只是拍脑袋想出来的，但实际上并不是公司真正需要的。这种情况也很常见，很多人在写 JD 的时候恨不得把所有条件都写上，但是并没有充足的预算支持，并且实际上也并不是需要这样的人。只是把他们认为应该写上的都写上去而已。这样的 JD
  HR 也强调了需要从头到尾参与整个招聘过程。
  同时强调了现在是一个候选人的市场。招聘方需要快速的响应，一旦 Offer 批准之后就应该立即行动。可能就在你犹豫的一瞬间，候选人可能就被别的公司抢走了。
  同时这个访谈里面还提到了一些比较有意思的点。首先提到的一点就是求职网站，这一点很重要，因为这是求职者对你公司的第一印象。有的公司的网络做的很垃圾，体验很糟糕，不仅要上传简历，还要填写给种各样的表单。之前甚至还遇到有银行招聘需要求职者提供身份证照片，简直就离谱。对于这种公司，很多求职者可能在一开始就直接放弃了。毫无疑问，提升这方面的体验非常重要。
另外一点就是 HR 要在整个过程中需要保持和候选人的接触，这样让候选人感觉到他们一直被持续关注。尤其是遇到那种面试官出差或者请假的状态。这样避免候选人认为整个流程已经慌了。而且有的公司投递简历，石沉大海，没有任何响应的行为也非常不好。这些都有可能为公司带来一些负面影响。</description>
    </item>
    
    <item>
      <title>Go 的漏洞管理</title>
      <link>https://madneal.com/post/go-vuln-management/</link>
      <pubDate>Wed, 07 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/go-vuln-management/</guid>
      <description>原文：Vulnerability Management for Go
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 我们很高兴地宣布 Go 对漏洞管理的新支持，这是我们帮助 Go 开发人员了解可能影响他们的已知漏洞的第一步。
这篇文章概述了当前可用的内容以及该项目的后续计划。
概述 Go 提供工具来分析你的代码库来发现已知漏洞。该工具由 Go 漏洞数据库提供支持，该数据库由 Go 安全团队规划。Go 的工具通过仅显示代码实际调用的函数中的漏洞来减少结果中的噪音。
Go 漏洞数据库 Go 漏洞数据库 (https://vuln.go.dev) 是有关公共 Go 模块中可导入包中已知漏洞的综合信息源。
漏洞数据来自现有来源（例如 CVE 和 GHSA）以及来自 Go 包维护者的直接报告。Go 安全团队会审查这些信息并将其添加到数据库中。
我们鼓励包维护者在他们自己的项目中提供有关公共漏洞的信息，并更新其 Go 包中漏洞的现有信息。我们的目标是使报告过程成为一个非常容易的过程，因此请向我们反馈任何改进的建议。
Go 漏洞数据库可以在浏览器中的 pkg.go.dev/vuln 中查看。 有关数据库的更多信息，请参阅 go.dev/security/vuln/database。
使用 govulcheck 检测漏洞 新的 govulncheck 命令是一种低噪音、可靠的方式，让 Go 用户了解可能影响他们项目的已知漏洞。 Govulncheck 分析你的代码库并仅根据代码中的哪些函数传递调用易受攻击的函数来发现实际影响你的漏洞。 要开始使用 govulncheck，你可以从项目中运行以下命令：</description>
    </item>
    
    <item>
      <title>iMac&#43;Studio Display，双 5k 屏体验</title>
      <link>https://madneal.com/post/studio-display/</link>
      <pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/studio-display/</guid>
      <description>选型 之前一直用的显示器是 iMac 2020 款以及明基的 PD2700U 显示器。作为最后一款 intel 芯片的 iMac，显示器比新款的感觉更好一些，毕竟是买显示器送电脑。而明基的这款显示器显示效果也不错，同时也比较护眼，使用体验也很好。这种双屏的组合不论做啥都很爽。
奈何公司只提供 1080P 的显示器，在 Mac 上面的使用效果和看马赛克差不多。为了提高工作效率。只好忍痛把家里的明基显示器带到公司去使用。而 Studio Display 作为苹果推出时间不久的显示器，之前一直有种草。其显示效果是业界有目共睹的。但是这款显示器的摄像头以及麦克风的收音效果据说都还好，虽然对于我来说没有特别大的区别。
这款显示器支架有三种版本，普通支架，可升降的支架以及 vesa 版本。vesa 版本和普通支架的价格是一样的，但是普通支架占地方不说，而且调节的范围非常有限。之前明基显示器也是通过乐歌的显示器支架来使用的。之前也一直后悔 iMac 没有选择 vesa 版本，后来还是买一个魔改的配件来配合使用。关于 iMac 的使用体验，可以参考之前的这篇文章。所以这次毫不犹豫地选择了 vesa 版本，不过 vesa 版本等货的周期更长，差不多要晚半个月的时间。最终，也是等了一个半月才拿到了显示器。
开箱 显示器到手之后就是开箱。说实话，这个箱子和当初的 iMac 有一点类似，箱子都非常大。本来想拍一个开箱视频，但是实在是不好开箱，就简单地录了一点点视频。显示器的包装还是传统的牛皮纸箱加内包装的组合，打开来除了比较大而已，其实还是非常方便的。配件也非常简单，显示器主体，连接在一起的电源线（注意电源线是不能拔掉的），还有一根雷电线，可以直接通过 type-c 接口连接电脑。对于 vesa 版本一开始还想会不会提供螺丝，结果找了半天没有，后来在网上也看了别人的介绍，vesa 版本的确也是没有提供螺丝的。
简单的开箱视频：
https://www.bilibili.com/video/BV1NB4y1t7eb
然后就是把明基显示器拆下来，把新的显示器装上去。过程还是比较简单的，基本就是拆拆螺丝，拧拧螺丝而已。最终显示的效果还是比较满意的，虽然说这款显示器和之前的使用体验上来说可能并没有什么质的飞跃，但是看着就很爽。不过貌似是新的显示器比以前的要更重一些，现在在使用升降桌的时候，升到高的时候，比以前更容易晃动。这可能是相对于以前来说使用体验比较下降的一个点之一吧，不过总体来说并没有什么大的毛病。
使用体验 这款显示器使用也有将近两个礼拜的时间。说实话和以前的体验并没有本质的区别，可能实际的性价比并没有那么高。但是这款 5k 屏的素质还是非常高的。同时也为了使用这款显示器，也把自己一直使用的 Catalina 系统升级到了最新的版本。老的版本似乎有一些奇怪的 bug，而且还有一些功能不能使用，虽然还是比较喜欢以前的老系统。但最终为了配合使用这款显示器，还是对系统进行了升级。
不过这款显示器最让人惊艳的可能就是扬声器了，感觉音响的效果非常好，虽然我这个木耳可能并不太会欣赏。但明显可以感觉到和以前的 iMac 自带的扬声器还是有着很大的区别。至于人物自动居中的这些功能对于来说并没有什么卵用，所以也暂且不提。不过这款显示器继承了一个 A13 的芯片，未来可能会升级更多的功能。</description>
    </item>
    
    <item>
      <title>Shopee 靠谱内推</title>
      <link>https://madneal.com/post/shopee/</link>
      <pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/shopee/</guid>
      <description>岗位 目前 Base 有新加坡、上海、深圳、北京等地、覆盖各种岗位，包括开发、QA 、PM 、运营、安全等各种岗位。
岗位参考链接 https://app.mokahr.com/recommendation-apply/shopee/2964?sharePageId=1477124&amp;amp;recommendCode=NTALl86#/
校招 https://app.mokahr.com/recommendation-apply/shopee/2964?sharePageId=1480471&amp;amp;recommendCode=NTALl86&amp;amp;codeType=1#/jobs?zhineng=111395
薪酬范围 可以参考 Boss 直聘上岗位薪酬范围：
https://www.zhipin.com/gongsir/0e1bc15942b85a7d1nB90ty8.html?ka=company-jobs
目前股价是非常具有性价比的。
投递方式 自主投递 https://app.mokahr.com/recommendation-apply/shopee/2964?sharePageId=1477124&amp;amp;recommendCode=NTALl86#/
点击链接，参考自己心仪的岗位投递即可。
邮箱投递 邮件标注自己希望投递的岗位以及 BASE ，以及你的个人简历。邮件发送 hacknanahack@gmail.com 即可，邮箱会实时更新进度。
福利  薪资对标大厂，15 薪保底，现在股价具有性价比。 五险一金+商业保险（试用期即可使用） 15 天年假（新加坡 18 天），14 天带薪病假 无限量水果零食供应，还有冰淇淋供应 年度旅游、季度团建 每月健身补贴（部分 office 是自己的健身房） Orange Day ，公司每个月末周五特色活动，迎接新人、寿星生日等，游戏+下午茶形式 Open Day ，与老板面对面建言献策、自由交流的机会 每年都有五千培训经费，可以用于报名考试学习报销  热招岗位 金融信贷-后端开发专家/Leader
Shopee Express后台开发专家/Leader
保险业务后端开发专家/Leader
Shopee Express 前端开发专家/Leader
资深/专家数据开发工程师-用户画像方向
Shopee Express资深Golang开发工程师
Shopee Express后台开发工程师
保险技术中高端	Multimedia Center
金融风控后台负责人
RTC音视频SDK专家/Leader（深圳）-Multimedia Center
视频转码后端Leader（深圳）-Multimedia Center</description>
    </item>
    
    <item>
      <title>停车被蹭的那些小事</title>
      <link>https://madneal.com/post/shanghai/</link>
      <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/shanghai/</guid>
      <description>自从有了车之后，停车似乎就变成生活中最大的烦恼之一。而停车停着不动被别人蹭，那就烦恼加倍。而被人蹭了还找不到人，那则是烦恼再加倍。被蹭了找到了人，别人不承认，然后你还没有直接证据，烦恼又又加倍。那如果用二进制表达的话，那么就是 1111，就有 15 倍烦恼了。前段时间已经是我停着不动，第三次被人蹭了，而且基本上只有第一次人都是直接在现场的，后面都是基本确定了作案对象，但是由于没有直接的视频证据，所以也没有办法。
第一次是在公司园区的地下停车场，当时一个十字交汇处人一直挺多的，走来走去。我就在那停车等待。大聪明急不可耐的冲了过来，左转，充满自信的把我蹭了个满怀。我当时真的是。。。这个人本来还说要跟我责任一半一半，他说我压了道路线。这里想解释下为什么压道路线的问题，因为右边都是停车位，而且很多车的车头都会露出来，所以会往左边开一点。后来打了110，当场民警是不愿意定责的，不过他还是讲了这个责任主要还是在于他没有把握好距离导致的，最后他还是认了全责。
https://www.bilibili.com/video/BV16M4y1L73L
这里的保险过程也比较简单，他报了保险，保险要了双方的驾驶证和行驶证，以及 4s 店的地址。定损由于责任清晰，定损员也没有过来定损，直接通过照片定损的。像这种发生事故其实是特别坑的，保险不会赔偿你的时间，你还要过去修车，修车过程中还要耽误用车。而且如果你的车比较新，别人也不会给你折损费。一开始保险公司定损的价格过低，保险杠当时车灯附近当初已经有好几处已经扭曲了，保险公司想做修复，4s 店说做不了，后来才同意换新的。这里涉及到另外一个潜规则，一般来说保险公司都想能修就修，所以他们会把零件自己带出去修，而车主当然是希望换新的，尤其还是别人的责任的情况。所以，这种情况还是需要 battle，当然一般小的保险公司，甚至包括平安，评价都很不好，赔偿的时候不痛快。好像只有人保比较爽快，但是人保的保费又比较高。当时整个上海都没有保险杠，我顶着破保险杠开了半个多月，然后修车也等了好几天。
第二次，其实也是在园区停车场，不过这一次当时没有发现，发现的时候已经是第二天。后来去翻了下行车记录仪，应该当时是一辆大众倒车入库的时候蹭到了我车的右前方。但是行车记录仪只有缩时录影，这种一般都是几十秒拍一张照片，而且没有声音，所以这种视频证据也很难拿出来作为直接证据。因为当时是周五，园区的物业只有周一才上班。周一上班的时候才联系上物业。我原本以为车位前面那个圆圆的是摄像头，后来物业那个是检测车位是否占用的，另外一个角度有摄像头，但是被一个大柱子挡住了。当时是通过 imagemagick 把视频分割成照片，然后再自己组合起来合成一个帧率低的一个视频。这样获取到了车牌号，后来报警，通过警察对方联系了我，我把这个视频给她看了，她的车身左侧位置的确是有一道划痕，但是她不承认就是这一次蹭的。她说她自己经常蹭这蹭那，不一定就是我的车蹭的。因为没有直接的视频拍到接触画面，所以这一次事故也没有办法。而且这一次报警，警察连来都不愿意来的。
https://www.bilibili.com/video/bv14S4y1E7e
第三次，就是最近的一次了，停在小区。当时车辆有震动告警了，然后我就下去了看了，然后发觉是有工人在搬空调。当时就问他是不是搬空调时不小心蹭到了，对方很激动地否认了。继续报警，警察过来看了，然后看了四周没有摄像头，就说应该不行了。其实当初远处一个摄像头，但当时警察说肯定拍不到，也就没有看了。后来问了邻居，邻居说可以看到的。后来就去找物业看监控，的确是能看到那个时间点，他们在面包车车尾处下货，但是他们的车身已经把前面全部挡住了，所以根本看不到后面。这一次虽然报了警，还去做了笔录，但是依然没有什么卵用，还是得自己去修车。
所以停车被蹭几乎是个无法解决的问题，这是一个薛定谔的猫，你也不知道什么时候会发生。如果能够遇到素质高的人，能够主动承认就已经非常不错了。当然对于这种情况也想到了以下几种尽可能能够去追回肇事方的方法：
 监控 行车记录仪 哨兵模式  监控是最有效以及最直接的证据。而且一般监控其实覆盖的距离还是比较远的，所以停车的时候可以尽量找那种摄像头可以覆盖的区域。一般这种区域都是停车场主干道附近，以及一些交汇处。不过这个也需要结合时间段来去找，如果车子有震动告警，这样会比较好找一些。
接降压线的行车记录仪理论上是可以做到24小时监控的。但是一般会有电压保护，防止小电瓶没有电，所以可能有的时候电压保护就断电了。另外，就是普通的可能是缩时录影，一般一分钟或者几十秒拍一张照片，这种视频也难以作为直接证据。但是如果是正常录制的话，可能录不了特别长的时间，往往可能只能录满几个小时。所以，行车记录仪往往也只能作为辅佐手段之一。
目前很多新能源汽车已经有哨兵模式了。这种模式下发生震动事件后，会自动记录四周的照片和一点点视频，这个往往是比较好用的。但是小鹏有一个缺点，就是哨兵模式需要手动开启，所以会经常忘记。</description>
    </item>
    
    <item>
      <title>第一款Goland的SCA插件开发之旅</title>
      <link>https://madneal.com/post/goland-plugin/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/goland-plugin/</guid>
      <description>插件开发，是一件即快乐又痛苦的事情。快乐的是你可以根据自己的需求通过插件来进行实现，比如经常看到的 Chrome 的插件开发。插件对于应用的原生生态有着很大的益处，往往那些特别优秀的插件甚至会被官方收编或者在正式功能中加入插件的功能。痛苦的是你需要去看文档，看插件开发的各种文档，如果文档不详细的话，痛苦加倍。程序猿最讨厌的事就是看别人的文档以及自己写文档。当然，除了文档，作为小白你还会踩到各种各样的坑。
先吐槽 五一期间，疫情实在是憋得无趣，于是就成生了编写一款 Goland 上的 SCA 检测的插件的想法。Jetbrains 作为一个 IDE 开发公司，通过 Java 的语言生态开发出 IDEA 全家桶系列如此精美并且功能强大的 IDE 产品。其背后的技术能力不得不让人折服。IDE 是程序猿开发的生产力，而 Jetbrains 公司则是生产力的生产力。这几天，笔者就在着力开发一款针对 Goland 的第一款 SCA 检测插件。相较于以往 Chrome 或者 Burp 的插件开发而言，Jetbrains 插件开发的难度大大提升，主要是因为以下几点原因：
API 文档过于简单 IntelliJ 只提供了官方的文档地址。这里面包含了一些 API 的实现以及介绍，但是太简单了。全篇中几乎找不到相关实现的示例代码，通常只有寥寥数语的介绍。举一个例子，希望能够通过插件能够创建文件，在找遍了官方的文档后，只发现了以下内容：
文档里面提到可以使用 PsiDirectory 中的 add 方法来保存 PSI 文件，但它没说 HOW！那怎么办，只能去 Github 中去搜索代码关键字，然后扒别人的代码去看别人是如何实现的，这绝对是一个非常痛苦的过程，尤其是你看的是一个实现很糟糕的插件。
API 复杂性 由于 IDEA 强大的生态，其 API 要考虑到兼容性以及很多特性，所以 API 中很多的含义不好理解。其本身也是包含了很多复杂的配置项，同时还需要综合考虑插件是通过什么样的形式去实现。
太“强大的”官方模板 官方提供了一个创建插件的模板。首先承认的一点是这个模板的功能非常强大，涵盖插件开发、单元测试、质量检查、发布的整个生命周期，并且与 Github 无缝集成。不过作为模板，它包含的内容是不是太多了呢？这个模板的 README 几乎看了3遍之后才知道里面包含了哪些内容。实际上，对于一个小白来说，这个过程挺痛苦的，甚至可能有的人看了一下就萌发了退意。里面的一些模块，比如单元测试模块以及覆盖率检查这些模块，可以作为可选项，并不一定要默认就包含进去。
Bug 有一点点多 目前尚未确定是否这是一个 Bug，但是笔者严重怀疑这是一个 Bug。上面提到的模板，通过 Gradle 实现了一系列的任务。在 Run Verifications 中，有个小任务是 .</description>
    </item>
    
    <item>
      <title>goland-2022.01版本最新实用功能</title>
      <link>https://madneal.com/post/goland/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/goland/</guid>
      <description>在 Go 的开发过程中，经常遇到一个非常麻烦的问题就是 JSON 的解析。因为 Go 中的 JSON 的解析，一般来说需要定义对应 JSON 的 struct。或者使用 interface{} 类型来进行定义，然后再进行类型的转换。当然这在 Python 中可能两三句话就搞定了。
在 Goland 2022.01 最新版本中，终于迎来了在 JSON 方面解析的便捷功能。在最新版本中，只要将 JSON 粘贴到 IDE 中就会提示是否转化为 struct 类型，所有的字段都会被生成，相对于以前的一个个的手动的定义要方便太多太多了。
还可以使用 Action 来进行转换动作，Generate Go Type form JSON：
同时还可以添加新的 tag，key 以及修改 key 的代码风格，调用来说一般使用 alt+enter 快捷键即可。
Intention actions 字段添加新的 tag
 点击 struct 的字段然后按 alt+enter 选择 Add key to tags  修改 key
 点击 struct 的字段然后按 alt+enter 选择 Update key value in tags  修改 key 的代码风格</description>
    </item>
    
    <item>
      <title>gobuster源码阅读--终篇</title>
      <link>https://madneal.com/post/gobuster3/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/gobuster3/</guid>
      <description>在搞完 gobuster 系列源码阅读的第一篇以及dir篇之后，对于 gobuster 的实现思路已经比较熟悉。本文就对剩下的模块进行一个讲解，由于一些公共模块在前面的两篇文章中已经提过，所以本文主要专注于每个模块所独有的部分。
在前面的文章中提到过，gobuster 中的各个模块中的核心功能都是基于 libgobuster/interfaces.go 中接口的实现。而 PreRun 以及 Run 函数则是每个模块实现的核心所在，所以关注其它模块这两个函数的实现的即可。
dns 对于 dns 模块中的 PreRun，其内部也有一个 ErrWildcard 的实现。其实现过程也有一点类似于 dir 模块。通过将 uid 和 domain 进行拼接，理论上这个域名应该不存在，会报一个 no such host 的报错。如果不存在这个报错，则表明对于任意域名都会解析成同一个 IP。如果没有报错，则表明这里可能存在 ErrWildcard。
wildcardIps, err := d.dnsLookup(ctx, fmt.Sprintf(&amp;#34;%s.%s&amp;#34;, guid, d.options.Domain)) if err == nil {  d.isWildcard = true  d.wildcardIps.AddRange(wildcardIps)  if !d.options.WildcardForced {  return &amp;amp;ErrWildcard{wildcardIps: d.wildcardIps}  } } 在通过 PreRun 函数之后，即是 Run 函数的实现，这个函数的实现基本上逻辑非常简单，就是解析出域名对应的 IP 即可。
s3 s3 模块主要用于亚马逊云存储桶的包括，里面的实现逻辑比较简单，主要是基于 https://%s.</description>
    </item>
    
    <item>
      <title>gobuster源码阅读--dir篇</title>
      <link>https://madneal.com/post/gobuster2/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/gobuster2/</guid>
      <description>在本系列的第一篇中，主要阅读了 gobuster 入口的这一部分。后续主要是阅读各个模块工作的细节，本文主要讲解 dir 模块。dir 模块主要是实现目录爆破的功能，其主要命令行配置项包括以下内容：
Usage: gobuster dir [flags] Flags: -f, --add-slash Append / to each request -c, --cookies string Cookies to use for the requests -e, --expanded Expanded mode, print full URLs -x, --extensions string File extension(s) to search for -r, --follow-redirect Follow redirects -H, --headers stringArray Specify HTTP headers, -H &amp;#39;Header1: val1&amp;#39; -H &amp;#39;Header2: val2&amp;#39; -h, --help help for dir -l, --include-length Include the length of the body in the output -k, --no-tls-validation Skip TLS certificate verification -n, --no-status Don&amp;#39;t print status codes -P, --password string Password for Basic Auth -p, --proxy string Proxy to use for requests [http(s)://host:port] -s, --status-codes string Positive status codes (will be overwritten with status-codes-blacklist if set) (default &amp;#34;200,204,301,302,307,401,403&amp;#34;) -b, --status-codes-blacklist string Negative status codes (will override status-codes if set) --timeout duration HTTP Timeout (default 10s) -u, --url string The target URL -a, --useragent string Set the User-Agent string (default &amp;#34;gobuster/3.</description>
    </item>
    
    <item>
      <title>gobuster源码阅读--入口篇</title>
      <link>https://madneal.com/post/gobuster1/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/gobuster1/</guid>
      <description>gobuster 作为一款信息收集工具，深受安全业界的欢迎。希望通过阅读优秀工具的源码，能够了解其工作的具体细节，为自己日后造轮子也做好准备工作。
入口 得益于 Golang 的跨平台属性，其编译过程极其简单，编译的结果直接为二进制程序，可以直接使用，这也是越来越多安全工具选择 Golang 的原因之一。对于每一个 Golang 项目，其根目录下都有一个 main.go 的文件，gobuster 也不例外。
func main() { 	cmd.Execute() } 这里即是作为程序的入口来展开这次代码之旅。Execute 其实主要是接受程序中断的信号做相应的处理操作，里面的主要涉及的知识点为 context 以及 Signal，前者主要是为了方便程序的取消、退出，后者则是捕获系统中断的信号。Notify 函数负责将 signal 一直传送到管道 c，这个函数可以一直调用。直到调用 sinal.Stop 的时候，signalChan 中的 sinal 则会被清空。这一段代码里面的内容主要是 signal 这一块的内容，可以参考 Golang 的官方文档，里面讲的非常的详细。
func Execute() { 	var cancel context.CancelFunc 	mainContext, cancel = context.WithCancel(context.Background()) 	defer cancel()  	signalChan := make(chan os.Signal, 1) 	signal.Notify(signalChan, os.Interrupt) 	defer func() { 	signal.Stop(signalChan) 	cancel() 	}() 	go func() { 	select { 	case &amp;lt;-signalChan: 	fmt.</description>
    </item>
    
    <item>
      <title>SAST 测试中要测量的三个参数</title>
      <link>https://madneal.com/post/sast/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/sast/</guid>
      <description>原文：3 parameters to measure SAST testing
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 在我们之前的博客中，为什么你不能仅使用列表、测试套件和基准测试来比较 SAST 工具，我们探索了当今常用来评估和比较 SAST 测试工具的各种工具和指标。我们还研究了为什么这些工具可能会产生不一致的结果并且对于评估 SAST 测试工具可能根本不可靠的一些原因。
相反，在评估 SAST 测试工具时，你需要考虑 3 个参数：
 准确性 完整性 任意其它独特价值  在本文中，我们将探索这些参数并研究测量它们的方法。在评估 SAST 测试工具时，有两种相关类型的测量 - 定量（意味着结果的数量与“误报”）和定性（特别是语言深度和支持）。
定量方面 以下对准确性和完整性的定义起初有点复杂，因为它们实际上是同一枚硬币的两面。数学上不可能（根据赖斯定理）进行完美的静态程序分析。人们可能会认为增加建议的数量会发现所有可能的问题。可悲的是，这也会将误报 (FPs) 的数量达到干扰让结果无法处理的级别。SAST 测试供应商可以使用一些技巧来改进结果，但在数学上完美是不可能的。
准确性 在 SAST 测试的上下文中，准确性被松散地定义为具有最高数量的 TP（真正类，即实际问题的发现），同时保持最少数量的 FPs（误报，因此是错误的）。
准确性尤其重要。高准确率意味着我们可以获得更有价值的结果，以及更少的“噪音”（不相关的、无法操作的报告）。“噪音”也是阻碍开发者使用 SAST 测试产品的第一大因素，这就是为什么准确性越高，整体开发者体验就越令人满意的原因。
为了计算准确性，你首先需要对结果进行分类。那么公式就是 TP*100/(TP+FP)。这将产生一个介于 1 到 100 之间的数字。数字越大，准确度越高。例如，找到 140 个 TP 和 40 个 FP 的工具的准确率为 77.</description>
    </item>
    
    <item>
      <title>hey,我能看到你的源码哎</title>
      <link>https://madneal.com/post/webpack/</link>
      <pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/webpack/</guid>
      <description>最近偶然间有看到某家的一个站点中的网站中的前端代码的“泄露”。此处的泄露为什么打引号，因为一般来说网站的前端代码都是可以通过浏览器即可访问。但是一般生产环境中的 JavsScript 代码都是经过压缩和混淆的，所以可读性大大降低，这也提升了从前端的角度挖取更多信息的门槛。这里的泄露指的是在 Chrome 浏览器的 Sources 面板中可以看到完整的以及原始的前端代码。
通过这样的源码，可以非常清晰地了解应用的前端业务，包括接口信息，如果前端包含加解密的逻辑的话，这样也非常有利于攻击者进行破解。
目前市面上绝大多数应用都是前后端分离，基本上绝大多数是基于 Vue 或者 React 这样的前端框架。而大多数应用配套的构建工具则是 Webpack。而这种源码的泄露真是因为 sourceMap 而导致的，但是这种配置在前端开发环境中是必不可少的，因为如果缺少了 sourceMap 那么前端开发者就无法进行前端代码的调试，sourceMap 正是帮助开发者进行前端代码的调试。通常通过 devtool 的配置即可开启 sourceMap，Webpack 会为相应的 js 文件生成对应的 map 文件，在 js 文件的最后一行会有 sourceMap 的申明，表示 map 文件的地址。
module.exports = { ... devtool: &amp;#39;source-map&amp;#39;, ... } 市面上的绝大多数浏览器都是支持 sourceMap 的，Chrome 浏览器默认支持。打开浏览器的开发者工具，在 Sources 面板中的设置可以看到相应的配置项，勾选后即可在面板中看到对应解析的源码。
不过大家可能有一个疑惑，在 Chrome 的 Network 面板中看不到 map 文件的网络请求。但是如果直接使用抓包工具去抓包的话，是可以看到对应的 map 文件的请求的。通过 chrome://net-export 可以捕获请求，通过 https://netlog-viewer.appspot.com/#events 即可查看捕获的日志文件，可以看到对应的 map 文件的请求记录。
毫无疑问，sourceMap 如果在生产环境开启的话，必然具有一定的安全风险，因为从很大程度上帮助攻击者了解应用，获取应用的更多信息。那么，我们是不是可以写一个 Chrome 插件来检测这种问题并且来直接进行源码的下载呢。实现这样的插件不是件很困难的，检测 js 文件请求，然后尝试请求对应的 map 文件。有不少开源库能够进行 sourceMap 的解析，Mozilla 的 source-map 即是一个能够解析 sourceMap 的 js 库，亦可以通过这个库生成 js 的对应的 sourceMap。</description>
    </item>
    
    <item>
      <title>基于golang实现报告生成技术方案</title>
      <link>https://madneal.com/post/go-report/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/go-report/</guid>
      <description>最近在做一个基于历史数据生成报告的需求，在做这个需求的时候遇到过一些小坑，所以想在这篇文章分享一下踩坑经验。
最初的需求是基于历史数据来生成一个 word 报告，这种需求其实在大多数应用中也算比较常见的需求。但是由于我们使用的语言是 golang，而 golang 关于 word 方面的轮子是少之又少，只有一个国外的商业产品以及极少的特别不成熟的库，比如做一些简单的文字替换的，这些都比较难以满足需求现状。也不可能为了这么个需求就造一个 word 方面的轮子，况且还不一定造的出来。这种方案实现，如果是使用 java 或者 python 会轻松很多，的确 golang 在某些方面的轮子还是存在缺失。后来想到的方案是，先渲染 html 模板，然后再把 html 转成 pdf。渲染 html 不然，基于 template，理论上可以实现任意文本格式文件的填充，但是转 pdf 又又涉及另外一个轮子，也是一番调研，有一些，但是不太多，看起来也不是特别好用。同时，这个方案也不是很优雅。就在一筹莫展之际时，我想到我们内部其实非常热衷于通过自研的 wiki 平台来分享报告，大家分享的时候也经常通过这个平台来直接链接。（其实中间也看了腾讯文档的开放平台，但是这个开放平台根本就不成熟，都没有开放写入的能力，只开放了创建文档的 API，不能写入，那能有啥用呢。）后来找对应平台的开发聊过，幸好他们提供写入的 API，这样实现报告的方案就实现了。平台支持 markdown 的语法，只需要通过 markdown 的语法来渲染好模板，然后写入就可以了。随便提一句，任何不支持 markdown 语法的编辑器都是极其不友好的，所以非常难理解当初 freebuf 改造 markdown 编辑器居然花了一两年的时间，不知道是如何做到的。其实，我自己都为这个方案拍案叫绝，不过这好像也是唯一能实现的技术方案，但在我看来，也是最优雅的实现方式。
这个需求另外一个小坑就是图标的实现。wiki 平台自身没有提供基于数据实现图表的功能，所欲图表的需求是需要我们自己来实现的。这种最能想到的方式就是基于数据生成图表的图片，然后插入到 markdown 中。在调研图表的方案中，是有看到一个 go-chart 的方案。但是这个库看起来可定制型不是很高。echarts 是前端领域大名鼎鼎的数据可视化方案，可以说的上是百度做的开源精品，现在已经属于 apace 基金维护的开源产品。go-echarts 是一个基于 echarts 的 golang，其本质应该还是通过 echarts 来渲染前端。所以在使用这个库的时候有一个问题，它不会直接生成图片，而是通过 html 来进行渲染的。那么在嵌入图表的时候就不能使用图片，但是正因为之前使用的方案是 markdown，且一般来说大多数 markdown 是兼容 html 的，所以只要将 html 通过 iframe 的形式嵌入，那么这个问题也就迎刃而解了。
&amp;lt;iframe src=&amp;#34;%s&amp;#34; frameborder=0 width=&amp;#34;1000&amp;#34; height=&amp;#34;600&amp;#34;&amp;gt;&amp;lt;/iframe&amp;gt; 同时得益于 echarts 的灵活，这个方案也可以实现高度定制化的可视化方案。不过这个库并没有丰富的文档，大多数的使用教程都是通过 examples 里面的代码样例来进行说明，这个仓库里面有很多图表的各种形式展现的代码样例。不过在图表的时候也遇到一些问题。比如 x 坐标轴的 label 文字过宽，导致容器容纳有问题，这个一般的做法都是将 label 进行旋转，这在 echarts 里面也是比较常见的做法，在 go-echarts 里面有一定的配置语法。</description>
    </item>
    
    <item>
      <title>文武双全，看我如何过CISSP</title>
      <link>https://madneal.com/post/cissp-domain1/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/cissp-domain1/</guid>
      <description>2020年我有拿到 Offensive Security 的 OSWE 的认证，这个认证算得上是应用安全代码审计方面含金量比较高的认证。当初，我也写过一篇文章「一键 Shell，我的 OSWE 之旅」分享了课程学习和备考的经历，感兴趣的同学可以看看这篇文章。在考完 OSWE 之后，就考虑去考一下 CISSP，毕竟 CISSP 算是国内目前安全领域内认可度比较广的证书之一了。同时，也是为了证明自己在安全实战和理论方面都有所掌握，拿到认证并不代表什么，但是取得认证的过程却是大有裨益的。下面就分享一下在 CISSP 准备过程中以及考试的一些经验。
考试报名 我的 CISSP 备考过程是没有参加任何培训的，也没有做过什么培训班的题目，主要的复习资源都是官方的材料。其实，在2021年初当时就有考试的计划，不过当时也没有明确的目标，也就偶尔翻了一下书。直到年末才开始认真准备，差不多3个月左右的准备时间，提前1个月预约了考试时间和考点。上海一共有2个考点，一个在人民广场一个在徐家汇，都是比较市中心的位置。如果有过几年的安全经验的话，两到三个月的备考时间是比较合适的。因为 CISSP 预约考试之后换预约时间是需要再付费的，所以建议还是确定好考试时间再注册报名考试。当时我做 Practice Test 的准确率差不多有 80% 左右，感觉差不多了就报名了考试。可能一开始没有合适的时间，可以没事多看看，看到合适的时间就果断的报名考试。值得注意的一个点是考试报名的时候应该把名放在前面，一开始我以为是要和中文拼音保持一致的，后来考点的人和我说还是要调整过来的。
备考 教材的选择可以说是准备考试的第一步。因为考虑到教材的准确性和翻译问题，备考过程中我看的全都是英文的教材，包括像 Official Study Guide 以及 All in One，习题做的就是 Practice Test。英文教材的表述会更地道，更准确，另外一点就是英文教材已经更新到第9版了，中文教材还没有更新。Practice Test 的最新版本是第3版。
OSG 和 AIO 的选择，我强烈推荐 OSG。OSG 和 AIO 对比下来，感觉逻辑更清晰，知识点更明确，AIO 感觉更像是知识点的延伸，所以有的知识点讲的特别发散。当然如果准备时间比较充裕，也可以看看作为一个补充。对于 CISSP 的八个 Domain:
 Security and Risk Management Asset Security Security Architecture and Engineering Communication and Network Security Identity and Access Management Security Assessment and Testing Security Operaions Software Development Security  我本身主要是参与最后3个 Domain 的相关工作，不过这三个 Domain 在知识点占得比重不能算很多。第一个 Domain 是教材中篇幅最长的，可见其重要程度。风险是 CISSP 中非常重要的一个概念，很多的知识点都是围绕着风险展开的，所以对风险务要有深入的理解。</description>
    </item>
    
    <item>
      <title>安全运营平台从0到1</title>
      <link>https://madneal.com/post/sop/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/sop/</guid>
      <description>本文首发于安全客平台，https://www.anquanke.com/post/id/266237
笔者作为某公司的安全开发独自一人负责安全运营平台的开发，经过数个月的折腾以及其他安全同学的合作，目前该平台已经运营了几百个安全漏洞以及一些安全事件，其它一些安全能力也在慢慢地接入中。在之前的公司，笔者也是作为安全工程师负责平台架构部门的安全运营，当时我们也有几个开发来负责安全运营平台的开发。安全运营平台其实可以作为一个公司偏向应用安全的基建之一，或许可以将它看做偏向于应用安全的 SIEM。所以，基于本文，也想分享一下在安全运营平台建设和开发的过程中的经验。在整个建设过程，开发工作只是一部分，体系的建设和实现也不可或缺，所以很多做法也是需要结合公司的实际情况，并一定就能够完全通用。
开发 安全运营平台的开发技术选型其实和其它后台业务类型的系统并不会有太大的区别。目前大多数应用系统都是采用前后端分离的方式，前端大多数是类似于 vue-admin 类型的技术方案。后端框架见仁见智，选择适合内部开发的语言即可。笔者之前最早实习的时候就是干前端开发的，后来干安全也是经常会写安全工具的代码，所以常用的语言也是都略懂一些，所以也就扛起了这个平台的开发工作。
最初的技术选型是想选择 gin-vue-admin，这是个前后端分离方案。后端基于 go 的 gin 框架，前端是和 vue-admin 比较类似的前端方案。这个轮子用起来不错，有很多开箱即用的功能，权限方面管理也非常方便。不过最终还是没有采取这个方案，因为内部的大多数应用都是基于内部自研的 go 微服务框架，其部署运维也与该方案息息相关。如果不使用内部的框架在部署方面则会麻烦很多，考虑到后期的运维，最终还是选择了基于内部的微服务框架开发。不过，这样做的最大的问题就是学习成本，因为这个内部框架与外部的 web 框架差异较大，而且作为安全的唯一开发也是两眼一抹黑，只能跟在开发大佬后面跪舔，才慢慢把应用的雏形搭建起来。前端框架比较简单，主要是基于 element 的 Vue 框架。
其实在开发过程中要说技术难度有多大也不见得，和其它的业务系统其实没有太大的区别。主要就是各种和头发丝一样琐碎细小的业务需求，所以开发过程就好比把这些头发丝一根根捡起来捋直了，所以有时候也是比较痛苦的过程。前端的用户体验和设计也是痛点之一，本身安全在开发就比较缺乏，尤其是设计方面。不过安全运营平台主要面向的也是内部的用户，主要就是安全工程师和开发，所以和面向外部客户的应用相比，要求也会稍微低一点。
需求建设 对于安全运营平台的大致规划是按照下面的框架来进行划分的，大多数公司的安全运营平台也会比较类似。安全运营平台的核心是应用安全的运营，漏洞管理作为安全运营平台的核心之一，也往往是安全运营平台被开发所熟知的方面之一。另外一方面就是集成各种安全工具的数据，包括像扫描工具，包括 SAST 以及 DAST 的扫描，将这些数据能够转换成实际的漏洞来推动。
漏洞管理 漏洞管理作为安全运营平台的最基础的一方面，同时也是其核心。漏洞的本质其实也是一个 bug，只不过它被赋予了安全这一属性，摇生一变被称为漏洞。那么漏洞自然就和开发日常处理的 bug 会稍微有一些不同。Bug 的处理流程相对来说会简单一点，测试把 bug 提给开发，开发确认之后修复完成，测试验证通过就可以了。安全漏洞的处理过程其实也是基于这一个过程的演化，这也是因为安全漏洞的特殊性，安全漏洞是一种特殊的 bug。一方面，安全漏洞的机密性要求更高，漏洞的可见范围越小越好，一般仅限定为要处理的人及它的直属领导，而不是任意一个人都可以查看漏洞，这样也是为了避免万一有人通过漏洞信息来进行利用。另外一方面，漏洞的处理流程相对来说会更复杂一点。在现实业务中，可能会有各种各样的场景。正常来说，一个应用应该具备测试环境、UAT 环境、生产环境。漏洞应该在之前的环境中被验证通过后，再进行下个环境的验证，这样的好处也是避免一开始就没有修复，导致返工，也降低了风险。但是往往也有不少应用并不同时都有这些环境，比如第三方采购的应用，一般都没有前两个环境，大多数是布在生产上的。也有的应用可能也没有 UAT 环境，就只有测试环境和生产环境。我们的做法是有提供两种模式给开发选择，开发可以选择默认模式，则这三种环境都有，开发也可以选择不带 UAT 环境的。针对于只有一种环境，我们的做法是把主动权交给安全工程师，安全工程师在复测完成后可以直接关闭漏洞，不过这个的弊端就是有时候安全工程师忘记直接关闭这个漏洞。
漏洞在被确认之前可能还有一些例外情况，包括像漏洞的忽略以及漏洞的接受。漏洞的忽略主要是漏洞的一些误报，这个主要是安全工程师可能对于业务有些了解还不充分导致的一些信息差，另外还有就是有些漏洞可能就是正常的业务需求。漏洞的接受则是这的确是一个漏洞，但往往漏洞修复非常困难，或者漏洞修复对业务的影响非常大，但是漏洞的危害程度没有达到高危及以上的那种程度。其实对于这种情况一般有两种处理，一种就是安全把漏洞提给开发，但是开发就是不太愿意修复这个漏洞，这个漏洞状态就一直保持着，如果哪天开发憋不住了，或者状态场景发生了变化，他们就完成了这个漏洞的修复。另外一种情况就是业务方接受漏洞并且不修复，这种可以理解为风险接受。其实在 CISSP 中的风险管理中就有这样的概念，如果采取安全措施的代价大于资产的实际价值，那么业务方可以选择接受风险。不过对于这种情景，是需要经过业务方领导的审批，确保业务方能够明确意识到这个漏洞潜在的风险。
漏洞另外一个重要的内容就是和资产的联动。一个成熟的 cmdb 对于安全来说真的太重要了。因为这可以帮助安全迅速的定位到明确的责任人，从而确保漏洞的及时修复，其实这也涵盖其它的安全内容，包括像安全事件，甚至在安全应急响应中，好的 cmdb 对于安全来说真的非常重要。不过，安全往往不是作为 cmdb 的第一责任人，一般 cmdb 的运维职责是落在运维方，安全起到的作用是反馈和治理。安全在使用数据的过程中，及时反馈，从而帮助数据修正，这样达到一个良性进化的过程。
事件管理 事件管理和漏洞管理也不太相同，所以事件管理的流程会被单独作为另外一个流程来进行管理。事件不同于漏洞，它往往也没有上文提到的各种的环境。事件的处理往往也是一个点对点的过程，安全工程师确认了安全事件，将事件上报给对应的处理人，处理人处理完毕，安全工程师验证没有问题，安全事件就可以关闭了。目前的安全事件的功能还是比较弱化的，主要还是用于事件的处理流程。不过未来事件流程最重要的方面是和其它安全平台的对接，包括与 SIME、IDS 等安全产品对接，并且能够将事件直接分发给对应的处理人，提高事件的处理效率。
安全能力 作为安全运营平台，SAST 以及 DAST 也是作为应用安全重要的补充能力。SAST 以及 DAST 市面上都有很多成熟的产品，也有很多公司采取自研方案。对于这两种产品最重要的能力就是数据的打通，如何将这两种产品扫描出来的漏洞直接转化为实际有效的漏洞。前期对于这种漏洞比较好的处理方式，可能是先同步数据，然后安全运营平台作为一个审核平台，这些数据经过安全工程师的审核和加工，有效的数据将转化为漏洞进行上报。另外一个重要的方面就是组件成分分析，这也是近几年非常火的一个概念。因为目前的软件开发都是大概率依赖于第三方组件，不管是商业的还是开源的、前端的、后端的以及各种语言的，这些组件的风险都有可能会对你自己应用带来风险。做好应用的组件分析，知道应用的依赖关系，能够快速地在紧急安全漏洞爆发初做到较快的响应处置。当然，这些都建立在资产都能够与这些信息打通的基础上，这样才能做联动响应，根据资产去盘点漏洞，同时也能够根据漏洞去看哪些资产受影响。
安全运营平台除了这些大的方面，其实也有很多细节方面需要考虑。比如像漏洞级别的定级，不同级别的漏洞对应着不同的威胁程度，那么其要求的修复时间也是不相同的。对于漏洞的响应时间应该是按照自然日来算的，因为攻击者并不会因为是休息日就鸣金收兵的。对于漏洞的定级，其实业界有一个比较成熟的定级模型，叫做 DREAD，即：</description>
    </item>
    
    <item>
      <title>电车的高速之行</title>
      <link>https://madneal.com/post/highway/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/highway/</guid>
      <description>上周末回了一趟老家，高速来回行驶了800多公里。所以我很想结合这一次的高速的经验分享一下电车的高速形式经验，或许也能帮助一些鹏友解答电车在高速形式上面的问题。我的车之前的文章也提到过，小鹏 P7，长续航智尊版，选配了 NGP 辅助驾驶功能。当然，这篇文章的经验也主要是我本身这次的高速之行的感受，并不一定适用于所有的情况。

续航，谁先倒下？ 新能源车的续航一直是很多人对于其望而却步的主要原因，电车的续航缩水一直为人所诟病。我这辆车的官方续航标准是 NEDC 586公里，当然这个续航一般是达不到的，实际用车的话，一般都是使用 WLTP 标准。充满电，长续航版本的里程显示是504公里（WLTP标准）。如果按照120的限速跑，开空调，开音乐，驾驶能耗是16多一点。基本上500公里的续航应该能跑到将近450公里左右。这对于我回家来说，基本上够用了。
说实话，我是真实体验到人的续航和车的续航，就我而言，基本都是我先倒下。基本上开了两个小时左右，我就已经觉得很累了。所以，停下来，休息一下吃个饭什么的，还是比较合适的。只不过去程的时候我那个服务器使用的桩功率有一点低，电流只有69A，一般在城市里基本上都是200A左右。当时，也没有换桩，不知道是不是仅仅只是那一个桩的问题。不过返程的时候另外一个服务区的充电桩就还可以，电流差不多有 120 多，基本上就够用了.当然，这是在高速不是特别拥堵的情况下，我的确也没有跑过那种特别极端的情况下，那种情况可能会是另外一种情景。
辅助驾驶好不好用 这段时间辅助驾驶闹得沸沸扬扬。其实，我是觉得现在很多媒体把辅助驾驶和自动驾驶混淆了。目前国内已经上市的车，是没有车已经达到了自动驾驶的级别。自动驾驶的级别一般划分L1-L5 5个级别，小鹏宣称自己是L2.5，我们暂且也认为其是L2级别。所以，一定要分清辅助驾驶和自动驾驶，目前人还是要时刻保持关注，随时做好接管的准备，千万不要做那种毫无意义的尝试，在危险边缘疯狂试探。
小鹏的 NGP 目前支持在封闭路段使用，包括城市高架和高速。在拥堵的路段，NGP 的使用体验不是很好，因为它反应比较慢，刹车偏急，起步偏慢，所以拥堵高架体验一般。但是高速上是非常适合 NGP 使用的，800 多公里的路程基本上差不多600多是通过NGP行驶的，这极大减轻了驾驶负担。NGP 基本上在自适应巡航，跟车方面都做的比较完善。因为 NGP 结合了高精度地图，所以可以完美地通过高精度地图来辅助驾驶。所以这个方案和特斯拉的视觉方案不同，这两种方案也是各有千秋。不过依赖于高精度地图的缺点就是有的地图高精度的缺失，辅助驾驶的降级不是很完美。NGP 不能很完美地降级到 LCC。当然，其实在我看来人为接管率并没有很大影响。另外一点，如果长时间使用辅助驾驶的话也会比较疲劳，所以有时接管开一下也是蛮好的。
NGP 最值得诟病的就是双车道的高速超车逻辑。经常遇到的情况就是在左车道行驶，如果前车行驶速度变慢，就会向右变道超车。但是这种情形一般都是因为右边不远处有一辆慢速行驶的火车。如果变道到右边的车道，马上就会被那辆火车堵住，然后左边就会一直有车经过，这种情形就比较尴尬了。所以，一般双车道的超车行为都会被我立马扼杀在摇篮中。
综合来说，这次的高速之行对于我来说总体体验还是不错的。如果满分10分的话，应该可以打个7.5分。当然，这一切的体验都是基于这次的高速之行得出的。小鹏 P7 目前来看还是一个综合素质比较出色的新能源汽车，如果有朋友感兴趣的话可以使用我的试驾链接试驾。
https://events.xiaopeng.com/r18f95.html?token=2cf68377</description>
    </item>
    
    <item>
      <title>富文本场景下的 XSS</title>
      <link>https://madneal.com/post/stored-xss/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/stored-xss/</guid>
      <description>富文本编辑器是一个常见的业务场景，一般来说，通过富文本编辑器编辑的内容最终也会 html 的形式来进行渲染，比如 VUE，一般就会使用 v-html 来承载富文本编辑的内容。因为文本内容需要通过 html 来进行渲染，那么显然普通的编码转义不适合这种场景了，因为这样最终的呈现的效果就不是我们想要的了。针对于这种场景，显然过滤是唯一的解决方案了，不过过滤其实可以在后端和前端都是可以做的，后端做的话，一般是在数据存储在数据库之前。前端做的话，则是在数据最终在页面渲染之前做过滤。
前端的过滤方案，可以尝试使用开源的 [js-xss](https://github.com/leizongmin/js-xss)。先介绍一下这个库的使用方法，这个库可以在 nodejs 中使用，同样也可以在浏览中直接引入使用。
// nodejs 中使用 var xss = require(&amp;#34;xss&amp;#34;); var html = xss(&amp;#39;&amp;lt;script&amp;gt;alert(&amp;#34;xss&amp;#34;);&amp;lt;/script&amp;gt;&amp;#39;); console.log(html); // 浏览器中使用 &amp;lt;script src=&amp;#34;https://rawgit.com/leizongmin/js-xss/master/dist/xss.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; // apply function filterXSS in the same way var html = filterXSS(&amp;#39;&amp;lt;script&amp;gt;alert(&amp;#34;xss&amp;#34;);&amp;lt;/scr&amp;#39; + &amp;#34;ipt&amp;gt;&amp;#34;); alert(html); &amp;lt;/script&amp;gt; 一般在 vue 的项目中，通过 webpack 也可以直接通过 CommonJS 的方式引入，与 nodejs 的引入方式基本一致。值得注意的一个问题是，默认情况下会去禁用 style 属性，这样会导致富文本的样式展示异常，需要禁用 css 过滤或者使用白名单的方式来进行过滤。
const xssFilter = new xss.FilterXSS({  css: false }); html = xssFilter.process(&amp;#39;&amp;lt;script&amp;gt;alert(&amp;#34;xss&amp;#34;);&amp;lt;/script&amp;gt;&amp;#39;); const xssFilter = new xss.</description>
    </item>
    
    <item>
      <title>米哈游内推</title>
      <link>https://madneal.com/post/mihoyo/</link>
      <pubDate>Sat, 07 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/mihoyo/</guid>
      <description>微信扫描投递即可
社招 
校招</description>
    </item>
    
    <item>
      <title>提车二月记--小鹏P7</title>
      <link>https://madneal.com/post/xp/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/xp/</guid>
      <description>P7 提车也有两个月了，行驶基本上也有 2000 多公里。关于提车的介绍，可以参考我之前的那篇文章。经过这两个月的形势，我不仅加深了对 P7 的了解，同时自己的驾驶技术也提高了。下面，就自己这两个月的行驶感受做进一步总结。
驾驶体验 P7 的驾驶体验总的来说对于我个人来说还是非常优秀的，不过因为可能我也没有开过其它的什么车，发言权不是特别大。不过根据我爸的说法感觉还是不错的，方向盘和刹车都不错，不过刹车在某些情况下会变得很硬，不过可能与 P7 的 AEB 有关系。提到 AEB 还想提一次经历，有一次前面车突然急刹车，然后当时行驶速度比较快，我踩了几脚刹车，最后一脚重踩，可以明显感到 AEB 给刹车加了一把，虽然我自己踩应该也是不会追尾的，不过 AEB 感觉是上了一道双保险。有遇到一些鹏友吐槽 AEB 的，不过目前对于我来说，AEB 没有给我带来任何困扰，反而感觉是多了一份保障。
说完优点，就说说驾驶体验有点不太好的地方。P7 的悬挂实在是太硬了，稍微有点颠簸路面就感觉非常颠，这一点的体验是比较差的。还有就是感觉低速行驶有一些不太平的路面，左摇右摆特别的明显。
外观颜值 P7 的颜值可能是很多人买 P7 的重要原因之一。P7 的轿跑风格，那个大溜背，真的人见人爱。特别是和其它的车放在一起的时候，明显可以感觉 P7 的风格别树一帜，让人越看越喜欢。而且感觉上完牌照的 P7 比没上牌照的要好看多了。关于上牌体验，总体来说小鹏的体验还可以，我是自己在网上选号的，推荐网上选，比较方便，我是在电脑上通过网站选号的。虽然 P7 的车长有4.88米，但是由于其大溜背，所以后排空间也是捉襟见肘，不过因为平常后排也不怎么坐人，所以也还好，家里人感觉也还可以。后备箱的话，虽然是比较深的，但是高速不是很高，所以容量也是比较一般的。虽然前备箱也有，但是空间就要小得多的，而且开启也不是很方便，只能通过机械掰两下主驾旁边的开关，使用频率也非常低。


车机 小鹏的车机可以说的上是目前国内数一数二的，如果自信点，现在说是第一也不是很过分哈。车即真的非常流畅，没有任何延迟。而且车机上面的有个小优点，就是车机上的车模型的 UI 会和车的实际状态联动，比如车机上的车模型会显示你的实际号牌，并且还会同步汽车的车门开关状态以及车灯的状态，何小鹏不愧是做 UI 的。车机上面的功能划分也比较有逻辑性，会分为几个大类，切换不同的大类基本可以找到自己需要的功能。另外有一点可能有很多鹏友不知道，就是屏幕下拉会有一些功能的快捷设置，这点和手机还是比较类似的，毕竟小鹏的车机体验已经非常接近智能手机了。

不过有一点值得说的是，车机的优秀反而衬托了 APP 的薄弱。目前 APP 的功能实在是太少了，很多车机上可以看到的信息，在 APP 上却看不到。还有历史行程信息，感觉这个对于用户还是非常重要的，但是 APP 里面却看不到，甚至看不到仪表盘上面的那些行驶公里数，就只有一个总的历史公里数。感觉，这方面还是需要改进很多。不过，在车机上打开小 P 头像可以看到上一天的形式记录以及能耗方面，信息还是比较齐全的。

辅助驾驶 目前小鹏的辅助驾驶可以算得上是第一梯队，当然目前华为的极狐还没有正式量产上市。小鹏的 NGP （按导航辅助驾驶）目前的体验已经是非常好的，得益于高德高精度地图的加持，在很多地区体验可能比特斯拉的辅助驾驶体验还要好，当然特斯拉的视觉方案也很强。其实很多人对于汽车的自动辅助驾驶有一点误解，很多人以为自动辅助驾驶其实就是一个功能，其实不然。辅助驾驶里面是包含了很多项的，汽车也是通过视觉感知、雷达感知来获取大量的信息，来提升辅助驾驶能够获取的信息。现在新的辅助驾驶技术已经用上了激光雷达，这也是提高了感知的精度和范围。其实目前已有的方案并没有挖掘充分，P7 其实还是有不少算力冗余的。所以依靠现有的硬件条件，未来做到城市道路的自动辅助驾驶也不是不可能的。目前的辅助驾驶其实是一项项进阶形成的，比如车道偏离预警会在车辆偏离车道线的时候产生告警，不过在高速上有遇到过一些之前的车道线没有清除干净，导致告警并且勒安全带，感觉有点不太好。另外一些盲区安全辅助，在开门的时候有帮助，提醒你身边可能有一些突然冒出来的电动车。其它的就是 ACC, LCC, ALC 了，这些内容都是在智享版本上包含的，如果仅仅只是在城市中行驶，可能已经足够了。不过强大的 NGP 可以帮你在高架以及高速上基本上可以实现 0 干预行车，尤其高速上面的使用体验非常优秀。之前去嘉兴的高速上就使用了 NGP，那天雨下得特别大，视线非常不好，使用 NGP 反而感觉更好一些。即使在那么大雨的情况下，NGP 的使用都非常正常，体验也非常好。尤其是这次 2.</description>
    </item>
    
    <item>
      <title>技术宅的第一辆车--小鹏P7</title>
      <link>https://madneal.com/post/xiaopeng/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/xiaopeng/</guid>
      <description>写这篇文章的时候，刚刚从撞车的后悔与悲痛中慢慢恢复而来，也借此机会分享一下这段时间买车的经历吧。前段时间突然勾起来想买车的欲望，就一直想买车。因为是在上海，因为牌照的关系，加上我个人的偏好，所以我只考虑新能源汽车，我对新兴事物的接受度还是非常高的。之前其实主要考虑的就是特斯拉，不过特斯拉由于续航问题和外观原因，感觉和小鹏比还是有一些差距，当然也是因为我的一个买了小鹏朋友的安利。
买车 买车之前，几乎所有人都反对我买小鹏或者新能源车。我买车没有试驾过其它的车，只试驾了小鹏 P7，当天就订了车。值得吐槽的是，我的销售除了订车当天催我订车之外，几乎没有给过我任何实质性的建议，基本什么问题问她几乎也都是白搭，给我的承诺也没有做到（这个销售的专业能力应该是非常差的）。当然这个是销售的个人原因，和小鹏也没有太大关系的。因为贷款的原因，配车还延迟了一个礼拜，另外值得吐槽的就是中行的贷款，后面还挺麻烦的，提车当天还不能放款，后面我还是选择了全款，白白浪费了一个多礼拜，当然这里面的弯弯绕绕销售也都没有和我说过。

好像大多数销售在推荐车的时候都会推荐智享版，不过因为我本人和自动驾驶也颇有渊源。当初研究生的时候，一开始的时候搞得就是自动驾驶的方向，当时全世界搞这个的人都不多，当时因为没人交流就上也没有硬件去做，当时读论文真的很苦逼，后来为了毕业后面还是换了方向发论文，但也算是和自动驾驶结下了不解之缘。所以，纠结了一下，最后还是选择了长续航版本的智尊版本。

差不多等了一个多月，终于等到提车的日子。提车还是在军工路，特地请假去提车。整体的提车过程还是比较顺利的，基本就是看下车，因为是新车基本上也没有特别好验的。相对来说，交付比我的销售要靠谱很多。后面就是付钱，办理保险和临牌就可以。不得不说，小鹏整体的造型还是不错的，轿跑风格也是比较喜欢。整个车的风格也是越看越喜欢，提车基本就是送了一个小花篮以及水杯和雨伞，其它的没什么礼物了。



驾驶体验 我本身也是个新手，虽然驾照拿了很多年，但几乎没怎么开过车。小鹏车开起来还是比较简单和舒适的，对于新手来说还是比较友好。小鹏的车机和语音来说，在当前新能源车或者是汽车行业，也都算是数一数二的。语音交互体验比较好，基本上大多数的功能都可以通过语音交互来进行控制，当然语音有时候也有拉跨的时候，不过总体来说还是比较可以的。另外，就是这个车的空间，虽然车长有 4.88 米，但空间感觉还是一般，不过这也很轿跑造型有关系，为了外观，不可避免的牺牲了一些空间。
小鹏最亮眼的当属于 NGP了，这也是我当初为什么还是选了智尊版的原因（智尊版还需要额外2万的软件费用），因为这真的是小鹏的长处。后面也看了很多评测，感觉真的很香，感觉至少和特斯拉比是强一点的，不过如果和华为相比可能还是要差一些。毕竟目前NGP只能在高速或者高架路上开启。后来，我也体验过一两次，在高架上使用 NGP 实在是太香了，尤其是对于我这种新手来说。NGP的驾驶方式优秀，变道技术也比我好很多，所以高架上用NGP开非常的省心，这也让我庆幸当初的选择没有错。下面的这个视频也是我有天晚上全程使用 NGP 行驶的。
https://www.bilibili.com/video/BV1wN411f7hs/
不幸的事 福兮祸之所伏，祸兮福之所倚。快乐的事没过多久，不幸就随之而来。节前的最后一天，在一个十字路口调头，撞到别人车上，结果小鹏也受了比较大的损伤。当时整个人比较懵的，当天就花了很多时间处理保险和事故，然后亲自跟着拖车把车又送回了提车的地方维修。因为配件的原因，维修可能还需要比较长的时间。这几天一直处在深深地自责和后悔中，都怪自己当时不够小心，但世上没有后悔药了，一切也不能挽回。希望自己吃一堑长一智，以后一定要小心小心再小心。

你好，小P！以后我们好好相处吧。
如果对小鹏感兴趣的话，可以走我的试驾邀请链接试驾。</description>
    </item>
    
    <item>
      <title>多平台的敏感信息检测工具-GShark</title>
      <link>https://madneal.com/post/gshark/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/gshark/</guid>
      <description>GShark has beem maintained for alomost two years as an open source sensitive infomation detection tool. This tool is utilized in my own company and sparetime, multi information sensi
GShark 作为一款开源的敏感信息监测工具其实差不多维护也有两年多的时间。这款产品其实笔者在自己的公司或者平常都在使用，也通过这个工具发现多多起内部的信息泄露事件以及外部的一些的信息泄露事件。其实这种类似的开源工具数不胜数，大家的核心功能其实就是监控 Github 上面的信息，但是笔者要想把这种产品做得更好一点，就要从功能性、易用性角度来做进一步拓展。最近，对 GShark 做了较大的重构，前后端都完成了比较大的重构，之前老的版本也有写过文章介绍，所以关于这个工具的起源就不多介绍了，主要对这次重构和新的架构做介绍。
架构 目前 GShark 已经是一个前后端分离的项目，之前因为前端通过后端模板直接渲染的，所以在前端的功能性以及美观性都会差很多。新的重构是基于 gin-vue-admin，技术栈是后端通过 gin 实现，前端通过 vue-elemment 来实现。
所以架构主要就分为前端和后端两个部分，而后端则分为 web 服务以及敏感信息的扫描服务。新的架构具有以下特点：
 细粒度的权限控制，更好的安全性，包括菜单的权限设置以及 API 的权限设置 丰富的前端功能，CRUD 更简单 搜索源和之前保持一致，支持 github, gitlab 以及 searchcode  部署 之前就有想使用 GShark 的同学来和我反映，其实之前的编译就已经很简单了。但是因为有些人不太熟悉 go，所以觉得编译还是有一些问题。这一次，笔者专门写了一个脚本来发布三个操作系统下的工具包，所以直接使用即可，开箱即用，即使你不安装 go 也无所谓。
rm -rf ./releases/* cd web npm run build cd .</description>
    </item>
    
    <item>
      <title>JavaScript能否修改Referer请求头</title>
      <link>https://madneal.com/post/referer/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/referer/</guid>
      <description>正如题目，本文的也很直白，主要就是围绕这个问题展开。JavaScript 能否修改 Referer 请求头？现在 JavaScript 的能力越来越强大，JavaScript 似乎无所不能，修改一个小小的 Referer 请求头似乎看来不在话下（本文讨论的 JavaScript 仅限于在浏览器中执行，不包括 Nodejs）。
其实不然，在 web 浏览器中，绝大多数浏览器都禁止了 JavaScript 直接去操作 Referfer 请求头，当然这一方面也是出于安全方面的考虑。当然除了 Referer 请求头之外，还有其它请求头也被禁止通过 JavaScript 操作。
Referer 请求头属于 Forbidden header，这种请求头无法通过程序来修改，浏览器客户端一般会禁止这种行为。以 Proxy- 和 Sec- 开头的请求头都属于 Fobidden header name，还包括以下这些请求头：
Accept-Charset Accept-Encoding Access-Control-Request-Headers Access-Control-Request-Method Connection Content-Length Cookie Cookie2 Date DNT Expect Feature-Policy Host Keep-Alive Origin Proxy- Sec- Referer TE Trailer Transfer-Encoding Upgrade Via 可以通过一段简单的 demo 来进行验证。可以通过 Chrome 的开发者工具来进行验证，创建一个 xhr 请求，并且尝试来设置请求头。
可以看出，如果设置 content-type，浏览器没有阻止，但是如果设置 Referer 的话，浏览器则不允许，提示 Refused to set unsafe header &amp;quot;Referer&amp;quot;。</description>
    </item>
    
    <item>
      <title>微软开源对于 Solorigate 活动捕获的开源 CodeQL 查询</title>
      <link>https://madneal.com/post/ms-codeql/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/ms-codeql/</guid>
      <description>原文：微软 open sources CodeQL queries used to hunt for Solorigate activity
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 Solorigate 攻击的一个关键方面是供应链攻击，这使攻击者可以修改 SolarWinds Orion 产品中的二进制文件。这些经过修改的二进制文件是通过以前合法的更新渠道分发的，并允许攻击者远程执行恶意活动，例如窃取凭据，提权和横向移动，以窃取敏感信息。该事件提醒组织不仅要考虑是否准备好应对复杂的攻击，还需要考虑自己代码库的弹性。
微软坚信以透明的方式进行领导并与社区共享情报，从而改善整个行业的安全实践和状况。在此博客中，我们将分享审查代码库的过程，重点介绍一种特定的技术：使用 CodeQL 查询来大规模分析我们的源代码，并排除存在代码级别的危威胁情报（IoCs）和与 Solorigate 相关的代码模式。我们正在将本次本调查中使用的 CodeQL 查询开源，以便其他组织可以执行类似的分析。请注意，我们在此博客中介绍的查询仅可用于查找与 Solorigate 植入程序中的源代码具有相似之处的源代码，无论是在语法元素（名称，字面量等）还是功能上。两者可能在良性代码中同时发生，因此所有发现都需要进行审查以确定它们是否可行。此外，不能保证恶意行为者在其他操作中被约束为相同的功能或编码风格，因此这些查询可能无法检测到与在 Solorigate 植入代码中看到的策略有明显差异的其他植入代码。这些应被视为只针对攻击审计技术的一部分。
长期以来，微软一直采用完整性控制来验证分发给我们的服务器和客户的最终编译二进制文件在开发和发布周期的任何时候都没有被恶意修改。例如，我们验证编译器生成的源文件哈希是否与原始源文件匹配。尽管如此，在微软，我们仍然秉承 “assume breach” 的理念，该理念告诉我们，无论我们的安全实践多么勤奋和广泛，潜在的对手都可以同样地聪明并拥有大量资源。作为 Solorigate 调查的一部分，我们使用了自动和手动技术来验证我们的源代码，构建环境以及生产二进制文件和环境的完整性。
微软在 Solorigate 调查期间的贡献反映了我们对 Githubification of InfoSec 中描述的基于社区的共享愿景的承诺。为了保持我们对防御者知识的了解并加快社区对复杂威胁的响应的愿景，微软团队在此次事件期间公开透明地共享了威胁情报，详细的攻击分析和 MITER ATT＆CK 技术，高级狩猎查询，事件响应指南以及风险评估工作簿。微软鼓励其他安全组织开源自己的威胁知识和防御者技术来共享 “Githubification” 愿景，以加速防御者的洞察力和分析。如前所述，我们已在 https://aka.ms/solorigate 上收集了全面的资源，以提供有关攻击的技术详细信息，威胁情报和产品指南。作为微软全面调查 Solorigate 的一部分，我们检查了自己的环境。正如我们之前所分享的那样，这些调查发现有少量内部帐户存在活动，并且一些帐户已用于查看源代码，但是我们没有发现任何对源代码，构建基础结构，已编译的二进制文件或生产环境进行任何修改的证据。</description>
    </item>
    
    <item>
      <title>白名单，被谁饶过了？</title>
      <link>https://madneal.com/post/redirect/</link>
      <pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/redirect/</guid>
      <description>本文首发于安全客平台，https://www.anquanke.com/post/id/228916
起因 近期在内网发现了有个应用之前的开放重定向漏洞的绕过，通过这个漏洞绕过，我又发现了 apache/dubbo 的一个有意思的问题以及 URL 相关的话题。
之前，给内网应用提交过一个开放重定向漏洞，后面又发现这个开放重定向漏洞存在一个绕过方法。假设一个恶意 URL 为 https://evailhost#@whitehost，那么这个恶意链接依然可以实现跳转。开发说他们已经做过了白名单限制，理论上应该不存在被绕过的可能了。那么我就去看了下代码，对于重定向地址进行验证的代码类似如下。
public static String checkUrlSafety(String url, List&amp;lt;String&amp;gt; domainWhitelistSuffix, String domainWhitelist) { 	Url url2 = null; 	try { 	url2 = UrlUtils.parseURL(url, null); 	} catch (Exception e) { 	} 	String host = url2.getHost(); 	if (verifyDomain(host, domainWhitelistSuffix, domainWhitelist)) { 	return url; 	} else { 	... 	} }   private static boolean verifyDomain(String host, List&amp;lt;String&amp;gt; domainWhitelistSuffix, String domainWhitelist) { 	return domainWhitelist.</description>
    </item>
    
    <item>
      <title>火眼红队工具遭窃</title>
      <link>https://madneal.com/post/%E7%81%AB%E7%9C%BC/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E7%81%AB%E7%9C%BC/</guid>
      <description>原文：Unauthorized Access of FireEye Red Team Tools
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 概述 一个由国家支撑的顶尖的竞争者窃取了火眼的红队工具。 因为我们认为竞争者已经拥有这些工具，并且我们不知道攻击者是否打算自己使用被盗的工具还是公开披露它们，所以火眼在此博客中发布了数百种对策，以使安全社区能够保护自己免受这些工具的攻击。我们已将防御策略整合到我们的火眼产品中，并与合作伙伴，政府机构共享了这些策略，以显着限制不良行为者利用红队工具的能力。
您可以在这火眼的 GitHub 仓库中找到策略列表。
红队工具和技术 红队是一组经过授权和组织的安全专家，模仿潜在的对手针对企业安全状况的攻击或利用能力。我们的红队的目的是通过演示成功攻击的影响并向防御者（即，蓝队）展示防御方法，以改善企业网络安全。过去15年来，我们一直在为全球客户进行红队评估。截至目前，我们已经建立了一套脚本，工具，扫描器和技术，以帮助改善客户的安全状况。不幸的是，这些工具被顶尖攻击者窃取。
被盗工具的范围从用于自动化侦察的简单脚本到类似于 CobaltStrike和 Metasploit 等公开可用技术的整个框架。许多红队工具已经发布给社区，并已分发到我们的开源虚拟机 CommandoVM 中。
其中一些工具是公开可用的工具，经过修改可以逃避基本的安全检测机制。其它的工具和框架是我们红队内部定制开发。
没有零日漏洞或者未知技术 攻击者窃取的红队工具不包含零日漏洞。这些工具采用了世界各地其他红队所使用的众所周知且有据可查的方法。尽管我们认为这种盗窃不会大大提高攻击者的整体能力，但火眼会尽一切努力防止这种情况的发生。
请务必注意，火眼尚未看到任何对手散布或使用这些工具，我们将继续与安全合作伙伴一起监视任何此类活动。
有益于社区的检测 为了使社区能够检测到这些工具，我们正在发布防御策略，以帮助组织识别这些工具（如果它们在野出现）。为了应对我们的红队工具的盗窃，我们针对 OpenIOC，Yara，Snort 和 ClamAV 等公开可用技术发布了数百种对策。
可在此处找到火眼 GitHub 仓库上的对策列表。我们将发布检测，并将随着我们开发新的或改进现有检测的主机，网络和基于文件的指标的重叠对策而继续更新公共存储库。 此外，我们在 GitHub 页面上发布了需要解决的 CVE 列表，以限制红队工具的有效性。
火眼产品能够帮助客户免于这些工具攻击 火眼的各个团队都在努力制定对策，以保护我们的客户和广大社区。 我们已将这些对策整合到我们的产品中，并与我们的合作伙伴（包括国土安全部）共享了这些对策，这些合作伙伴已将这些对策纳入其产品中，从而为社区提供了广泛的覆盖范围。
有关可用的检测签名的更多信息，可以在GitHub仓库中找到。</description>
    </item>
    
    <item>
      <title>颈椎康复指南--桌面篇</title>
      <link>https://madneal.com/post/%E9%A2%88%E6%A4%8E/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%A2%88%E6%A4%8E/</guid>
      <description>最近两个月，颈椎的状态一直不是很好。左右无名指和小拇指一直都有麻的症状。后来去医院做了核磁共振，诊断结果是C3-C6的椎间盘突出。虽然后来吃药加上睡得特别早，慢慢恢复了一些，但是手麻的症状一直没有彻底好。后来，在网上有看到电动升降桌以及显示器支架这两款产品，为(jiu)了(shi)我(xiang)的(hua)颈(qian)椎，我也入了这两款产品。
电动升降桌 爱否科技有一个视频就是关于电动升降桌的介绍，感兴趣的可以看看。不过我觉得也没啥实用的。电动支架基本也就是贵一点就更好一点，升降更平稳，桌子更稳一点。我也纠结了好几款升降桌，包括京东京造的、网易严选的、乐歌的，价格从 1000 多到 2000 多，最后还是入了乐歌的 E4 双电机升降桌，2000多，是我看的里面最贵的一款，不过这个升降桌送一个显示器支架，后面我还会再说。
由于这款显示器支架在京东上是厂家发货的，如果是京东发货，隔天应该就到了。厂商发货就很慢了，催了好几次，最后是德邦快递送上门的。快递是拆分成了两个包裹，一个是桌面，另外一个是桌腿以及相关部件（超级重）。

E4 是提供一次免费上门安装的。不过像我这种心急想吃热豆腐的，当然是等不及的。总体来说，升降桌安装难度不能说特别大，基本按照说明书一步步来基本都可以装的上，就是桌腿真的质量特别大，一个人搞起来还是有点够呛。桌子总体来说颜值还可以，桌面是那种光滑的面板材料。桌子升降还是比较平稳的，当然停止的时候会有一种顿挫感，但这也不影响。当然，很多人关心站立办公时桌子会不会晃。实话说，是有一点晃，但还是还可以接受的，但如果你特别敏感的话，可能还是需要考虑一下。

总体来说，电动升降桌这种坐与站切换的方式似乎还是比较理想的。目前因为我使用的时间还不足以体会到明显改善的效果。这款升降桌一共有3个档位的记忆档位，调整上下档位不像其他的升降桌是按键形式，这款升降桌是旋转方式。旋转调整的粒度还是比较细的，调整可以比较精准。一般升降桌都有遇到障碍物方向升降的功能，避免一些意外伤害。这款桌面的承重是 120 千克，所以升降过程还是比较平稳。
https://www.bilibili.com/video/BV1Qp4y167cC/
显示器支架 电动升降桌，显示器支架以及人体工程学办公椅，这似乎就已经是颈椎病三件套。双十一在考虑入手电动升降桌之后，我就在考虑入手显示器支架。目前，因为主力使用的是 iMac2020，而且我当初选择的是支架版本，就是那种最普通的版本带底座的。其实 iMac 是有 VESA 孔的款式，这点恐怕很多人都不知道，我也是后来查了才知道的，而且带 VESA 孔的居然还要贵几百块。iMac 有个头疼的问题就是支架如何安装，因为原生的底座无法拆解。找了半天，终于找到一个折中的方案，通过底座中间的圆孔可以安装一个配件来安装显示器支架。选择的是长臂猿一款配件，国外应该也有类似的配件，不过好像更贵一点。


通过这个配件可以安装显示器支架，这种方案唯一的问题可能就是没有原生的那么稳定，再加上升降桌的晃动，可能晃动的幅度会更大一点。不过，总体还是一种比较可以接收的方案。
对于 iMac 支架选择还有一个更重要的问题就是重量。一般的显示器支架都是只支持 3-9 千克的显示器，iMac 整体的净重已经超过 9 千克了，如果使用普通的显示器支架势必会有低头现象。后来我选择了 NB 的 F100A 型号的支架。主要出于两个原因：一是这款显示器支架承重范围更广，可以支持 3-12 千克的重量；二是这款显示器支架性价比高，双十一差不多一百七左右就可搞定。实际入手的体验要比期望中的差一些，第一个还是有低头现象，后来换了一个，好了一点，但还是有点低头的。支架的安装过程不能算复杂，不过如果是第一次安装可能还需要一些时间的，第二次安装就快多了。

另外一款支架是乐歌的 D7A，好像是一款比较老的型号，但是价格好像还挺贵的。安装比 NB 的还简单一点，因为好几个组件都已经安装好了，基本只要固定在桌面就可以了。总体来说，这款支架可能综合方面比 NB 应该还更好一些，颜色也不太一样，偏银色。最后的总体效果我还是比较满意的，后来还是入了小米的显示器挂灯，配合使用效果还不错。显示器还是横屏用比较好，竖屏的确是不是很好用。

总结 这么一套折腾下来，差不多花了两千五左右，总体效果还是不错的。一个好的办公桌面真的会让人身心愉悦（可能是花了钱的缘故）。</description>
    </item>
    
    <item>
      <title>键盘简史</title>
      <link>https://madneal.com/post/%E9%94%AE%E7%9B%98/</link>
      <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%94%AE%E7%9B%98/</guid>
      <description>铁打的程序员，流水的键盘。作为一名全栈工程师，怎么能没几把好键盘。今天，就和大家分享一下这几年我体验的这些键盘。当然我并不是一个键盘发烧友，只是喜欢体验不同的键盘的手感，好的键盘真的会带给人写代码的愉悦（当然这种愉悦感最多也就持续一天）。键盘的种类主要可能就是薄膜键盘、静电容以及机械，然后每一种下面又分为好多种。这几个大类我都有体验过，那就讲讲使用这些键盘的感受是如何的。
性价比高的 IKBC 茶轴 入机械键盘坑的时候应该是当初还是做前端开发实习生的时候，当初就有好几个小伙伴在用机械键盘。当时就心痒痒，后来选择了 IKBC 的 C87 的白色茶轴，应该就四百左右。IKBC 算是性价比比较高的一款机械键盘，适合新手入坑。茶轴也挺适合机械键盘新入手的小伙伴，它既不会像青轴那么激进，但是同时又有比较强的段落感，所以码字还是比较带劲的。
当时拆箱的照片已经不见了，只有当初在实习公司的照片了，还有那两台特别戳的显示器。这款键盘后来出掉了，因为后来键盘很多了，而且这款我也不会再用了。


信仰之 Filco 青轴 机械键盘这玩意，基本一入坑就想换，就跟女生买包一样，买了一个还想买一个。如果机械键盘没有买过 Filco 就感觉始终没有到头。Filco 算是机械键盘里面比较 TOP 的品牌，被众多网友奉为退烧键盘。自从入了机械键盘坑之后就一直心痒痒要买 Filco。不久后我就入了 Filco 的 104 圣手二代青轴，当初也是双十一活动，九百就拿下了，这款键盘平常都要一千多。其实双模的肯定很爽，但因为价格原因还是选择了有线版本。另外，有兴趣的同学以后也考虑入侧刻的，比正刻的骚气一点。
Filco 的手感不用说了，那种轻快感，啪啪啪，震撼心魄，才拿到手的那段时间那真的不要太爽。不过青轴的缺点就是噪音比较大，当时办公室的人估计都想捶我。再好的键盘用多了也会腻，再加上噪音比较大，不过这个键盘我还是用了蛮久的，只是后来又入了新的键盘，这款键盘就闲置了。老实说，这款键盘的手感真的非常优秀，基本可以算我拥有的键盘里面手感最好的了。

另外一点就是 Filco 的大键不好安装，Filco 的大轴基本都是有平衡杆的，平衡杆是通过龙豆固定，对于我这种手残党来说，真的好难装，没有 Leopold 的卫星轴安装方便。

舒适的 Leopold 红轴 当青轴体验完之后，就很想体验那种有段落感截然不同的轴体。另外工作之后也希望不要使用那么高调的 Filco 青轴，正式工作的时候就入了 Leopold 的红轴。Leopold 可以算得上是和 Filco 并驾齐驱的机械键盘品牌之一。大 L 对于键盘的调教一点都不输于 Filco。
红轴的手感相比青轴段落感会弱很多，会有一点点闷的感觉，但是那种触感感觉还是很OK 的。红轴感觉就是相对于青轴更有一种成熟的感觉，感觉也更容易接受。

Leopold VS IKBC

不一样的 NIZ 静电容 在体验过3把机械键盘之后，我也很想尝试静电容键盘。HHKB 作为静电容键盘的头牌，也被很多程序猿所追求。之前实习的时候我也稍微体验过别人的这把键盘，手感的确有求。这款键盘键位排布我不是很喜欢，键位对于来说太少了。最不能接受的就是价格。后来还是选择了价格更加亲民的 NIZ 的静电容键盘 X87 35g。35g是按压压力，另外还有 45g的。
NIZ 键盘能够完美地适配 mac 电脑。键盘的外观还是比较朴素的，这也是我比较喜欢的风格。我一向不太追求花里胡哨的风格，之前选择的也都是比较低调的，灯厂那种风格的确不是特别适合我。静电容键盘的手感和机械键盘的手感完全不同，尤其是和青轴相比的话，没有那种段落感，更多的是直上直下，可能一开始会特别不习惯。静电容键盘可能稍微比较类似于红轴，但是和红轴相比，可能会更绵密，更软一点，当然声音也会更轻一点。NIZ 支持多种编程方式，不过我也没那种需求，就使用默认的就可以了。后来，还是觉得键帽太单调了，还是换了几个键帽作为点缀。</description>
    </item>
    
    <item>
      <title>imac 2020，真香？</title>
      <link>https://madneal.com/post/imac/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/imac/</guid>
      <description>前段时间，苹果发布了最新的 imac 2020。这次的发布好像偷摸摸就发布了，发布之后网上也出现了好多评测。这可能是最后一代使用英特尔芯片的 imac 了。这一代 imac 虽然外观还是依然没有变化，但是其它方面还是出现了重大更新。
其实我对数码产品其实一直没有特别大的追求，但电脑算我为数不多的追求爱好之一。但其实我也不是那种极致追求性能的那一种，因为我不打游戏，所以对显卡之类的几乎没有追求。我对电脑的要求是颜值高，使用方便，有保证，优秀的设计和体验。16年我入的是 XPS 15，几乎可以算得上是 windows 里面最优秀的笔记本电脑之一了。使用了将近两年的时间，当时因为公司的电脑太垃圾了。而我又是一个重度电脑使用用户，当初就把 XPS 放在了公司，18年又买了一台 macbook pro 2018。其实我是不太喜欢 touch bar的，但是当初好像是性能稍微好一点的都是带的。事实证明，touch bar 对于我来说还是非常鸡肋的，加上我基本都是把笔记本接显示器使用。所以，touch bar 我一共也没有使用几回。不过 macbook 总体使用起来没什么大问题，就是因为内存比较小，只有 8G，所以开了虚机之后有的时候可能会比较卡。
开箱 收到电脑之后就是一个简单的开箱，开箱感觉自己还是太笨拙了，开箱开的不好看，毕竟不是专业人士，没有那种可以治愈强迫症的感觉。imac 的包装还是比较厚实的，一共有两层盒子，泡沫也保护的很好。
https://www.bilibili.com/video/BV1Qa411w7qD
内存 对于 imac 好处之一就是可以自己升级内存，如果采取苹果官方的内存升级那是真正的人傻钱多。苹果升级内存贵是众所周知的，基本上和抢钱差不多。从 8GB 内存升级到 16GB 内存居然要加1500，要知道我买了2个 32 GB 内存才花了1800左右，而官方升级到 64 GB 内存居然要加7500。稍微有脑子的都会选择自己升级内存。
一开始我本来我还在准备插 4 根 16GB 的内存，后来想想还是用了 2 根 32GB 的，这样以后万一还需要拓展的话还可以有空间。换内存条的时候还有点小插曲，imac 的内存插槽真的是有毒，还真的是不能随便插得，可能会导致降频或者不能识别的问题。后来我发现插2根的时候，就只能插在第一个和第三个插槽，而且第一次开机的时间还是比较长的。内存条选的是金士顿的骇客神条，兼容性还是可以的，一次点亮。内存基本上就不需要操心容量问题了，万一以后需要扩容的话，还是可以继续扩容的。还有一点就是换内存的时候，后面那个挡板那个按钮需要比较用力的按下去。
使用体验 总体来说我从 MacBook 切换到 imac 上几乎上是没有任何成本的，本来开机的时候打算直接迁移的，但是这样速率太慢了。后来还是选择使用移动固态硬盘利用 time machine 进行备份，然后再恢复到 imac 上，总体来说速度也非常快，体验也比较丝滑。电脑到手使用起来也有将近小一个月的时间，说实话体验上并没有特别的改善，毕竟从 macbook 切换到 imac 上并没有系统方面的切换，所以感觉不会特别大。最主要的区别就是显示器的区别了，我之前使用的显示器是明基的 PD2700U，这款 4K 显示器的使用也是比较舒服的，这一款也比较护眼。这款显示器也有类似于苹果的夜览功能，到晚上会自动调节为暖色调。4K 和 5K 的差异肯定是有的，不过对于我可能就没有那么明显了。现在这台明基显示器被我当做副屏以竖屏的形式来使用，使用的频率不是特别高。</description>
    </item>
    
    <item>
      <title>一键 Shell，我的 OSWE 之旅</title>
      <link>https://madneal.com/post/oswe/</link>
      <pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/oswe/</guid>
      <description>原文来自于安全客，https://www.anquanke.com/post/id/217301
终于收到了 Offsensive Security 的官方邮件通知最终结果，我的 OSWE 之旅也算是尘埃落定。打算以本文回顾一下自己的 OSWE 的准备过程，包括 AWAE 课程的学习和准备以及我在考试过程中踩得一些坑，希望对 OSWE 有兴趣的人能有所帮助。
初识 AWAE Offsensive Security，作为安全圈的人应该都熟悉这家公司，Kali 就是他们家的。他们家最广为人知的课程也是 Pentration Testing with Kali Linux(PWK)，其对应的考试为 Offsensive Security Certified Professional(OSCP)。我最初结识 Offsec 也是通过 OSCP，认识了一些考 OSCP 的小伙伴，结果一直因为没(bao)有(ming)准(fei)备(tai)好(gui)，迟迟没有报名。结果大佬们一个个都通过了，报名费也从799美元涨到了999美元。
所以，当 AWAE 去年年末打折的时候，我毫不犹豫的就报名了。因为相对于 OSCP 来说，我也更喜欢 OSWE，因为自己毕竟是开发出身，对于代码审计也很感兴趣。疫情期间，的确有更多的时间可以看课程。有一个建议就是，当你的 lab 开始之后，可以第一时间就预约考试，因为 OSWE 相对来说考试可以选的场次更少，越早越好，一共有3次可以重新预约考试的机会。Lab 结束之后，我也一直拖了好久，主要当时认识了几个小伙伴考试都失利了，所以我也没啥信心。最后还是硬着头皮预约了考试。
AWAE 课程 AWAE(Advanced Web Attacks and Exploitation) 是一门关于应用安全的审计课程。AWAE 经常被拿来和 OSCP 的 PWK 来进行比较，官方也有暗示 OSWE 是 OSCP 的进阶版本，OSCP 注重于漏洞的利用，而 OSWE 则更进一步，侧重于市从白盒角度去审计代码，发现安全漏洞。不过 OSCP 并不是 OSWE 的先决条件，有人认为必须先考 OSCP 才能考 OSWE，这是不正确的。因为我就没有报考 OSCP 直接考的 OSWE。不过，另外一方面，如果你通过了 OSCP，对于 OSWE 绝对是有帮助的。我也在考试过程中体会到正因为我缺乏 OSCP 的经验，导致我犯了一些低级错误。</description>
    </item>
    
    <item>
      <title>寻找你的第一个漏洞</title>
      <link>https://madneal.com/post/%E5%AF%BB%E6%89%BE%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%AF%BB%E6%89%BE%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%BC%8F%E6%B4%9E/</guid>
      <description>最近 Burp Suite 社区有在收集赏金猎人对于新手的一些建议。其实，相对于国外来说，国内的白帽子的生存环境还是比较恶劣的，和国外相比，国内的白帽子的生存环境还需要进一步提高。如果想全职在中国做一名白帽子还是比较困难的，但国外全职的白帽子就比较多。自己其实在安全方面也不能算老手，之前也不是做安全挖洞出身的。自己当初第一个提交给 SRC 的漏洞还是在内网做代码审计发现的开源框架的 XSS 漏洞，当初是阿里和大众点评各一个。虽然漏洞不值钱，但当时还是比较开心的。后面也都是偶然发现的一些信息泄露，SRC 的项目也没怎么做过，不敢和那些挖洞大佬比。他们收集的一些建议我觉得有的还是非常有价值的，而且 Burp Suite 社区真的算是业界良心，且不说 Burp 作为每个安全工程师必备工具之一，他们出品的 Web Security Acedemy 简直就是业界良心，这么优秀的应用安全学习资源，居然还免费！！！
理解过程 脚本小子一时爽，一直当，一直爽。这个其实不一定是好的，对于新手来说，建议可以关注一种漏洞类型，然后深入挖掘，并且可以在一些项目中尝试去挖掘。
@0x1ntegral
  专注某种特性类型漏洞 阅读这种漏洞类型的报告 在项目中寻找这种类型漏洞 当你找到一个漏洞，更改漏洞类型并重复步骤 1   @Troll_13
 不要把事情过度复杂化。可以先做一些容易理解的，即使你的第一份漏洞赏金比较少，后面比较多的赏金会让你更开心。
 探寻未知领域 这其实是一个对于挖掘漏洞的一个比较通用的建议，一般来说，特别老的应用或者特别新的应用都是比较容易挖到漏洞的。往往有些老的应用，经常会有一些地方会被忽视掉。
永远不要停止学习 不管你是做安全还是做开发，学习对于你来说，是永远都不能丢掉的。坚持这一点可以让你在技术的世界走得更远。
@root4loot
 多读文章
 @shail_official
 读代码，先专注于公开的部分。阅读单元测试。
  坚持尝试，不要停止。使用 burp 去现实世界中挖掘漏洞。Apache 的一系列漏洞，配置错误，反射型 XSS 以及敏感信息泄露。
 总结 对于安全的技术学习，实践往往非常重要。所以向 Web Security Academy, Penteserlab, Hack the Box，这种平台都非常有意义。对于挖漏洞这件事情来说，如果作为全职职业的确非常困难，但它却是安全行业的找工作里面一个非常重要的门槛。尽管我自己也是挖漏洞也很菜，希望自己以后也可以多花点时间放在这一方面，能多挖些漏洞。实在不行，混个月饼呗。
Reference  https://portswigger.net/blog/finding-your-first-bug-bounty-hunting-tips-from-the-burp-suite-community  </description>
    </item>
    
    <item>
      <title>网络安全分析的瑞士军刀--zeek</title>
      <link>https://madneal.com/post/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80--zeek/</link>
      <pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80--zeek/</guid>
      <description>本文首发于 Freebuf 平台，https://www.freebuf.com/sectool/235587.html，转载请注明来自FreeBuf.COM
Zeek (Bro) 是一款大名鼎鼎的开源网络安全分析工具。通过 Zeek 可以监测网络流量中的可疑活动，通过 Zeek 的脚本可以实现灵活的分析功能，可是实现多种协议的开相机用的分析。本文主要是将 Zeek 结合被动扫描器的一些实践的介绍，以及 Zeek 部署的踩过的一些坑。
安装 Zeek 的安装还是比较简单的，笔者主要是在 Mac 上以及 Linux 上安装。这两个操作系统的安装方式还是比较类似的。对于 Linux 而言，需要安装一些依赖包：
sudo yum install cmake make gcc gcc-c++ flex bison libpcap-devel openssl-devel python-devel swig zlib-devel 这里我有遇到一个问题就是可能你的 Redhat 镜像源里面没有包含 libpcap-devel，因为这个包在可选的范围内，而内网的服务器又没有互联网连接。可以通过手工下载相应版本的 libpcap 以及 libpcap-devel 即可。
Mac 上需要的依赖更少一点，首先需要确保安装了 xcode-select，如果没有安装，可以通过 xcode-select --install 来进行安装。Mac 上只需要安装依赖 cmake, swig, openssl, bison 即可，可以通过 Homebrew 来进行安装。
依赖包安装完毕之后就可以安装 Zeek，其实是可以通过包管理工具来进行安装的，不过这里我推荐使用基于源码的安装方式，安装比较简单而且还容易排查问题。从 Zeek 的 Github Release 即可下载源码包，目前我安装的是 3.0.0 版本，注意一点是，如果使用最新的版本，可能需要 7.0 以上版本的 cmake，因为需要 C++17 的语言特性。而一般镜像源默认的 cmake 版本是4+版本，所以如果你的服务器也无法上互联网，建议可以安装 3.</description>
    </item>
    
    <item>
      <title>让你的SQL盲注快起来</title>
      <link>https://madneal.com/post/%E8%AE%A9%E4%BD%A0%E7%9A%84sql%E7%9B%B2%E6%B3%A8%E5%BF%AB%E8%B5%B7%E6%9D%A5/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%AE%A9%E4%BD%A0%E7%9A%84sql%E7%9B%B2%E6%B3%A8%E5%BF%AB%E8%B5%B7%E6%9D%A5/</guid>
      <description>本文首发于 Freebuf 平台，https://www.freebuf.com/articles/web/231741.html
SQL 注入是当前 web安全中最常见的安全问题之一，其危害性也比较大，众多白帽子在渗透测试过程中往往会首先着重进行 SQL 注入的测试。盲注是 SQL 注入的重要的技术之一，在现实中的 SQL 注入案例中，往往很难将注入的结果直接回显出来。因此，盲注也就成为了 SQL 注入必不可少的手段之一。本文想分享一个如何大大提升盲注效率的技巧。
与或运算 与或运算，操作符分别为 &amp;amp; 以及 |，大多数人应该会在实际开发过程中很少使用到与或运算。如果你之前学过计算机组成原理，里面讲了很多关于补码、反码以及各种运算。当然，我们这里不需要理解那么多知识，这里我们只需要理解与或运算就可以了。
与运算 运算规则： 0 &amp;amp; 0 = 0; 0 &amp;amp; 1 = 0; 1 &amp;amp; 0 = 0; 1 &amp;amp; 1 = 1
即：两位同时为“1”，结果才为“1”，否则为0
或运算 运算规则：0 | 0 = 0; 0 | 1 = 1; 1 | 0 = 1; 1 | 1 = 1
即：参加运算的两个对象只要有一个为1，其值为1
假设参与运算的2个数据，一个数据是1，那么另外一个的值就可以确定了，假设另外一个值为 x：
1 &amp;amp; x = 0, x = 0</description>
    </item>
    
    <item>
      <title>XSS 漏洞知解 123</title>
      <link>https://madneal.com/post/%E5%8F%8D%E5%B0%84%E6%80%A7xss%E7%9F%A5%E8%A7%A3123/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%8F%8D%E5%B0%84%E6%80%A7xss%E7%9F%A5%E8%A7%A3123/</guid>
      <description>跨站脚本攻击（Cross-Site Scripting），为了避免与 CSS 混淆，一般简称为 XSS。XSS 作为一种典型的主要可以分为 3 种：
 反射型 XSS 存储型 XSS DOM 型 XSS  关于这 3 种 XSS 类型的区别，在这就不展开了，本文主要讲解 XSS 漏洞的利用场景以及如何测试反射型 XSS，当然反射型 XSS 漏洞的测试和其它 XSS 漏洞类型的测试存在很多共同之处的。通常来说，通过 XSS 漏洞攻击者可以在受害者机器上执行任何脚本的话，包括：
 可以执行受害者可以执行的任何操作 可以浏览受害者可以浏览的任何内容 可以修改受害者可以修改的任何信息 可以通过最初的受害者与应用中其他用户交互，从而发起对其他用户的攻击  不过值得注意的是，反射型 XSS 总漏洞利用过程中也会遇到较多的障碍，经常可能会遇到很多限制：
 cookie 设置为 httponly，无法通过 JS 直接操控 cookie 用户输入的内容被进行过滤或者编码 受害者可能并没有登录应用，或者应用用户会话与特定的因素有绑定关系，比如 IP 地址或者 MAC 地址，这种情况比较少见  典型利用场景 XSS 的利用场景其实是五花八门的，可以说只要你敢想，搞不好你就可以做得到。这里，我们可以选择两个最典型的利用场景进行讲解。在这里我主要使用 PortSwigger 的应用安全学院里面的 lab 进行讲解。
盗取 cookie 通过 XSS 漏洞盗取 cookie 可以说是最典型的利用场景了。不过现在随着 HttpOnly 的广泛应用，这一利用场景也产生了一些限制。但是 HttpOnly 也并不能完全保证 XSS 漏洞的防范，因为 HttpOnly 理论上应该覆盖所有的敏感 cookie，如果有一处没有覆盖到，就有被攻击的可能性。另外一方面，通过结合 CORS 也有突破限制的可能性。还有一个实际情况是，仍然有很多应用并没有使用 HttpOnly，本节也主要是针对这一情形的具体利用。</description>
    </item>
    
    <item>
      <title>PWK 以及 OSCP 最常见的问题</title>
      <link>https://madneal.com/post/pwk%E4%BB%A5%E5%8F%8Aoscp%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/pwk%E4%BB%A5%E5%8F%8Aoscp%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>OSCP 最近在安全圈子越来越受到认知，Offsec 最近更新了一篇博文，关于 PWK 以及 OSCP 最常见的问题。本文挑一些重点讲一下：
什么是 PWK 以及 OSCP PWK 是为信息安全专业人员设计的渗透测试培训课程，是 OffSec 的基础课程。考虑参加 PWK的 学生应具有 TCP/IP 网络，Linux 和 Bash 脚本编写的一些经验。具备 Python 或Perl 的基本知识。OSCP 则是 PWK 对应的考试，OffSec 一般都是课程对应考试，比如 AWAE 对应相应的考试 OSWE。
官方还推荐完成 OSCP 后还可以考虑以下课程：
 CTP 中的渗透测试技术以及漏洞利用开发功能， AWAE 中的 Web 应用程序安全技能 WIFU 中的无线安全技能  如何以及在哪参加 PWK PWK 可以在世界各地参加，只要你能联网。不过中国的网络，你懂得。官方的 PWK 课程仅由 OffSec 提供，所以不要被一些培训机构骗了。
如何注册 PWK 以及 OSCP 考试 一般来说个体只要有护照应该就可以报名了。如果你已经是学生了，你可以在你最开始购买时收到的邮件里面购买其他可能或者更多的 lab 时间。如果要注册 OSCP 考试，可以使用课程报名的欢迎邮件。
前提条件 除了上述建议的先决条件外，我们还要求学生至少 18 岁才能上课，当然也有列外，之前国外好像就有一个16岁的学生通过了考试。对于硬件，我们建议至少安装 4 GB 的 RAM，至少要有一个双核 CPU 和 20GB 的可用硬盘空间。与实验室的连接是通过使用 Kali Linux 的 OpenVPN 完成的，要使用稳定的网络，当然对于中国的学生来说非常难。</description>
    </item>
    
    <item>
      <title>Haystack - hack the box</title>
      <link>https://madneal.com/post/haystack/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/haystack/</guid>
      <description>Introduction Target: 10.10.10.115(Linux)
Kali: 10.10.16.61
HayStack is an easy box in hack the box. But it does isn&amp;rsquo;t easy at all. It&amp;rsquo;s annoying to find the user and password in the messy Spanish. For the root, you should have a basic understanding of ELK. Hence, the box is quite fresh in htb.
Information Enumeration As usual, nmap is utilized to detect detailed ports and services.
# Nmap 7.70 scan initiated Sun Jun 30 01:10:53 2019 as: nmap -sT -p- --min-rate 1500 -oN ports 10.</description>
    </item>
    
    <item>
      <title>僵尸网络 Stantinko 犯罪活动新增加密货币挖矿</title>
      <link>https://madneal.com/post/botnet/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/botnet/</guid>
      <description>ESET 研究人员发现，Stantinko 僵尸网络背后的犯罪分子正在向他们控制的肉鸡分发加密货币挖矿模块。
Stantinko 僵尸网络 的操纵者已经通过一种新方法扩展了其工具集从受其控制的肉鸡中获利。多达 50 万的僵尸网络自 2012 年以来一直保持活跃，主要针对俄罗斯，乌克兰，白俄罗斯和哈萨克斯坦的用户，现在分发了一个加密货币挖矿模块。门罗币是一种加密货币，其汇率在 2019 年在 50 美元至 110 美元之间波动，自 2018 年 8 月以来，它一直是僵尸网络的获利手段。在此之前，僵尸网络进行了点击欺诈，广告注入，社交网络欺诈和密码窃取攻击。
在本文中，我们将介绍 Stantinko 的加密货币挖矿模块并对其功能进行分析。
该模块最显着的功能是它的混淆方式阻碍了分析并避免了检测。由于源代码级混淆以及随机性使用，而且 Stantinko 的操纵者会为每个新的受害者编译此模块，因此该模块的每个样本都是唯一的。
我们将在另一篇文章中为恶意软件分析人员介绍该模块的混淆技术，并提供一种处理其中某些问题的可行方法。
由于 Stantinko 一直在不断开发新的产品并改进其现有的自定义混淆器和模块，这些混淆器和模块被严重混淆，因此跟踪每个小的改进和修改非常困难。因此，我们决定仅提及和描述与早期样本相比比较重要的调整。最终，在本文中我们打算仅描述模块当前的状态。
修改后的开源加密货币挖矿软件 Stantinko 的加密货币挖矿模块通过挖掘加密货币来耗尽受感染机器的大部分资源，它是 xmr-stak 的大幅修改后的开源加密货币挖矿版本。为了逃避检测，删除了所有不必要的字符串甚至整个函数。其余的字符串和函数被严重混淆。ESET 安全产品将此恶意软件检测为 Win{32,64}/CoinMiner.Stantinko.。
挖矿代理的使用 CoinMiner.Stantinko 不会直接与其矿池进行通信，而是通过 IP 地址为从 YouTube 视频的描述中获取的代理进行通信。使用了与银行恶意软件 Casbaneiro 类似的技术在 YouTube 视频描述中隐藏数据。Casbaneiro 使用看起来更为合法的频道和描述，但目的大致相同：存储加密的 C&amp;amp;C。
此类视频的描述由以十六进制格式的挖矿的代理 IP 地址字符串组成。例如，图1中显示的 YouTube 视频的描述为 &amp;ldquo;03101f1712dec626&amp;rdquo;，它对应于两个十六进制格式的 IP 地址- 03101f17 对应于十进制点分四进制格式的 3.16.31[.]23，而 12dec626 对应 18.222.198[.]38。截至本文，格式已稍作调整。 IP地址当前用 “!!!!” 括起来，简化了解析过程，并防止了 YouTube 视频 HTML 结构的更改导致解析器无法正常工作。</description>
    </item>
    
    <item>
      <title>GMail XSS 漏洞分析</title>
      <link>https://madneal.com/post/xss/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/xss/</guid>
      <description>原文：XSS in GMail’s AMP4Email via DOM Clobbering
译者：neal1991
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 这篇文章是我在2019年8月通过Google 漏洞奖励计划报告的 AMP4Email 中已经修复的 XSS 的文章。该 XSS 是对著名浏览器问题 DOM Clobbering 的真实利用案例。
什么是 AMP4Email AMP4Email（也称为动态邮件）是 Gmail 的一项新功能，可以让电子邮件包含动态 HTML 内容。尽管撰写包含 HTML 标签的电子邮件已经很多年了，但通常认为 HTML 仅包含静态内容，即某种格式，图像等，没有任何脚本或表单。 AMP4Email 打算更进一步，允许电子邮件中包含动态内容。 在Google 官方 G Suite 官方博客中的帖子中，对动态邮件的使用案例进行了很好的总结
 通过动态邮件，你可以轻松地直接从消息本身直接操作，例如对事件进行快速回复，填写问卷，浏览目录或回复评论。
  以在 Google 文档中进行评论为例。现在，你将不再在有人在评论中提及你时接收到单独的电子邮件通知，而是会在 Gmail 中看到最新的主题，你可以在邮件中直接从中轻松回复或解决评论。
 该功能引发了一些明显的安全性问题。最重要的一个可能是：跨站点脚本（XSS）？如果我们允许电子邮件中包含动态内容，是否意味着我们可以轻松地注入任意 JavaScript 代码？好吧，答案是否定的；没那么容易。</description>
    </item>
    
    <item>
      <title>Chrome 最新零日漏洞</title>
      <link>https://madneal.com/post/chrome%E6%9C%80%E6%96%B0%E5%9C%A8%E9%87%8E%E9%9B%B6%E6%97%A5%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/chrome%E6%9C%80%E6%96%B0%E5%9C%A8%E9%87%8E%E9%9B%B6%E6%97%A5%E6%BC%8F%E6%B4%9E/</guid>
      <description>原文：Chrome 0-day exploit CVE-2019-13720 used in Operation WizardOpium
译者：neal1991
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 摘要 卡巴斯基安全防护是卡巴斯基产品的一部分，过去已成功检测到许多零日攻击。最近，为 Google的 Chrome 浏览器发现了一个未知的新漏洞。我们会立即将此情况报告给 Google Chrome 安全团队。在审核了我们提供的 PoC 之后，Google 确认存在零日漏洞并将其分配为 CVE-2019-13720。 Google 已针对 Windows，Mac 和 Linux 发布了 Chrome 版本78.0.3904.87，我们建议所有 Chrome 用户尽快将其更新为最新版本！你可以点击此处阅读 Google 公告。
卡巴斯基端点产品借助漏洞利用防御组件检测漏洞。该攻击的裁决是 Exploit.Win32.Generic。
我们称这些攻击为 Operation WizardOpium。到目前为止，我们还无法与任何已知的威胁者建立明确的联系。与蓝莲花攻击有某些非常弱的代码相似性，尽管这很可能是 false flag。目标网站的配置与最近部署了类似虚假标记攻击的早期 DarkHotel 攻击更加一致。
卡巴斯基情报报告的客户可以获取有关 CVE-2019-13720 和最近的 DarkHotel 的 false flag 攻击的详细信息。有关更多信息，请联系：intelreports@kaspersky.</description>
    </item>
    
    <item>
      <title>MyBatis 和 SQL 注入的恩恩怨怨</title>
      <link>https://madneal.com/post/mybaits%E5%92%8Csql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%81%A9%E6%81%A9%E6%80%A8%E6%80%A8/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/mybaits%E5%92%8Csql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%81%A9%E6%81%A9%E6%80%A8%E6%80%A8/</guid>
      <description>本文首发于安全客平台
MyBatis 是一种持久层框架，介于 JDBC 和 Hibernate 之间。通过 MyBatis 减少了手写 SQL 语句的痛苦，使用者可以灵活使用 SQL 语句，支持高级映射。但是 MyBatis 的推出不是只是为了安全问题，有很多开发认为使用了 MyBatis 就不会存在 SQL 注入了，真的是这样吗？使用了 MyBatis 就不会有 SQL 注入了吗？答案很明显是 NO。 MyBatis 它只是一种持久层框架，它并不会为你解决安全问题。当然，如果你能够遵循规范，按照框架推荐的方法开发，自然也就避免 SQL 注入问题了。本文就将 MyBatis 和 SQL 注入这些恩恩怨怨掰扯掰扯。（注本文所说的 MyBatis 默认指的是 MyBatis3）
起源 写本文的起源主要是来源于内网发现的一次 SQL 注入。我们发现内网的一个请求的 keyword 参数存在 SQL 注入，简单地介绍一下需求背景。基本上这个接口就是实现多个字段可以实现 keyword 的模糊查询，这应该是一个比较常见的需求。只不过这里存在多个查询条件。经过一番搜索，我们发现问题的核心处于以下代码：
public Criteria addKeywordTo(String keyword) {  StringBuilder sb = new StringBuilder();  sb.append(&amp;#34;(display_name like &amp;#39;%&amp;#34; + keyword + &amp;#34;%&amp;#39; or &amp;#34;);  sb.append(&amp;#34;org like &amp;#39;&amp;#34; + keyword + &amp;#34;%&amp;#39; or &amp;#34;);  sb.</description>
    </item>
    
    <item>
      <title>1024献礼，全栈工程师进击</title>
      <link>https://madneal.com/post/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E7%99%BE%E5%AE%9D%E7%AE%B1/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E7%99%BE%E5%AE%9D%E7%AE%B1/</guid>
      <description>作为一名梦想成为一名全栈工程师的男人，收集工具，积攒武器库是一个必要环节。本文主要是自己这些年在学习中积攒的一些工具，这一篇主要是在线网站，以后会介绍其它的工具。
 学术篇  CODECOGD gallery latext 符号 Conference Portal   前端  Plunker realfavicongenerator Iconfont   安全  CTF 在线工具 Online Tools pcapfix cmd5 jwt rot13 beautifier ook spectrum-analyzer app.any.run HashKiller   开发  codebottle regexr programiz playground downgit devhints   写作工具  作图工具 图床 squoosh markdown 转微信公众号 百度脑图   效率工具  cvmkr smallpdf remove   总结  学术篇 CODECOGD 这个网站对于一些不能支持 latex 公式的地方很好用，可以直接通过引入带有公式代码的链接生产图片。</description>
    </item>
    
    <item>
      <title>Kibana 任意代码执行漏洞</title>
      <link>https://madneal.com/post/kibana%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/kibana%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</guid>
      <description>今日，有人公开了 Kibana 任意代码执行漏洞（CVE-2019-7609）的 POC。这个漏洞的主要原理是因为 Kibana 中的 Timelion 中具有原形链污染漏洞，因此可以导致指定变量的原型链污染，通过传递 NODE 环境变量参数，利用 Kibana 的 Canvas 会创建新进程的特性可以达到远程执行命令的效果。
在本地尝试搭建环境复现，忙活了半天，一开始尝试的是 6.4.2 版本的 Kibana。尝试执行命令的时候，发现一直没有效果，才发现这个漏洞的利用还有一个重要的环节。在导致原型链污染之后，还需要点击 Canvas 菜单，因为点击 Canvas 菜单，Kibana 会尝试创建一个新的进程，从而可以达到远程命令执行的效果。不过在 Kibana 6.5 版本之前，Canvas 不是默认安装在 Kibana 中的。可以通过 kibana-plugin 去安装 Canvas 插件，不过我后来还是选择使用 6.5.4 版本，同时注意相应 elasticsearch 也需要升级到 6.5.4 版本。最后在使用反弹命令的时候，遇到了一点问题，可能与机器系统版本相关，可以多尝试几种命令。
漏洞的利用过程其实不是特别复杂，注意几点即可：
 漏洞的影响的版本是 5.6.15 版本以及 6.6.1 版本以前。 Kibana 需要安装了 Canvas 插件。 目前公开的 POC 因为使用了 linux 特有的环境变量，所以目前这个 POC 只能作用于 linux 机器。  原型链攻击 如果熟悉 JavaScript 的同学，对于原型链应该会比较熟悉。传统的 JavaScript 对象的集成就是基于原型链实现的。如果可以利用程序漏洞可以去修改 Object.protootype 就会导致所有的 JavaScript 的变量收到影响。针对本次漏洞，修复方式就是通过 hasOwnProperty 方法可以确保直接通过 proto 属性直接去修改 prototype。</description>
    </item>
    
    <item>
      <title>Pornhub Web 开发者访谈</title>
      <link>https://madneal.com/post/pornhub-web-%E5%BC%80%E5%8F%91%E8%80%85%E8%AE%BF%E8%B0%88/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/pornhub-web-%E5%BC%80%E5%8F%91%E8%80%85%E8%AE%BF%E8%B0%88/</guid>
      <description>原文：Interview with a Pornhub Web Developer
译者：neal1991
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 无论你对色情内容采取何种立场，都无法否认成人网站行业对推动互联网发展具有巨大影响。从将浏览器的视频限制推送到通过WebSocket推送广告，以便广告拦截器无法检测到它们，你必须足够聪明才能在互联网的前沿进行创新。
最近，我很有幸采访互联网最大的成人网站 Pornhub 的一名 Web 开发者。我想了解技术，Web API 如何改进以及在成人网站上工作的感受。请享用！
注意：成人产业竞争激烈，因此有一些他们无法回答的问题。我尊重他们保守商业机密的需要。
成人网站显然会显示许多图形内容。在开发过程中，你是否使用了大量的占位符图像和视频？最终产品和开发时的内容和经验有什么区别？
实际上，我们在开发网站时不使用占位符！其次，重要的是代码和功能，接口是我们现在非常习惯的东西。一开始肯定会有一些学习曲线，但是我们大家很快就习惯了。
对于网络流和第三方广告脚本，你如何在网站和功能开发过程中模拟这些重要的动态资源？
为了进行开发，播放器分为两个部分。基本播放器实现核心功能并触发事件。开发不会受其他因素干扰。为了在网站上进行集成，我们希望运行那些第三方脚本和广告，以便我们尽早发现问题。在特殊情况下，我们将与广告客户合作，允许我们手动触发通常可能是随机的事件。
平均每个页面可能至少包含一个视频，GIF 广告，一些 cam 表演者预览以及其他视频的缩略图。你如何测量页面性能以及如何使页面保持最佳性能？有什么你可已分享的技巧吗？
我们使用一些测量系统。
 我们的播放器会向我们报告有关视频播放性能和一般用法的指标 用于一般站点性能的第三方 RUM 系统。 WebpageTest 私有实例，用于在可用的 AWS 数据中心中编写测试脚本。我们主要将其用于查看给定时间可能发生的情况。它还使我们能够查看来自不同位置和提供者的“瀑布”。  我必须假设前端最重要，最复杂的功能是视频播放器。从在视频之前加入广告，标记视频的精彩时刻，更改视频速度和其他功能，你如何维护该资产的性能，功能和稳定性？
我们有一支专门致力于视频播放器的团队，他们的首要任务是持续监控性能和效率。我们为此几乎使用了所有可用的东西；浏览器性能工具，网页测试，指标等。我们进行的所有更新均通过可靠的质量检查来确保稳定性和质量。
专门的视频团队有多少人？团队中有多少前端开发人员？
我要说的是，团队规模倾向于基于产品规模的平均水平。
在成人网站上工作期间，你如何看待前端未来的变化？哪些新的 Web API 使你的生活更轻松？
我肯定在前端世界的每个方面都看到了很多改进；
 从纯 CSS 到最终使用 LESS 和 Mixins，再到使用具有媒体查询和图片标签的灵活 Grid 系统，以适应不同的分辨率和屏幕尺寸 jQuery 和 jQueryUI 慢慢地被淘汰，因此我们将回到 vanilla JS 中更高效的面向对象编程。在某些情况下，框架也非常有趣 我们喜欢新的 IntersectionObserver API，对于以更有效的方式加载图像非常有用 我们也开始使用画中画 API，以便在我们的某些页面上播放该浮动视频，主要是为了获得用户对该想法的反馈。  展望未来，有没有你想要更改，改进甚至创建的 Web API？</description>
    </item>
    
    <item>
      <title>被动扫描器之插件篇</title>
      <link>https://madneal.com/post/%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F%E5%99%A8%E4%B9%8Bchrome%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F%E5%99%A8%E4%B9%8Bchrome%E6%8F%92%E4%BB%B6/</guid>
      <description>本文首发于 freebuf, https://www.freebuf.com/articles/web/219818.html
最近被动扫描器的话题如火如荼，好多公司都在做自己的被动扫描器。而获取质量高的流量是被动扫描器起作用的关键。笔者主要开发了两个被动扫描器的插件，r-forwarder 以及 r-forwarder-burp，两个插件的代码都在 Github 上开源。两个插件分别为 Chrom 插件以及 Burp 插件，本文也从笔者开发这两个插件的经验来聊一聊被动扫描器中插件的开发。
Chrome 插件 Chrome 插件是向 Chrome 浏览器添加或修改功能的浏览器拓展程序。一般通过 JavaScript, HTML 以及 CSS 就可以编写 Chrome 插件了。市面上有很多非常优秀的 Chrome 插件拥有非常多的用户。Chrome 插件的编写也比较简单，基本上你熟悉一点前端知识，然后熟悉一下 Chrome 插件的 API，你就可以编写 Chrome 插件。Chrome 插件的安装，如果你没有发布在 Chrome 商店的话（因为网络原因，可能没办法直接从商店下载），可以通过开发者模式安装 Chrome 插件。或者你也可以注册 Chrome 插件的开发者账号（只需要 5 美元，就可以发布 20 个插件）。
简单地介绍了一下 Chrome 插件的开发，咱们主要还是聊一下关于 Chrome 插件关于被动扫描器的方面的内容。对于 Chrome 插件，主要是通过插件的能力去获取经过浏览器的流量，并将流量转发给后端来进行处理。Chrome 插件关于网络流量的处理地 API 主要有两个：chrome.devtools.network 以及 chrome.webRequest。但是前者使用的时候需要打开 Chrome 开发者工具，这个有一点不太方面，所以选择了后者，这也是对于被动流量获取一种常见的方式。
Chrome 插件中的 webrequest API 是以相应的事件驱动的，其中请求的生命周期图如下，主要有7个事件。只需要监听关键事件进行处理就可以满足被动扫描器获取流量的需求了。
其实这些事件不难理解，基本通过事件的名称就可以知道事件的含义了，主要就是请求发送前，发送请求头之前，发送请求头等等事件。对于不同的事件，可以获取的流量数据也是不尽相同的。首先，考虑一下，对于被动扫描器来说，哪些流量数据是比较关心的。被动扫描器主要是通过收集业务的正常流量来进行测试，提高测试的效率，并能取得比主动扫描器更好的效果。那么一般来说，被动扫描器最关心的就是请求的 URL 以及请求头了，如果是 POST 请求，还需要请求体。对于扫描器来说，响应头和响应体则没那么重要，其实可以通过响应状态过滤一下，一般只需要能够正常响应的请求头以及请求体即可。
对于被动扫描器上述的需求，chrome.webrequest 中的 onBeforeRequest 以及 onSendHeaders 这两个事件可以满足需求。通过前者，可以获取请求体。通过后者则可以获取请求头。不过在使用 onSendHeaders 的时候，有好几点需要注意：</description>
    </item>
    
    <item>
      <title>真香系列之 Golang 升级</title>
      <link>https://madneal.com/post/gproxy/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/gproxy/</guid>
      <description>Golang 以前的依赖管理一直饱受诟病，社区的方案也层出不强，比如 vendor, glide, godep 等。之前的依赖管理一直是依靠 GOPATH 或者将依赖代码下载到本地，这种方式都有劣势。另外由于特殊的网络环境，导致谷歌的大部分包都没有办法下载。才 Golang 1.11 开始，官方已内置了更为强大的 Go modules 来一统多年来 Go 包依赖管理混乱的局面，从 1.13 开始将成为默认配置。配合 Goproxy 来使用来说，真香。这次配合我之前的 golang 开源项目 gshark 升级到 1.13，升级花费的时间不超过 5 分钟，真香。
升级 Golang 版本 其实升级 Golang 版本是非常简单的，只要移除之前的 Golang，然后复制新版本的 Golang 就可以了。以我之前的 VPS 为例（CentOS,亲测苹果系统可以使用同样的方式升级），之前安装的 Golang 版本是 1.9。
  移除旧版本 Golang
rm -rf /usr/local/go   安装新版本 Golang
wget https://dl.google.com/go/go1.13.linux-amd64.tar.gz tar -C /usr/local -xzf go1.13.linux-amd64.tar.gz   配置 Golang 环境
如果你之前配置过 Golang 的环境，那么你可以找直接升级。主要只是需要配置 GOROOT 以及 GOPATH 即可，对于 1.</description>
    </item>
    
    <item>
      <title>Bastion -- Hack the box</title>
      <link>https://madneal.com/post/bastion/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/bastion/</guid>
      <description>介绍 目标： 10.10.10.134 (Windows)
Kali：10.10.16.65
In conclusion, Bastion is not a medium box. But it would be easier to solve this box with windows VM. Command VM may be a good choice. But it can be finished by kali.
总的来说，Bastion 其实并不是一个特别简单的机器。如果使用 windows 可以更方便地解决这台靶机。Command VM 对于这台靶机其实挺不错的，不过我们也可以使用 kali 来完成这个靶机。
信息枚举 Firstly, detect the open ports:
首先，探测开放端口
# Nmap 7.70 scan initiated Sun May 5 12:33:32 2019 as: nmap -sT -p- --min-rate 10000 -oN ports 10.</description>
    </item>
    
    <item>
      <title>如何写一个 burp 插件</title>
      <link>https://madneal.com/post/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAburp%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAburp%E6%8F%92%E4%BB%B6/</guid>
      <description>Burp 是 web安全测试中不可或缺的神器。每一个师傅的电脑里面应该都有一个 Burp。同时 Burp 和很多其他神器一样，它也支持插件。但是目前总体来说网上 Burp 插件开发的资料不是特别特别的丰富。今天我也来讲讲自己如何从一个完全不会 Burp 插件开发的小白如何学习 Burp 插件的开发。
如何调试 其实开发一样东西，调试真的特别重要。如果没有调试，那就和瞎子摸象差不多，非常的难顶。尤其是在 Burp 插件的开发过程中，如果你不可以调试，那你就必须把 jar 包打包出来，再安装，然后通过 output 来打印调试，这样的确非常地痛苦。后来在网上找了一些资料，一开始没太明白，后来研究发现原来调试配置这么简单。这么我们以宇宙 JAVA 开发神器 IDEA 为例。
 配置 DEBUG  首先是在 IDEA 里面配置调试。点击右上角里面的配置，点击 &amp;ldquo;Edit Configurations&amp;rdquo; 就可以进入对 DEBUG 的配置页面。新增一个 Remote 配置，命名可以随自己的喜好。
命令行启动 Burp  为了配合调试，需要在命令行中使用刚才新建 DEBUG 配置的参数来启动 Burp。
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar burpsuite_community_v2.1.02.jar 部署 jar 包，打断点  可以现在程序中打一下断点。接着就是编译 jar 包，并且启动 IDE 的 DEBUG。将 jar 包部署到 Burp 中，下面就可以快乐地调试了。
Burp 开发 老是说其实 Burp 插件开发其实还是比较简单的，只要你掌握常规的套路，熟悉了基本的 API 之后，基本就可以进行插件的开发。插件开发最困难的部分其实是 GUI 的开发，不过这也属于 JAVA GUI 开发的范畴，这个暂不讨论。Burp 开发注意以下几点：</description>
    </item>
    
    <item>
      <title>偶遇 XSS 漏洞</title>
      <link>https://madneal.com/post/%E5%81%B6%E9%81%87%E7%9A%84xss%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%81%B6%E9%81%87%E7%9A%84xss%E6%BC%8F%E6%B4%9E/</guid>
      <description>最近在公司内网发现了好几个 XSS 漏洞，后来看了一下系统，都是使用的开源项目。后来发现是开源项目自身的漏洞。后面我就去看了一下源代码，下面我们就聊一下这些 XSS 漏洞。
最近公司的被动扫描器发现了一个 XSS 漏洞，后来发现是登录的时候发现是登录请求传入的 ReturnURL 参数导致的 DOM 型 XSS 漏洞。后来，又看了一下系统，发现这是一个开源的系统，RAP。 RAP 是一个开源的 Web 接口管理工具，由阿里妈妈前端团队开发，不过目前这个代码仓库已经不维护了，已经迁移到了 rap2-delos。但是 RAP 的 star 数更多，高达 10000+。可以得知，该项目目前应该还有不少人在使用。
其实这个漏洞的原理非常简单。其实就是 doLogin 请求会传入一个 ReturnURL，而重定向的页面会直接使用 window.location.href 来直接重定向 URL。使用 window.location.href 其实本来就是一种比较危险的行为，尤其是链接的参数取决于外部输入，更有可能导致 dom 型的 XSS 漏洞。同时，这个漏洞也是一个开放重定向漏洞。不过本文就稍微聊一下这个 XSS 漏洞。开源仓库就是有一个好处，可以直接看代码。下面我们就通过代码来简单解释一下原理。
简单粗暴地在代码仓库中搜索了一下 window.location.href，发现代码仓库中有多处使用了 window.location.href。不过我们很快就发现了一个有趣的代码，正是重定向页面的代码。
关键代码就是：window.location.href = decodeURIComponent(&amp;quot;$returnUrl&amp;quot;);。这段代码没有对 returnUrl 做任何的处理，而且这段代码就是直接放在 script 标签中。毫无疑问，这种一定会导致 XSS 漏洞，可以通过构造 returnUrl 来闭合双引号从而导致 XSS 漏洞。比如，&amp;quot;alert(/xss/);//，这段代码就可以导致 XSS 漏洞。
再看看调用这个页面的地方：
 public String doLogin() {  // 增加验证码  Map&amp;lt;String,Object&amp;gt; session = ContextManager.</description>
    </item>
    
    <item>
      <title>cve check</title>
      <link>https://madneal.com/post/check-cve/</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/check-cve/</guid>
      <description>今天想检查一下 Gitlab 11.9.0 产品受哪些 cve 的影响。其实网上已经有很多网站可以查询产品的相关 cve，但就是粒度比较粗。我想在 cve 列表中筛选出特定的版本，已经特定的版本，比如是社区版还是旗舰版。找了一下，没有发现完全符合这个要求的。后来在网上我就看到了一个网站是可以提供 cve 的 API 查询的。可以通过网站 API 可以获取特定的数据。
可以通过 https://cve.circl.lu/api/ 可以看到 API 文档。可以通过 cve id 以及 product 以及其他更多信息来查询。最有用的 API 就是这一个，
可以通过 vendor 以及 product 获取指定 vendor 和 product 的 cve 列表。这个 API 返回的结果是一个 JSON 数组，我们需要在这里面过滤出相应的版本号以及 edition 版本。另外由于请求的结果一般是一个很长的 json 数据，我的做法是第一次请求，可以吧结果保存成 JSON 文件，第二次请求的时候首先检查这个 JSON 文件的最近修改时间，如果最近修改时间小于指定的天数，比如 3 天，如果 3 天内修改过的话，直接从 JSON 文件加载数据，否则重新发送请求，加载数据。
# check if file modified in the last several days def check_file_modified(filename, days): file_modify_time = getmtime(filename) return time() - file_modify_time &amp;lt; (days * 3600 * 1000) def write_json(filename, result): with open(filename, &amp;#39;w&amp;#39;) as f: dump(result, f, indent=2) def write_csv(filename, result, header): with open(filename, &amp;#39;w&amp;#39;, newline=&amp;#39;&amp;#39;) as f: writer = csv.</description>
    </item>
    
    <item>
      <title>持续发布 Chrome 插件</title>
      <link>https://madneal.com/post/%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83chrome%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83chrome%E6%8F%92%E4%BB%B6/</guid>
      <description>Chrome 插件对于 Chrome 浏览器用户来说是必不可少的利器之一。之前我有开发过一款七牛云图床的 Chrome 插件 image-host。后来由于我自己没有自己的域名，所以不太好使用这个插件了。后面，有其他的同学来提交 PR 来维护这一个插件。这样就有一个问题，一旦新的代码发布，就需要自己再重新发布一下插件。虽然发布插件不算特别麻烦，打包成压缩包，上传就可以了，但是对于程序员来说，可以自动做的绝对不要手动做。以下就是通过 CircleCI 来持续发布 Chrome 插件，参考了官方的文章，自己也才了一些坑。
介绍 CircleCI 是一款持续集成产品，和 Travis 非常类似，都属于 Github 上非常流行的持续集成产品。产品有商业和普通版本，开源项目是可以免费使用的。关于持续集成产品的不同，可以参考这篇文章。使用这个工具持续发布 Chrome 插件的原理就是：通过 CircleCI 来使用 Chrome 插件的 API 来持续发布插件，通过 CirecleCI 和 github 的集成可以在特定的时机就可以发布插件。那么下面具体介绍如何使用 CircleCI 来进行 Chrome 插件的发布，主要包括 Google API 的配置以及 CirecleCI 的配置。
Google API 首先，创建一个 Google API 项目，可以直接点击这个链接创建。
在创建项目之后，我们需要开启 &amp;ldquo;Chrome Web Store API&amp;rdquo;。在 Library 中搜索这个 API， 并且将其 ENABLE。
在 ENABLE 这个 API 之后，就可以点击 &amp;ldquo;CREATE CREDENTIALS&amp;rdquo; 创建口令了。确保你已经选择了对应创建的 project。值得注意的一点是，你创建的应该是 OAuth client ID 类型的，确保你选择了正确的类型。</description>
    </item>
    
    <item>
      <title>Holiday -- hack the box</title>
      <link>https://madneal.com/post/holiday-hack-the-box/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/holiday-hack-the-box/</guid>
      <description>Introduction Target: 10.10.10.25(Linux)
Kali: 10.10.16.65
Holiday is an insane box officially. It&amp;rsquo;s really difficult to get the user permission. The most difficult part should be how to pass the XSS filter. It may need a lot of time. And the root privesc is based on the exploitation of npm install which is relatively fresh.
Information enumeration As usual, use nmap to detect open ports and related services: nmap -A 10.10.10.25:</description>
    </item>
    
    <item>
      <title>后渗透的文件传输</title>
      <link>https://madneal.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%90%8E%E6%B8%97%E9%80%8F%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</guid>
      <description>在后渗透环节中，文件传输往往是必不可少的一个环节，比如下载 payload 或者其它特定的工具。所以掌握一些后渗透的文件传输的技巧也是非常有用的。对于后渗透的文件传输，结合我这些天自己玩靶机的过程以及一些大佬的文章，我有以下一些体验：
 工具越简单越好，要求就是方便易用 最好不要安装额外工具，使用原生的工具即可，或者是最常用的环境 稳定，这点也很重要  针对以下几点，总结以下一些经验，不同的操作系统有一些细节可能不太相同，但是大致的思路是差不多的。其实对于某一种方法，或许可以使用很多的工具，本文主要挑一些最常用的工具来讲一讲。
web 服务器 通过 web 服务器来搭建文件服务器，然后再下载文件这是一种常用的思路，这种方法简单易用，适用于各种平台，可以使用的工具也非常多。本文的攻击机器默认为 Kali，受害机器可能为 Windows 或者 Linux 机器。其实有很多工具可以搭建 web 服务器，比如 python、php、ruby等等。其实任何语言几乎都可以作为搭建文件服务器的工具，这里我们主要以 python 以及 php 为例，因为两种在我们的渗透过程中比较常见。我一般都选择把文件服务器的端口放在 80，因为这是 HTTP 的默认端口，这样下载文件的时候就可以不用指定端口号了。
python2 python -m SimpleHTTPServer 90 python3 python3 -m http.server 80 php </description>
    </item>
    
    <item>
      <title>Help -- hack the box</title>
      <link>https://madneal.com/post/help-hack-the-box/</link>
      <pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/help-hack-the-box/</guid>
      <description>Introduction Target: 10.10.10.121(OS: Linux)
Kali: 10.10.16.28
To be honest, Help is not a difficult box. But there are some rabbit holes in the box. And in some case, you may come across some very strange situations. May you should step back, find if there is something wrong. For the PrivEsc of root, never give up trying the most basic method.
Infomation Enumeration Firstly, gather open ports and services:
# Nmap 7.</description>
    </item>
    
    <item>
      <title>使用浏览器作为代理从公网攻击内网</title>
      <link>https://madneal.com/post/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86%E4%BB%8E%E5%85%AC%E7%BD%91%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86%E4%BB%8E%E5%85%AC%E7%BD%91%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91/</guid>
      <description>介绍 在 Forcepoint，我们不断寻求改善我们产品所提供的防护。为此，我们经常研究不寻常或潜在新颖的攻击技术。最近的一个研究课题是从公网发起的针对 localhost 和内网的攻击。
虽然不是新的攻击，但在安全研究社区之外，恶意 JavaScript 可以攻击内网并不广为人知。在关于该主题的有限文档中，大多数资源是从 inter-protol(协议间)漏洞来描述 [1] [2]，而我们的重点是 intra-protol(协议内部)的漏洞。我们发现没有一站式资源从协议内部攻击的角度去描述这种攻击，并且在白皮书中收集这些技术是为了填补关于这些攻击文档的空白，以及让被低估的攻击面受到关注。
由于浏览器默认可以访问 localhost 以及本地局域网，因此这些攻击可以绕过潜在的本地基于主机的防火墙以及企业/消费者外围防火墙。
恶意攻击者了解这些攻击，但防守者也需要被告知。除了描述攻击的技术细节之外，我们还将讨论检测和防范攻击的方法。
可疑行为：公网到局域网的连接 从恶意站点加载的 JavaScript 可以在许多情况下能够连接用户本地计算机（localhost）或其他内部主机上运行的服务。现代 Web 浏览器不能完全阻止使用受害者浏览器作为代理攻击内网。事实上，我们不仅可以让受害者浏览器在内部发送请求，而且我们还可以发现内部主机，进行有限端口扫描，进行服务指纹识别，最后我们甚至可以通过恶意 JavaScript 来攻击易受攻击的服务。
如果从公网获取的网页尝试访问未路由的 IP 地址（例如 localhost 或内部网络），则应将其视为可疑行为。通过我们的遥测技术，我们还没有发现过存在于公网上的良性网页需要连接到私有 IP 地址，我们也没有发现任何有效和合理的业务用例来做这样的事情。是否有必要允许公网上的网页连接到私有 IP 地址，而不是在某些边缘情况下，这是值得怀疑的。一个边缘情况可能是在内部网络上使用公共 IP 地址的不常见设置。（但必须允许相反的方向的情况，因为许多内部页面可能出于完全正当的原因而获取外部资源。）
这种可疑行为与攻击链的各个部分一起具有某些特征，可以用于检测目的建模。我们稍后将回到更详细的关于检测的讨论，因为如果我们先了解攻击链的技术细节，检测就更有意义了。
在进行威胁建模时，开发者通常认为本地服务永远不会接收外部输入，因此通常缺乏对这些服务的安全审核。可能通过远程托管的恶意 JavaScript 攻击易受攻击的本地服务的最新示例是 Logitech Options 应用开启易受攻击的 WebSocket 服务器 [3]。通过远程跨域 JavaScript 进行的本地攻击代表了一种被低估的攻击面。
同源策略不会阻止本地攻击吗？ 实际上，同源策略（SOP）[4]在很多情况下确实可以防范这种攻击，但正如我们看到的，仍然存在攻击可能成功的情况。尽管有相关文档，通常被忽略的事实是同源策略并不会阻止浏览器发出跨域请求，它只能阻止 JavaScript 读取响应。（同源策略允许嵌入跨域资源，如图像和 JavaScript，但这是另外一方面的内容。）对于攻击某些易受攻击的服务，它可能足以能够盲目地发送恶意请求以达到攻击者的目的。
Mozilla 的文档很好地描述了同源策略的功能：允许跨域嵌入和写入，但不允许读取。允许跨域写入的事实使得可能执行以下攻击：
 受害者在互联网上浏览恶意页面。页面上的 JavaScript 根据同源策略向不应与之通信的内部服务器发出异步请求(XMLHttpRequest)。 然而，浏览器将发送请求（此时服务器被利用）。 浏览器收到响应但不会将其传递给 JavaScript。  那跨域资源共享呢？ 我们要展示的攻击与跨域资源共享(CORS) [5] 无关，只与同源策略相关。在本白皮书中，我们可以假设不允许跨域资源共享请求，这意味着我们拥有最严格的设置，其中同源策略“阻止”所有内容。即使面对同源策略，我们也可以进行攻击。
攻击概述 我们将看一下使用受害者的浏览器作为代理，外部站点上的 JavaScript 如何攻击运行在 localhost 或内网中的易受攻击的服务的示例。作为概述，我们将看看以下步骤：</description>
    </item>
    
    <item>
      <title>Bashed -- hack the box</title>
      <link>https://madneal.com/post/bashed-hack-the-box/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/bashed-hack-the-box/</guid>
      <description>Introduction Target: 10.10.10.68 (OS: Linux)
Kali linux: 10.10.16.44
Information Enumeration Firstly, detect the open ports:
# Nmap 7.70 scan initiated Wed Apr 3 20:48:43 2019 as: nmap -sT -p- --min-rate 10000 -oA openports 10.10.10.68 Warning: 10.10.10.68 giving up on port because retransmission cap hit (10). Nmap scan report for 10.10.10.68 Host is up (0.31s latency). Not shown: 39680 closed ports, 25854 filtered ports PORT STATE SERVICE 80/tcp open http Only port 80 is open, it may be an easy box.</description>
    </item>
    
    <item>
      <title>Nibbles - Hack the box</title>
      <link>https://madneal.com/post/nibbles-hack-the-box/</link>
      <pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/nibbles-hack-the-box/</guid>
      <description>Introduction Target: 10.10.10.75(OS: Linux) Kali linux: 10.10.16.44
Information Enumeration Firstly, detect the open ports:
nmap -sT -p- --min-rate 10000 -oA openports 10.10.10.75 There are not too many open ports, just 80 and 22. Detect the detailed services of the open ports:
nmap -sC -sV -oA services 10.10.10.75 Nothing special found. The only clue may be the open port of 80. To be honest, the box with less open ports is easier in general.</description>
    </item>
    
    <item>
      <title>Cronos -- hack the box</title>
      <link>https://madneal.com/post/cronos-hack-the-box/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/cronos-hack-the-box/</guid>
      <description>Introduction Target machine: 10.10.10.13(OS: linux)
Kali linux: 10.10.16.44
Enumeration Firstly, detect the open ports:
nmap -sT -p- --min-rate 10000 -oA openports 10.10.10.13 3 ports is open, detect the detailed services:
namp -sV -sC -p22.53.80 -Pn -oA services 10.10.10.13 So we can conduct the relation of ports of ports and services as following:
   port service     53 DNS   22 ssh   80 http    Exploitation http As the target machine provides http service, try to access http://10.</description>
    </item>
    
    <item>
      <title>跨站请求伪造（CSRF）攻击</title>
      <link>https://madneal.com/post/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf%E6%94%BB%E5%87%BB/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf%E6%94%BB%E5%87%BB/</guid>
      <description>概述 跨站请求伪造（CSRF）攻击强迫终端用户在他们身份被认证的情况下执行对于目标应用未知的操作（恶意的）。CSRF 攻击一般针对状态更改请求，而不是数据被盗，因为攻击者无法查看对伪造请求的响应。通过社会工程的（例如通过电子邮件或聊天发送链接）方法，攻击者可以欺骗 Web 应用程序的用户执行攻击者选择的操作。如果受害者是普通用户，则成功的 CSRF 攻击可以强制用户执行状态更改请求，例如转账，更改其电子邮件地址等。如果受害者是管理帐户，CSRF 可能会危及整个 Web 应用程序。
值得注意的一点是 CSRF（跨站请求伪造）攻击经常与 XSS（跨站脚本）攻击（特别是反射性 XSS 攻击）混淆，两者虽然都是跨站，但并未有实际联系，利用方式也不尽相同。XSS 攻击通常是在合法的网络应用中注入恶意的内容为受害者提供服务。注入的内容会被浏览器执行，因此恶意脚本会执行。CSRF 的攻击通常是让目标用户在不知情的情况下执行一个操作（比如转账，表单提交），如果当前目标用户的还是已授权状态，那么这些操作就有可能会执行成功。可以这么理解，CSRF 就是利用用户合法的身份在用户不知情的情况下执行一些操作。而 XSS 则是在合法的网站注入恶意的内容，需要或者不需要用户交互即可执行恶意脚本，从而实现攻击。虽然两者并无太多相同之处，但是 XSS 漏洞会导致 CSRF 的某些防护措施失效，因此做好 XSS 的防护对于 CSRF 的防护也是很有意义的。
CSRF 的工作原理 CSRF 攻击是通过让一个已授权的用户的浏览器向应用发起一个恶意请求（用户尚不知情的情况）。只要用户的身份已被验证过且实际的请求已经通过用户的浏览器发送到目标应用，应用无法知道情况的来源是否是一个有效的交易或者这个用户是在知情的情况下点击这个链接。通过 CSRF 攻击，攻击者可以让受害者执行一些他们不知情的操作，比如，登出，购买操作，改变账户信息或者其它目标攻击应用提供的服务。
下面就是一个例子在机票供应商那里购买飞机票：
POST http://TicketMeister.com/Buy_ticket.htm HTTP/1.1 Host: ticketmeister User-Agent: Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O;) Firefox/1.4.1 Cookie: JSPSESSIONID=34JHURHD894LOP04957HR49I3JE383940123K ticketId=ATHX1138&amp;amp;to=PO BOX 1198 DUBLIN 2&amp;amp;amount=10&amp;amp;date=11042008 响应代表购买飞机票的 POST 请求已经成功执行：
HTTP/1.0 200 OK Date: Fri, 02 May 2008 10:01:20 GMT Server: IBM_HTTP_Server Content-Type: text/xml;charset=ISO-8859-1 Content-Language: en-US X-Cache: MISS from app-proxy-2.</description>
    </item>
    
    <item>
      <title>2019 年针对 API 安全的 4 点建议</title>
      <link>https://madneal.com/post/2019%E5%B9%B4%E9%92%88%E5%AF%B9api%E5%AE%89%E5%85%A8%E7%9A%844%E7%82%B9%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sat, 02 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/2019%E5%B9%B4%E9%92%88%E5%AF%B9api%E5%AE%89%E5%85%A8%E7%9A%844%E7%82%B9%E5%BB%BA%E8%AE%AE/</guid>
      <description>原文：4 Tips for Better API Security in 2019
译者：neal1991
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 
无论是在科技媒体亦或是分析报告中，2018年 “API”以及“安全”变得越来越常见，-或者更糟糕，“API” 以及“违规”一起出现在头条中。
APIs（应用程序编程接口）不仅是应用程序，系统和数据之间的连接组织，而且是允许开发人员利用和重用这些数字资产以实现新目的的机制。API 几乎影响到每个数字用例，它们在安全新闻中的作用不仅仅是 API 中的一个内在缺陷，因为它们中的一些已被破解，因此存在明显的缺陷。
但是头条新闻强调了一个重要信息：如果 API 安全性不是企业 2019 年优先事项的首要事项，那么优先级列表就不完整。
实际上，API 安全的要求正在成为一种共识：
  在 2017 年 12 月的报告“如何构建有效的API安全策略中，”Gartner 分析师 Mark O&amp;rsquo;Neill， Dionisio Zumerl e和 Jeremy D&amp;rsquo;Hoinne 预测，“2022年，API 滥用将是最常见的攻击向量，导致企业网络应用程序的数据泄露。”
  OWASP Top 10是一个备受推崇的 web安全威胁列表，其中多次提及 API。其明确的警告包括针对没有保护即传输敏感数据的 API 的警告，针对可疑行为而未监控流量的 API 以及使用易受攻击组件的 API。</description>
    </item>
    
    <item>
      <title>隐写术-深入研究 PDF 混淆漏洞</title>
      <link>https://madneal.com/post/%E9%9A%90%E5%86%99%E6%9C%AF-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6pdf%E6%B7%B7%E6%B7%86%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%9A%90%E5%86%99%E6%9C%AF-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6pdf%E6%B7%B7%E6%B7%86%E6%BC%8F%E6%B4%9E/</guid>
      <description>原文：&amp;ldquo;steganography&amp;rdquo; - obfuscating PDF exploits in depth
译者：neal1991
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 上礼拜发现的关于使用 this.getPageNumWords() &amp;amp; this.getPageNthWord() 方法来进行混淆的 PDF 漏洞不久，我们发现另外一个，一个在 PDF 漏洞中更加强大的混淆利用技术。这种技术使用所谓的“隐写术”方法来隐藏嵌入在 PDF 文件中的图像中的恶意 Javascript 代码，它非常强大，因为它可以绕过几乎所有的 AV 引擎。
我们的 EdgeLogic 引擎将样本检测为 &amp;ldquo;exploit CVE-2013-3346&amp;rdquo;，与前一个相同。
 https://edgespot.io/analysis/ebc5617447c58c88d52be6218384158ccf96ec7d7755179a31d209a95cd81a69/  样本首先在 2017-10-10 提交给 VirusTotal，文件名为 “oral-b oxyjet spec.pdf”。
上周只有 1 个 AV 引擎检测到这种攻击（但是，截至写作时，检测增加到 5/57）。
 https://www.virustotal.com/#/file/ebc5617447c58c88d52be6218384158ccf96ec7d7755179a31d209a95cd81a69/detection  打开后，伪装成 IRS 文件的 PDF 看起来很正常。</description>
    </item>
    
    <item>
      <title>什么是DDOS</title>
      <link>https://madneal.com/post/%E4%BB%80%E4%B9%88%E6%98%AFddos/</link>
      <pubDate>Fri, 04 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BB%80%E4%B9%88%E6%98%AFddos/</guid>
      <description>什么是 DDOS DDOS(Distributed Denial of Service)，即分布式拒绝服务，是一种针对于网络服务的攻击行为。对于 DDOS 我们可以这样通俗地理解，假如有一家商店在售卖商品，突然涌过来一大帮人说要买东西，这里面有的人是真正地顾客，有的人只是过来捣乱的，但是售货员如果没办法及时处置，就会导致一种拒绝服务攻击了。而分布式拒绝服务攻击，则是因为黑客控制了很多台肉鸡来发动攻击。这种攻击近些年来越来越流行，对于攻击者来说，成本小，但是相对收益大，对于受害者来说，造成的伤害却是巨大的。因为对于服务提供者来说，一旦服务不可用，就会造成不可挽回的损失，可能会导致用户量的流失。根据腾讯云发布的《2018年泛互联网行业DDoS攻击态势报告》，2018年 DDOS 攻击已经进入 TB 时代，2018 年的攻击峰值为 1.23Tbps（同比增长121%），而业界的攻击峰值更是达到惊人的 1.94Tbps。
有人说对于 DDOS 攻击，有钱的话，就死命扩容，没钱的话，就忍一忍。虽然是玩笑话，但是有一定的道理。最近也是自己了解 DDOS 攻击这一块知识，下面简单介绍一下自己看到的一些。
DDOS 攻击类型 常见的 DDOS 攻击主要包括以下几类：网络层攻击、传输层攻击、会话层攻击以及应用层攻击。
传输层 DDOS 攻击 传输层 DDoS 攻击一般是针对于 TCP 以及 UDP 协议地攻击，主要是指 Syn Flood，Ack Flood，UDP Flood，ICMP Flood、RstFlood 等攻击。
以最常见的 DDOS 攻击 Sync Flood 为例，它利用了 TCP 协议的三次握手机制，当服务端接收到一个 Syn 请求时，服务端必须使用一个监听队列将该连接保存一定时间。因此，通过向服务端不停发送 Syn 请求，但不响应 Syn+Ack 报文，从而消耗服务端的资源。当等待队列被占满时，服务端将无法响应正常用户的请求，达到拒绝服务攻击的目的。
DNS DDoS 攻击 DNS 服务对于企业来说是比较重要的，因此针对 DNS 服务的 DDOS 攻击也是比较常见的。DNS DDoS 攻击主要是指 DNS Request Flood、DNS Response Flood、虚假源+真实源 DNS Query Flood、权威服务器和 Local 服务器攻击。</description>
    </item>
    
    <item>
      <title>GShark-监测你的 Github 敏感信息泄露</title>
      <link>https://madneal.com/post/gshark-%E7%9B%91%E6%B5%8B%E4%BD%A0%E7%9A%84github%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</link>
      <pubDate>Wed, 31 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/gshark-%E7%9B%91%E6%B5%8B%E4%BD%A0%E7%9A%84github%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</guid>
      <description>近几年由于 Github 信息泄露导致的信息安全事件屡见不鲜，且规模越来越大。就前段时间华住集团旗下酒店开房记录疑似泄露，涉及近5亿个人信息。后面调查发现疑似是华住的程序员在 Github 上上传的 CMS 项目中包含了华住敏感的服务器及数据库信息，被黑客利用导致信息泄露（这次背锅的还是程序猿）。
起源 对于大型 IT 公司或者其他行业，这种事件发生的概率实在是太常见了，只不过看影响的范围。现在大家看到的，也仅仅只是传播出来的而已。企业没办法保证所有人都能够遵守规定不要将敏感信息上传到 Github，尤其是对于那种特别依赖于外包的甲方企业，而甲方的开发人员也是一无所知，这种事件发生也就是司空见惯了。
废话说了一大通（可能是最近看安全大佬的文章看多了），终于要介绍一下我的这个项目，GShark。这个工具主要是基于 golang 实现，这也是第一次学习 golang 的项目，结合 go-macron Web 框架实现的一个系统。其实最初我是看到小米安全开源的 x-patrol 项目。网上这种扫描 Github 敏感信息的工具多如皮毛，我看过那种 star 数上千的项目，感觉实现方式也没有很好。因为说到底，大家都是通过 Github 提供的 API 结合相应的关键字来进行搜索的。但是，x-patrol 的这种实现方式我觉得是比较合理的，通过爬虫爬取信息，并对结果进行审核。所以，最初我是一个 x-patrol 的使用者。使用过程中，也遇到过一些问题，因为这个库似乎就是小米的某个固定的人维护的，文档写的不是特别清晰。中间我有提过 PR，但都被直接拒绝掉了。后来，我就想基于 x-patrol 来实现一套自己的系统，这也就是 GShark 的来由了。目前，这个项目与 x-patrol 已经有着很大的变化，比如移除了本地代码的检测，因为这个场景没有需求，其实我本身自己也实现了一个基于 lucene 的敏感信息检索工具。另外，将前端代码进行了梳理，并使用模板引擎来做模板的嵌套使用。基于 casbin实现基于角色的权限控制等等。
原理 讲完了起源，接着讲一讲这个系统的原理。基本上，这类工具都是首先会在 Github 申请相应的 token 来实现，接着通过相应的 API 来进行爬取。本项目主要是基于 Google 的 go-github。这个 API 使用起来还是比较方便的。通过这个 API 我们可实现在 Github 来进行搜索，其实这基本上等同于 Advanced Search。因为 API 提供的搜索能力肯定就是 Github 本身所具有的搜索能力。最基本的包括关键及，以及一些 owner 信息以及 star 数等等。</description>
    </item>
    
    <item>
      <title>Qradar SIEM--查询利器 AQL</title>
      <link>https://madneal.com/post/qradar-sime%E6%9F%A5%E8%AF%A2%E5%88%A9%E5%99%A8/</link>
      <pubDate>Fri, 26 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/qradar-sime%E6%9F%A5%E8%AF%A2%E5%88%A9%E5%99%A8/</guid>
      <description>对于 SIEM 平台来说，好用的查询方式非常重要。之前有体验基于 ELK 搭建的平台，在 kibana 上面是可以通过一些 filter 来做一些过滤并且是支持 lucene 的语法，包括一些简单的逻辑查询以及 wildquery 等等。但是的确是在做一些汇聚之类时不是很方便，一般需要通过 json 来构建更高级的查询语句。后来好像也有转 SQL 之类的插件，但我也没有使用过，总的来说体验比较一般。
Qradar Qradar 是 IBM 一款比较成熟的商业 SIEM 平台（尽管他们的 BUG 一大堆，但架不住别的更差啊），基本上也是属于业界 TOP 5。商业产品的好处就是不用自己太折腾，搞搞就可以用，缺点就是贵。AQL（Ariel Query Language）是 Qradar 中的一种查询语言，与普通的 SQL 的语句类似，但是阉割了一些功能也增加了一些功能。以下是 AQL 的基本流程：
可以看出 AQL 是一种非常类似于 SQL 的语言，所以基本上你用过 SQL 学会 AQL 也就分分钟的事情，而且你也不会拿它去做特别复杂的嵌套查询（因为它也不支持。。。）
Tips 虽然 AQL 终于让我们有枪可以搞一搞了，但是还是有一些地方值得吐槽的地方。第一就是很多 ID 不知道其具体的映射，就比如我们想查询一些事件的名称或者规则的名称，AQL 是不存在字段名是事件名称或者规则名称的。不过你可以通过函数来进行转换，比如使用 QIDNAME(qid) 来获取事件名称，RULENAME(123) 来获取规则名称。你没办法知道事件名称或者规则名称到底是对应什么 ID，目前我用的办法就是先去 IBM Develop API 里面先去查询。第二，AQL 查询的结果我发现有某个规则的查询结果和用 filter 查询的结果不一致，不知道这是不是特例。还有其他的，想到再说。
下面就是我在使用过程中一些小经验：
引号的使用 在 AQL 中，单引号和双引号的使用是有区别的。单引号一般可以表示字符串或者作为字段的别名，如果你的字段包含了空格，那么你必须使用单引号。双引号一般用来表示自定义属性的名称。还有一个值得注意的地方就是，当你在使用 WHERE, GROUP BY, ORDER BY 的时候，你必须要使用双引号来使用别名，而不是单引号，是不是有点绕。其实有个好的方法就是不要使用单引号了，直接使用帕斯卡命名或者使用下划线连接，比如 EventName 或者 Event_Name，其实你自己想怎么命名都可以啦。</description>
    </item>
    
    <item>
      <title>web 狗之writeup--phone</title>
      <link>https://madneal.com/post/web%E7%8B%97%E4%B9%8Bwriteup--phone/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/web%E7%8B%97%E4%B9%8Bwriteup--phone/</guid>
      <description>鄙人不才，只能做个 web 狗了。那就好好学习 web 吧。拼命地刷 writeup 就好了。上题目，Phone number。提示只有 phone number is a good thing.
打开链接可以看到是一个登陆页面，查看源代码，没有什么东西。不过，这个页面还有个注册页面，注册页面有用户名密码以及 phone，查看其源代码也没有什么异常情况。这道题初步看来应该是一道 sql 注入题了，那么注入点在哪呢？当然是 phone 了（来自于上帝视角）。如果正经地来说还是因为题目的提示啦。
注入点的确就是 phone，不过是要使用 16进制字符。为什么呢？上帝告诉我的，我也不知道。好吧，接下来就是 sql 注入四步曲了，爆数据库名，爆表名，爆字段，最后查数据，拿 flag。是不是很开心！
正常用户 首先，我们首先注册一个正常用户，注册之后登录，可以看到页面。这里面有一个 check 的按钮，点击一下，可以看到页面提示 There only 369 people use the same phone as you。查看源代码，可以看到注释里面有一句话：听说admin的电话藏着大秘密哦，这也是一个小提示。这里面的369应该就是通过 sql 语句从数据库拿到的，语句可能就是类似于 select count(*) from user where phonenum = 12 这种的，从而查出和你电话号码一样的用户数了，那么我可以信誓旦旦地告诉你，这就是一个注入点啦！
数据库名 因为 phone 可能使用的是数字，所以这是一个数字型的注入。那么，我买可以随便注册一个用户名了，首先获取数据库名的语句是 1 and 1 = 2 union select database()，把这个语句转化为16进制字符。将这个16进制字符串作为 phone 来进行注册，这里注意的一个点就是，前台对于 phone 的长度做了限制， maxlength=&amp;quot;11&amp;quot;，打开开发者工具设置大一点就可以了。注册成功之后，我么就可以看到：
Hello, txt1 Your phone is 1 and 1 = 2 union select database().</description>
    </item>
    
    <item>
      <title>利用 python 生成可视化报告</title>
      <link>https://madneal.com/post/%E5%88%A9%E7%94%A8python%E7%94%9F%E6%88%90%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%88%A9%E7%94%A8python%E7%94%9F%E6%88%90%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A/</guid>
      <description>Python 作为一种常用的胶水语言，可用于各种用途。最近有个需求需要获取 SIME 平台的数据并形成月度报告。我的想法就是通过平台的 API 获取数据，然后基于 word 以及 matplotlib 来生成可视化报告。在这里要介绍一个比较好用的 python 库，docxtpl。这个库是一个基于 python-docx 的库，可以通过模板来生成报告。下面就介绍一下如何使用这些库，以及使用过程中的一些小问题。
模板 docxtpl 是基于 jinja2 引擎的语法，类似于常见的 html 模板语法，变量经常会放在 {{}} 中。假如我们希望在模板中设置变量 a 的值，那么我么可以在模板中填写 {{a}}。最后，我们通过 render 来渲染模板即可。
doc = Docxtpl(filename) context = {  &amp;#34;a&amp;#34;: &amp;#34;13413&amp;#34; } doc.Render(context) 那么如果我们希望在模板中插入一个图片该怎么做呢，可以使用 InlineImage 去实例化图片：
from docxtpl import DocxTemplate, InlineImage # for height and width you have to use millimeters (Mm), inches or points(Pt) class : from docx.shared import Mm, Inches, Pt import jinja2 from jinja2.</description>
    </item>
    
    <item>
      <title>黑产代码解密--利用canvas加载代码</title>
      <link>https://madneal.com/post/%E9%BB%91%E4%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%AF%86--%E5%88%A9%E7%94%A8canvas%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%BB%91%E4%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%AF%86--%E5%88%A9%E7%94%A8canvas%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%A0%81/</guid>
      <description>前段时间获取到黑产的一些代码，不得不感叹黑产的代码实在在写的是好得很，思路巧妙，环环相扣。不得不说，技术不好，黑产都做不了了。虽然分析了好多天，但是也只是一知半解。这里抽出一小部分来讲一下。二话不说，先上代码：
最初的代码是经过混淆的，代码经过整理如下：
var createImgElement = function(urla, b) {  var imgElement = document.createElement(&amp;#39;img&amp;#39;);  var canvasEle = document.createElement(&amp;#39;canvas&amp;#39;);  imgElement[&amp;#39;crossOrigin&amp;#39;] = true;  imgElement[&amp;#39;onload&amp;#39;] = function() {  canvasEle.width = this.width;  canvasEle.height = this.height;  var canvasContext = canvasEle.getContext(&amp;#39;2d&amp;#39;)  canvasContext.drawImage(this, 0, 0, this.width, this.height);  for (var canvasContext = canvasContext.getImageData(0, 0, this.width, this.height),  cancasDataLength = canvasContext.data.length, arr = [], i = 0;  i &amp;lt; cancasDataLength;  i += 4) {  var code = canvasContext.</description>
    </item>
    
    <item>
      <title>Wmic 使用中的一些问题</title>
      <link>https://madneal.com/post/wmic%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/wmic%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>Wmic, 即 Windows Management Instrumentation Command-Line Utility，通过这个工具我们可以获取计算本地的很多信息。
起源 我起初是希望写一个 bat 脚本来获取计算机安装的程序和功能列表以及计算机最近安装的一些补丁信息。程序和功能列表以及补丁信息可以通过计算机的控制面板去查看，但是这样一点都不 geek，能用脚本解决的当然要用脚本去解决啦。
程序和功能 通过 wmic product 我们可以获取程序和功能的安装信息。
wmic product get name,description
这样我们就可以获取计算机上安装的程序和功能列表以及其相应的描述。当然除了 name 以及 description 之外我们还可以使用 vendor 以及 version 来获取程序的厂商名称以及对应的版本号。另外，如果我们希望把结果导入到 txt 文件中，我们还可以使用万能的管道符号：
wmic product get name, description &amp;gt; products.txt
这样我们就可以获取结果的 txt 文件，是不是很方便。然而，当我们将使用 wmic 导出的结果和控制面板中的程序和功能相比较的话，我们会发现有些程序没有出现在结果中，比如 Google Chrome。
通过 wmic 只能获取大部分程序列表，它们的安装包一般都是使用 Windows Installer 制作的，安装过程中调用 Windows Installer 服务进行安装。但是 Windows Installer 并不是唯一的制作安装包的工具，因此 wmic 往往可能获取的还不是完整的程序和功能列表。至于完整的程序和功能列表，可以参考这篇文章。
补丁信息 经常我们需要获取计算机的补丁安装情况。通过 systeminfo 可以获取一部分补丁安装信息，但是信息一般比较少。在这里，我们依然可以通过使用 wmic 来获取补丁安装信息。
wmic qfe list full</description>
    </item>
    
    <item>
      <title>Elasticsearch 团队开发章程</title>
      <link>https://madneal.com/post/elasticsearch%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E7%AB%A0%E7%A8%8B/</link>
      <pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/elasticsearch%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E7%AB%A0%E7%A8%8B/</guid>
      <description>原文：Elasticsearch Team Development Constitution
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 前言 我们作为 Elasticsearch 核心开发人员团队希望尽可能快地向可靠，健壮，安全，可扩展且易于使用的系统迁移。我们希望为创新而努力，取代传统的构造和功能，删除脆弱的代码，并致力于改善用户体验，同时在我们快速变化的同时保持用户增长。
对于我们来说，拥有一个团队的前进方向的共识是非常重要的，甚至更重要的是团队为什么要走上一条特定的路。当 Elasticsearch 创立之初时，它具有无尽的灵活性，易用性和丰富的 API。我们这帮年轻的团队成立了一家公司，并且突然用户数井喷式发展。支持组织几乎无法满足越来越多的客户，这是幸福的烦恼。然而，随着用户数量的增长，事情发生的可能性也越来越大，不幸的是，这比我们聘用支持工程师的速度要快得多。我们了解到，大多数灵活性来自宽松处理，从大多数情况下可行的功能，但不是全部。例如，用户可以使用请求发送的脚本基本上是一个远程代码执行引擎，如果出错，它是致命的。即使最基本的功能，比如设置，也非常灵活，但非常脆弱。在没有单位的情况下指定一个数字是很好的，除非许多用户不知道默认单位是什么。我们只是试图做正确的事情，结果证明并不是总是对的。
现在我们处于不同的位置。我们的用户基数比 2013 年的用户基数大得多，但我们的支持机构并没有以同样的速度增长。是的，我们处理比 2013 年更多的支持案例，但这在我们当时的系统中是不可能的。现在我们已经从一个脆弱而灵活的系统转向了范围较窄的软件。我们定义了更多的边界：更严格的输入验证，允许我们对权限进行细粒度控制的安全模型，甚至还有一个插件模型，可以以极大的灵活性来添加风险更高的功能。
但等等，我们还差得远呢！仍然有无穷无尽的问题会造成致命的后果。聚合可以通过一个请求来撑爆服务器。用户感觉需要运行 30+GB 堆的 Elasticsearch。我们仍然提供了 27 种指定布尔值的不同方式。这份清单还有其它内容&amp;hellip;
我们对我们的用户，支持组织，云托管团队和第三方提供商负有巨大责任，提供可靠，稳健，安全且易于使用的系统。出于这个原因，我们都应该努力创新，取代传统的构造和功能，删除脆弱的代码，并改善用户体验。我们与其他公司相比的优势是我们的创新，创新需要速度。我们必须在留住用户的同时下采取行动并接受变革创新。
以下章节是用于设计，重构或从 Elasticsearch 代码库中删除代码的原则和指导原则的集合。这些点是无序的，大部分是未分类的，应该被看作是 Elasticsearch 团队内软件开发的一个组成部分。
设计特性   过程优于结果。 我们多年来一直遵循这种方法，这使我们能够随着时间的推移做出巨大的变化，而不会因大量的请求而产生巨大的响应。例如，补齐建议程序在 Elasticsearch 的早期版本中添加，而不支持实时更新和特定的删除。这意味着删除 Elasticsearch 中的文档不会立即反映在建议中。这是一个很难的问题，大约三年后，我们增加了对 Lucene 建议器和 Elasticsearch 的 bitset 过滤器的支持。与此同时，对于许多用户来说，这是一个可以接受的解决方案，修复了许多错误，并朝着基于文档的建议器发展。这就是过程优于结果。
  为今天设计！谨慎使用抽象。 计算机科学教授教育学生以灵活性和信息隐藏的名义广泛使用抽象层。当然 Elasticsearch 广泛使用抽象; 没有任何涉及数百万行代码的项目可以以其他方式进行工作并生存。但经验表明，过度或过早的抽象可能与过早优化一样有害。抽象应该用于所需的级别，不要再进一步。</description>
    </item>
    
    <item>
      <title>理解 OutOfMemoryError 异常</title>
      <link>https://madneal.com/post/%E7%90%86%E8%A7%A3outofmemory%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sat, 26 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E7%90%86%E8%A7%A3outofmemory%E5%BC%82%E5%B8%B8/</guid>
      <description>OutOfMemoryError 异常应该可以算得上是一个非常棘手的问题。JAVA 的程序员不用像苦逼的 C 语言程序员手动地管理内存，JVM 帮助他们分配内存，释放内存。但是当遇到内存相关的问题，就比如 OutOfMemoryError，如何去排查并且解决就变成一个非常令人头疼的问题。在 JAVA 中，所有的对象都存储在堆中，通常如果 JVM 无法再分配新的内存，内存耗尽，并且垃圾回收器无法及时回收内存，就会抛出 OutOfMemoryError。
我之前在做一个工具，需要读取大量的文件，比如 word 或者 excel，而我给机器分配的最大的内存只有 2G。所以，很多人的机器往往会因为 OutOfMemoryError 异常导致程序中止运行。后来我发现一个现象，OutOfMemoryError 可以通过 Error 或者 Throwable 去捕获，OutOfMemoryError 类继承关系如下：
java.lang.Object java.lang.Throwable java.lang.Error java.lang.VirtualMachineError java.lang.OutOfMemoryError 因此 OutOfMemoryError 是一个 Error 而不是一个 Exception，并且据我观察，OutOfMemoryError 无法被 throw 到上一层函数中。
private void OutOfMemoryErrorTest() {  try {  // do something might lead to OutOfMemoryError error  } catch (Error e) {  e.printStackTrace();  } } 发生 OutOfMemoryError 的原因 越早找出 OutOfMemoryError 的原因就越利于我们解决问题。到底是因为 JAVA 的堆满了还是因为原生堆就满了呢？为了找到其原因，我们可以通过异常的细节信息来获得提示。</description>
    </item>
    
    <item>
      <title>从一道面试题谈谈 setTimeout 和 setInterval</title>
      <link>https://madneal.com/post/%E4%BB%8E%E4%B8%80%E5%88%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%88%E8%B0%88settimeout%E5%92%8Csetinterval/</link>
      <pubDate>Sat, 21 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BB%8E%E4%B8%80%E5%88%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B0%88%E8%B0%88settimeout%E5%92%8Csetinterval/</guid>
      <description>最近有看到一道题目，使用 JavaScript，隔一秒打印一个数字，比如第 0 秒打印 0，第 1 秒打印 1 等等，如何去实现？
假如我们尝试使用 setTimeout 去实现：
for (var i = 0; i &amp;lt; 5; i++) {  setTimeout(function() {  console.log(i);  }, i * 1000); } 这样可以么，执行的结果是什么呢？你可以将这段代码粘贴到 浏览器的 Console 中运行一下。结果是，每隔一秒打印一个 5 ，一共打印 5 次。这是为什么呢，为什么不是打印 0, 1, 2, 3, 4 呢？众所周知，JavaScript 是一种单线程语言，主线程的语句和方法会阻塞定时任务的执行，在 JavaScript 执行引擎之外，存在一个任务队列。当代码中调用 setTimeout 方法时，注册的延时方法会挂在浏览器其他模块处理，等达到触发条件是，该模块再将要执行的方法添加到任务队列中。这个过程是与执行引擎主线程独立，只有在主线程方法全部执行完毕的时候，才会从该模块的任务队列中提取任务来执行。这就是为什么 setTimeout 中函数延迟执行的时间往往大于设置的时间。
因此，对于上述的代码块，每一个 setTimeout 函数都被添加到了任务队列中。然后，这还涉及到了函数作用于的问题。因为当任务队列中的函数执行的时候，其作用域其实是全局作用域。setTimeout 中的打印函数执行的时候就会在全局作用域中寻找变量 i，而此时全局作用域的变量 i 的值已经变成 5 了。这也就是为什么打印的数字都是 5。那么应该如何达到我们一开始预期的效果呢？这里我们就需要考虑到函数执行上下文的问题，可以通过立即执行函数（IIFE）来改变函数作用域。
for (var i = 0; i &amp;lt; 5; i++) {  (function(i) {  setTimeout(function() {  console.</description>
    </item>
    
    <item>
      <title>消灭 star 大作战--Front-end-tutorial</title>
      <link>https://madneal.com/post/%E6%B6%88%E7%81%ADstar%E5%A4%A7%E4%BD%9C%E6%88%98-front-end-tutorial/</link>
      <pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%B6%88%E7%81%ADstar%E5%A4%A7%E4%BD%9C%E6%88%98-front-end-tutorial/</guid>
      <description>写在前面 Github star 往往非常简单，点击一个按钮，就 star 了。但是你还去看它么，这就未必了。因此很多库长年累月的堆积在你的 star list 里面无人问津。因此，会有这样一个具有一个非常中二的名字的计划。对于 star 仓库，从后往前，一个个理解消化，不要让它无意义地堆积。
操作步骤：
 fork it finish it  仓库信息  仓库名称：Front-end-tutorial 主要内容：这是一个博客，里面主要是前端开发的内容，内容设计比较广泛，包括 HTML, CSS, JS 以及流行的框架，以及前端开发的其他内容。 消灭计划：内容较多，打算主要消化一些感兴趣的内容，主要应该集中于原生的东西或者一些性能方面的知识。  作战内容 JavaScript 深拷贝 深拷贝可以说是一个老生重谈的问题，几乎每一个前端面试都可能会问这样的问题。Js 中的对象都是引用，所以浅拷贝时，修改拷贝后的对象会影响原对象。原仓库中其实讲的并不是很深入，我反倒是觉得评论里面的一篇文章深入剖析 JavaScript 的深复制讲得更好。
有很多第三方库实现了对于对象的深拷贝。
 jQuery: $.extend(true, {}, sourceObject) loadsh: _.clone(sourceObject, true) 或者 _.cloneDeep(sourceObject)  另外有一个神奇的方法就是借助于 JSON 的 parse 和 stringify 方法，当时我才看到这个方法的时候惊为天人，这个方法还可以用来判断两个对象是否相等。当然，这个方法还是有一些限制，因为正确处理的对象只能是使用 json 可以表示的数据结构，对于函数可能就无能为力了。原文作者实现了一个深拷贝的方法，不过考虑了很多情况，在这里我们就实现一个简单版的深拷贝把。
function deepCopy(obj) {  const result = {};  for (const key in obj) {  if (obj.</description>
    </item>
    
    <item>
      <title>如何做一个完美的页码跳转</title>
      <link>https://madneal.com/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E9%A1%B5%E7%A0%81%E8%B7%B3%E8%BD%AC/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E7%9A%84%E9%A1%B5%E7%A0%81%E8%B7%B3%E8%BD%AC/</guid>
      <description>需求 想给系统实现一个选择不同页面的功能，一开始的代码逻辑比较混乱，后来抽象出来就比较清楚了。第一步，咱们先说需求：
问题定义 我们希望实现一个页面切换，每次显示的可选的页码长度都是固定的，比如从第 1 页到第 11 页，从 21 页 到 31 页。这样能够实现一个统一的切换效果，可能还需要考虑一些边界情况。现在，我们令总页码数为 pages，当前选择的页码为 p,p 往左走或者往右走的步长是固定的，令步长为 step。那么我们现在要做的事情可以这么理解，我们要从 1 到 pages 之间截取可用的页码数，假设开始页码为 startIndex，结束页码为 endIndex。抽象一下，我们可以总结出以下几种情况：
Condition1 startIndex &amp;lt; 1 &amp;amp;&amp;amp; endIndex &amp;lt;= pages
Condition2 startIndex &amp;gt;= 1 &amp;amp;&amp;amp; endIndex &amp;gt; pages
Condition3 startIndex &amp;lt; 1 &amp;amp;&amp;amp; endIndex &amp;gt; pages
Condition4 startIndex &amp;gt;= 1 &amp;amp;&amp;amp; endIndex &amp;lt;= pages
这样抽象成四种情况，这样就比较容易理解。以线段的方式来理解，则是从 1 到 pages 截取页码。
代码实现 Show me the code.
func GetPageList(p, step, pages int) ([]int) { 	pageList := make([]int, 0) 	startIndex := p - step 	endIndex := p + step  	if startIndex &amp;lt; 1 &amp;amp;&amp;amp; endIndex &amp;lt;= pages { 	startIndex = 1 	endIndex = startIndex + 2 * step 	} else if startIndex &amp;gt;= 1 &amp;amp;&amp;amp; endIndex &amp;gt; pages { 	endIndex = pages 	startIndex = pages - 2 * step 	} else if startIndex &amp;lt; 1 &amp;amp;&amp;amp; endIndex &amp;gt; pages { 	startIndex = 1 	endIndex = pages 	} 		// handle some special cases 	if startIndex &amp;lt; 1 { 	startIndex = 1 	}  	if endIndex &amp;gt; pages { 	endIndex = pages 	}  	for i := startIndex; i &amp;lt;= endIndex; i++ { 	pageList = append(pageList, i) 	}  	return pageList } 结语 没有思考清楚的时候，你的逻辑是混乱的，写出来的代码也是混乱的。所以先整理好思路，想好应该怎么写，可以画画图，理理思路，这样写出的代码既有逻辑出现 bug 的概率也会大大降低。另外一点，很多人觉得写业务和算法可能就相去甚远，都有时候认真想想，或许你的业务代码也可以抽象成一个小算法。</description>
    </item>
    
    <item>
      <title>pwa, 上海地铁线路图全新重构</title>
      <link>https://madneal.com/post/pwa-%E4%B8%8A%E6%B5%B7%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF%E5%9B%BE%E5%85%A8%E6%96%B0%E9%87%8D%E6%9E%84/</link>
      <pubDate>Wed, 21 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/pwa-%E4%B8%8A%E6%B5%B7%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF%E5%9B%BE%E5%85%A8%E6%96%B0%E9%87%8D%E6%9E%84/</guid>
      <description>之前一直有在维护一个上海地铁线路图的 pwa，最主要的特性就是 &amp;ldquo;offline first&amp;rdquo;。但是由于代码都是通过原生的 js 去实现，之前我都不是很喜欢去用框架，不想具有任何框架的偏好。但是到后期随着代码量的增加，代码的确变得混乱不堪，拓展新功能也变得尤为困难。因此，花了将近两个礼拜的时候对于应用进行了一次完整的重构。网站访问地址：https://neal1991.github.io/subway-shanghai
准备 准备工作先做好，在 vue 和 react 之间，我还是选择了后者。基于 create-react-app 来搭建环境，crp 为你准备了一个开箱即用的开发环境，因此你无需自己亲手配置 webpack，因此你也不需要成为一名 webpack 配置工程师了。
另外一方面，我们还需要一些数据，包括站点信息，线路路径，文字说明等等。基于之前的应用，可以通过一小段的代码获取信息。就此如要我们获取我们以前的站点在 svg 图中的相关属性，普通的站点使用 circle 元素，为了获取其属性：
const circles = document.querySelectorAll(&amp;#39;circle&amp;#39;); let result = []; circles.forEach(circle =&amp;gt; {  let ele = {  cx: circle.cx,  cy: circle.cy,  sroke: circle.stroke,  id: circle.id  };  result.push(ele); }) const str = JSON.stringify(result); 通过这样的代码我们就可以获取 svg 普通站点信息，同理还可获取中转站信息，线路路径信息以及站点以及线路 label 信息。还有，我们还需要获取每个站点的时刻表信息，卫生间位置信息，无障碍电梯信息以及出入口信息。这里是写了一些爬虫去官网爬取并做了一些数据处理，再次就不一一赘述。
设计 数据准备好之后，就是应用的设计了。首先，对组件进行一次拆分：
组件结构 将整个地图理解成一个 Map 组件，再将其分为 4 个小组件：</description>
    </item>
    
    <item>
      <title>通过七牛云建立私有图床</title>
      <link>https://madneal.com/post/%E9%80%9A%E8%BF%87%E4%B8%83%E7%89%9B%E4%BA%91%E5%BB%BA%E7%AB%8B%E7%A7%81%E6%9C%89%E5%9B%BE%E5%BA%8A/</link>
      <pubDate>Sun, 25 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%80%9A%E8%BF%87%E4%B8%83%E7%89%9B%E4%BA%91%E5%BB%BA%E7%AB%8B%E7%A7%81%E6%9C%89%E5%9B%BE%E5%BA%8A/</guid>
      <description>七牛云是国内一家领先的云存储公司，可以利用七牛云存储对象存储图片。虽然现在各种图床，但还是希望能够搭建一个私有的图床。所以一直有希望使用七牛云搭建图床的想法，之前一直没有好好地看懂七牛云的 SDK，后来在仔细地看了一遍之后，终于知道如何利用官方的 SDK 来实现图片上传。过年在家花了一点时间，后来陆续也写了一点，完成了这个七牛云图床 chrome 拓展。
注册账户 首先你可以通过这个链接注册你的七牛云账户。在成功注册账户之后，可能还需要绑定手机号，你就可以创建存储空间，可以理解成为文件存储的文件夹。
创建好存储空间（bucket）就已经完成了私有图库的第一步。
开发 在这也会对所有代码一一解释，主要是讲解一下在开发中遇到的一些问题。首先基于七牛云存储开发，有必要学会七牛云存储 API 的使用。可以在官方 SDK 文档获取所有文档。本拓展的开发主要是基于 js 来进行开发，因此我们只需要了解 js SDK 文档。
文档中提到了一点：JS-SDK 依赖服务端颁发 token，可以通过以下二种方式实现：
 利用七牛服务端 SDK 构建后端服务 利用七牛底层 API 构建服务，详见七牛上传策略和上传凭证(https://developer.qiniu.com/kodo/manual/1208/upload-token)  第一个方法还需要搭建服务器来颁发 token，显然这种方法不太经济，如果仅仅是为了这个图床搭建一个后端服务，就不太划算了。因此，我选择第二种，在客户端来生成 token。这种方法就需要你了解上传策略以及上传凭证。
上传策略是资源上传时附带的一组配置设定。通过这组配置信息，七牛云存储可以了解用户上传的需求：它将上传什么资源，上传到哪个空间，上传结果是回调通知还是使用重定向跳转，是否需要设置反馈信息的内容，以及授权上传的截止时间等等。上传策略主要是 scope 和 dealine 这两个字段是必须要的。scope 是指定上传的目标资源空间 Bucket 和资源键 Key，这里我们只需要设置 bucket。deadline 是上传凭证有效截止时间。Unix时间戳，单位为秒。该截止时间为上传完成后，在七牛空间生成文件的校验时间，而非上传的开始时间，官方建议建议设置为上传开始时间 + 3600s。
function genPolicy(scope) {  let policy = {  scope: scope,  deadline: (new Date()).getTime() + 3600  }  return policy; } 按照上述算法流程构建客户端的上传 token，官方有提供上传凭证的在线示例，通过整理形成了自己的 token.</description>
    </item>
    
    <item>
      <title>聊聊答题应用题库的建立</title>
      <link>https://madneal.com/post/%E8%81%8A%E8%81%8A%E7%AD%94%E9%A2%98%E5%BA%94%E7%94%A8%E9%A2%98%E5%BA%93%E7%9A%84%E5%BB%BA%E7%AB%8B/</link>
      <pubDate>Fri, 23 Feb 2018 22:30:09 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%81%8A%E8%81%8A%E7%AD%94%E9%A2%98%E5%BA%94%E7%94%A8%E9%A2%98%E5%BA%93%E7%9A%84%E5%BB%BA%E7%AB%8B/</guid>
      <description>前段时间，答题 APP 如火如荼的发展，各大互联网公司都加入了撒币大战，包括像冲顶大会，百万英雄，芝士英雄等等。随之而来的也是各个答题应用辅助的兴起。
网上已经有不少答题应用的辅助，一般来说包括两个步骤，即获取题目选项以及搜索答案。对于题目以及选项的获取包括利用 adb 抓取手机屏幕截图，然后使用 ocr(optical character recognization) 的方式去识别题目和选项。大多数使用的 ocr 工具有谷歌开源的 tesseract-ocr以及百度的 ocr API。谷歌的 tesseract-ocr 可以在本地进行安装，软件下载地址是 https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-3.05.01.exe ， 安装的时候注意选择增加中文简体语言包，否则无法识别中文。另外一种方法就是利用百度的 ocr API，可以免费申请，使用起来比较方便，识别率相对来说也更加准确。百度 API 还有一个优点是图片无需处理就可以进行识别，而 tesseract-ocr 一般还需要对图片进行简单的处理。获取题目以及选项的另外一种方式就是使用抓包工具去抓取 APP 请求从而获取题目以及选项信息。
另一方面，对于题目答案的搜索。常见的几种做法是直接用题目作为搜索关键字打开浏览器，或者是问题加选项搜索，获取搜索引擎搜索的结果数量。通过结果数量来判断问题和选项的相关性从而判断问题的答案，一般来说这种方式获取的答案都是不太准确的，一是因为现在题目的出题方式越来越诡异，二是相关性越大并不一定就意味着是正确答案。本来对于题目和选项的判断就是很难的一件事情，除非你能做出很完美的语意理解，否则很难判断出正确的选项。还有一种比较直白的方式就是建立题库。在本文中，我们讨论一种建立题库的方式，这里只是做一个简单的探索，未必在实际中就能够使用，因为题库必须足够全才能够发挥威力。
使用 elasticsearch 建立题库 本文主要讲解关于题库的建立方面的很小的一方面进行探索，对于答题辅助的使用可以阅读原文查看完整介绍，代码主要是基于TopSup 做了一些调整。Elasticsearch 将被用于题库的建立，对于 es 的安装可以查看第一篇文章。有人可能会觉得用 es 来做题库，简直就是高射炮打蚊子——小题大做。但我觉得 es 安装和使用都很方便，得益于其强大的 RESTFUL接口，几乎可以用任何工具操控 es。Talk is cheap, show me the code.
from elasticsearch import Elasticsearch  def write_quetion():  question = {  &amp;#39;question&amp;#39;: &amp;#39;谁是世界上最帅的人&amp;#39;,  &amp;#39;answer&amp;#39;: &amp;#39;Neal&amp;#39;  }  es = Elasticsearch({&amp;#39;localhost&amp;#39;})  es.</description>
    </item>
    
    <item>
      <title>POI读取文件的最佳实践</title>
      <link>https://madneal.com/post/poi%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 26 Nov 2017 16:29:33 +0000</pubDate>
      
      <guid>https://madneal.com/post/poi%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>POI是 Apache 旗下一款读写微软家文档声名显赫的类库。应该很多人在做报表的导出，或者创建 word 文档以及读取之类的都是用过 POI。POI 也的确对于这些操作带来很大的便利性。我最近做的一个工具就是读取计算机中的 word 以及 excel 文件。下面我就两方面讲解以下遇到的一些坑：
word 篇 对于 word 文件，我需要的就是提取文件中正文的文字。所以可以创建一个方法来读取 doc 或者 docx 文件：
 private static String readDoc(String filePath, InputStream is) { String text= &amp;#34;&amp;#34;; try { if (filePath.endsWith(&amp;#34;doc&amp;#34;)) { WordExtractor ex = new WordExtractor(is); text = ex.getText(); ex.close(); is.close(); } else if(filePath.endsWith(&amp;#34;docx&amp;#34;)) { XWPFDocument doc = new XWPFDocument(is); XWPFWordExtractor extractor = new XWPFWordExtractor(doc); text = extractor.getText(); extractor.close(); is.close(); } } catch (Exception e) { logger.</description>
    </item>
    
    <item>
      <title>基于ELK进行邮箱访问日志的分析</title>
      <link>https://madneal.com/post/%E5%9F%BA%E4%BA%8Eelk%E8%BF%9B%E8%A1%8C%E9%82%AE%E7%AE%B1%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 16 Nov 2017 09:11:39 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%9F%BA%E4%BA%8Eelk%E8%BF%9B%E8%A1%8C%E9%82%AE%E7%AE%B1%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%86%E6%9E%90/</guid>
      <description>公司希望能够搭建自己的日志分析系统。现在基于ELK的技术分析日志的公司越来越多，在此也记录一下我利用ELK搭建的日志分析系统。
系统搭建 系统主要是基于elasticsearch+logstash+filebeat+kibana+nginx，其实我这个用的还是比较多的，可以直接用logstash直接去采集日志。不过由于logstash的性能影响都比较大，而且filebeat安装很方便，而且占用资源很小，所以现在filebeat现在被广泛应用于日志采集。
其实在搭这个系统还是比较麻烦的，可是前面有的踩过的坑当时没有及时记录下来，有点忘记了。但是里面就是配置logstash和filebeat配置证书的时候有点麻烦，配置不好会一直没有办法连通。还要注意ES的索引占得空间，其实ES索引还蛮占空间的。
Logstash Logstash其实在整个ELK中环节还蛮重要的，其实可以理解为一个“中间人”的角色。它通过从filebeat中接受数据，然后进行过滤，最后再传输给es。所以一般logstash的配置也包括input,output以及filter的配置。
filter logstash中的filter比较重要，可以对日志利用正则进行过滤，这样你可以更关心日志中你需要关注的字段。强烈建议去grokdebugger去调试你的grok正则表达式，但是国内访问速度比较慢，可以采取一定手段访问。上面还有grok内置的一些常用正则表达式，可以配合试用调试。
geoip 日志分析中往往涉及到ip归属地的查询。logstash自带的geoip插件已经自带了数据库，可以下载最新的数据库。同时，geoip里面包含了很多信息，你可以进行过滤，只选择自己想要的字段：
geoip { fields =&amp;gt; [&amp;#34;city_name&amp;#34;, &amp;#34;country_name&amp;#34;] } 日志分析 邮箱日志的格式是IIS的日至格式，日志是由空格分割开的一些字段信息。主要的字段包含以下这些字段信息：
#Fields: date time s-ip cs-method cs-uri-stem cs-uri-query s-port cs-username c-ip cs(User-Agent) sc-status sc-substatus sc-win32-status time-taken 针对这个日志，我利用grok去解析这些字段的信息，自定义的正则规则是：
DATE_CH \d+[/-]\d+[/-]\d+ OUTER_EMAIL %{DATE_CH:date} %{TIME:time} %{IP:serverIp} %{WORD:method} %{URIPATH:uristem} %{PARAM:query} %{INT:port} %{NOTSPACE:username} %{IP:clientIp} %{NOTSPACE:ua} %{INT:status} %{INT:substatus} %{INT:win32status} %{INT:timetaken} 通过grok我们可以获取这些字段，但如何在这些字段中挖掘有用的信息呢？这里面比较有价值的信息就是用户的登录时间，登录客户端，以及登录的ip。通过之前的 geoip 的配置，我们可以获取到ip对应的地址信息。登录时间由于很多邮件客户端在后台会去同步或者去登陆，所以参考意义不是特别的大。
后续对于日志如何进行分析，我目前还没有特别好的思路，希望有着方面经验的小伙伴可以一起交流。</description>
    </item>
    
    <item>
      <title>出去就餐并且理解Express.js的基本知识</title>
      <link>https://madneal.com/post/%E5%87%BA%E5%8E%BB%E5%B0%B1%E9%A4%90%E5%B9%B6%E4%B8%94%E7%90%86%E8%A7%A3express.js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 12 Nov 2017 17:12:53 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%87%BA%E5%8E%BB%E5%B0%B1%E9%A4%90%E5%B9%B6%E4%B8%94%E7%90%86%E8%A7%A3express.js%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid>
      <description>Going out to eat and understanding the basics of Express.js出去就餐并且理解Express.js的基本知识  原文：Going out to eat and understanding the basics of Express.js
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 如果你曾经去过一个坐下来就餐的餐厅，那么你可以了解 Express 的基础知识。 但是，如果你刚刚开始构建你的第一个 Node.js 后端&amp;hellip;&amp;hellip;你可能并不会很顺利。
是的 - 如果你曾经有过 JavaScript 经验，学习 Node 肯定更容易。 但是，在构建后端时面临的挑战与在前端使用JavaScript 时所面临的挑战完全不同。
当我学习Node时，我选择了困难的方式。 我一遍又一遍地学习电子书，写作教程和视频，直到我终于明白我为什么要做我正在做的事情。
有一个更简单的方法。 我打算用一个餐馆的比喻来解释你的第一个应用程序的四个关键部分。 Express.js 是一个组织你的代码的流行框架，我会为任何初学者推荐它。 稍后我会进一步解释。
下面是我们将会涉及到的四个关键部分：
 The require statements Middleware Routing App.</description>
    </item>
    
    <item>
      <title>将Medium中的博客导出成markdown</title>
      <link>https://madneal.com/post/%E5%B0%86medium%E4%B8%AD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E6%88%90markdown/</link>
      <pubDate>Sat, 23 Sep 2017 16:33:06 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%B0%86medium%E4%B8%AD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E6%88%90markdown/</guid>
      <description>Medium（需要翻墙访问）是国外非常知名的一个博客平台。上面经常有很多知名的技术大牛在上面发布博客，现在一般国内的搬运的技术文章大多数都是来自于这个平台。
Medium 文章格式显示地非常优雅，但是存在一个问题。众所周知，markdown已经是最受程序猿欢迎的文本编辑格式之一。但是Medium仅仅支持markdown格式导入，不支持markdown格式的导出。这也正是我当初开发这个插件export-medium的原因，现在这个项目是放在github上面的，欢迎大家多多star,或者pr。自己也花了5美金，注册了开发者账号，因为现在chrome对于不是商店的插件限制很严格，如果没上商店，一直有提醒，很麻烦。商店访问地址在这,需要翻墙访问。不过你可以手动安装:
 将 export-medium clone 或者下载到本地。 在 Chrome 浏览中打开chrome://extensions,加载已解压的拓展程序，选择项目文件夹  这两种方法都是可以支持安装的。目前这个插件的功能主要是把Medium上面的文章解析成 markdown 格式的文本，用了一个简单的库去渲染（事实上我觉得挺鸡肋的），然后你只要点击一个按钮就可以把文本复制到剪切板，就可以复制到编辑器了，是不是很方便。
目前可能很多页面做的不是特别好看，欢迎大家感兴趣的可以试用或者向我提建议。
仓库地址: https://github.com/neal1991/export-medium （喜欢的还请多多star!!!)</description>
    </item>
    
    <item>
      <title>Mongoose中document和object的区别</title>
      <link>https://madneal.com/post/mongoose%E4%B8%ADdocument%E5%92%8Cobject%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 17 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/mongoose%E4%B8%ADdocument%E5%92%8Cobject%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>这个问题其实是mongoose非常常见的问题，经常有很多以前没遇到这个问题的人都会被这个问题弄得怀疑人生。我们先介绍一些问题的背景。先看下面一段代码：
router.get(&amp;#39;/&amp;#39;, function(req, res, next) {  // res.render(&amp;#39;index&amp;#39;, { title: &amp;#39;Express&amp;#39; });  const model = mongoose.model(&amp;#39;realestate&amp;#39;);  const queryCretia = {};  model.find(queryCretia, (err, docs) =&amp;gt; {  res.render(&amp;#39;index&amp;#39;, {  title: &amp;#39;express&amp;#39;,  docs: docs  })  }) }); &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;%= title %&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#39;stylesheet&amp;#39; href=&amp;#39;/stylesheets/style.css&amp;#39; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;%= title %&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;Welcome to &amp;lt;%= title %&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;!-- &amp;lt;%= docs %&amp;gt; --&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;% docs.</description>
    </item>
    
    <item>
      <title>JavaScript是如何工作的：引擎，运行时间以及调用栈的概述</title>
      <link>https://madneal.com/post/javascript%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BC%95%E6%93%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 13 Sep 2017 21:04:31 +0000</pubDate>
      
      <guid>https://madneal.com/post/javascript%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BC%95%E6%93%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0/</guid>
      <description>JavaScript是如何工作的：引擎，运行时以及调用栈的概述  原文：How JavaScript works: an overview of the engine, the runtime, and the call stack
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 随着JavaScript变得越来越流行，团队在多个层级都对它进行利用－前端，后端，混合应用，嵌入式设备以及更多。
正如GitHut stats所展示的那样，JavaScript是Github上面最活跃以及总Push次数最多的语言。在其它类别中也不会落后太多。 (获取最新的 GitHub language stats).
如果项目对于JavaScript越来越依赖，这意味着为了构建好的软件开发者必须利用这个JS提供的一切并且对于生态系统的内部有着更深的理解。
因此，尽管每天有很多开发者在使用JavaScript，但并不知道内部到底发生了什么。
概览 几乎每个人都已经听说过V8引擎的概念，并且很多知道JavaScript是单线程的或者它是使用一个回调队列的。
在这篇博文中，我们将会详细讲述所有概念并且解释JavaScript是如何真正运行的。在了解这些细节之后，你将能够写出能够适宜地利用提供的API的更好的，非阻塞的app。
如果对于JvaScript来说还不是很了解，这篇博文将会帮助你理解为什么JavaScript和别的语言相比如此“奇怪”。
如果你是一个有经验的JavaScript开发者，希望这篇文章能够让你对你每天使用的JavaScript Runtime是如何真正工作的。
JavaScript 引擎 最流行的JavaScript引擎的例子之一就是谷歌的V8引擎。比如Chrome以及Node.js内部就是使用V8引擎。下面是一个简单的视图示例：
引擎主要由两个部分组成：
 内存堆——这是内存分配发生的地方 回调——这是你代码执行时的栈帧。  Runtime 有很多浏览器中的API几乎都被JavaScript开发者使用过（比如：&amp;lsquo;setTimeout&amp;rsquo;）。然而这些API并不是由引擎提供的。
那么，它们是从哪来的呢？
事实证明这有一点复杂。
因此，虽然我们有引擎但实际上是有更多。我们有那些由浏览器提供的Web API，像DOM, AJAX, setTimeout以及更多。
接着，我们还有非常流行的事件循环(event loo)以及回调队列(callback queue)。</description>
    </item>
    
    <item>
      <title>什么是服务端伪造（SSRF）</title>
      <link>https://madneal.com/post/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%AA%E9%80%A0ssrf/</link>
      <pubDate>Sun, 06 Aug 2017 21:44:24 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%AA%E9%80%A0ssrf/</guid>
      <description>什么是服务端伪造（SSRF）  原文：GitHub Pages and Single-Page Apps
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 服务端伪造（SSRF）指的是攻击者从一个具有漏洞的web应用中发送的一个伪造的请求的攻击。SSRF通常适用于针对在防火墙后一般对于外部网络的攻击者是无法访问的内部系统。另外，攻击者也可能利用SSRF来访问监听回送地址接口（127.0.0.1）的服务。
典型的SSRF发生在web应用发送请求的时候，攻击者对这个发送的请求具有全部或者部分的控制。一个通用的例子就是攻击者能够控制全部或者部分web应用向第三方服务发送请求的URL。
下面的是PHP中容易收到SSRF的一个例子。
&amp;lt;?php  /** * Check if the &amp;#39;url&amp;#39; GET variable is set * Example - http://localhost/?url=http://testphp.vulnweb.com/images/logo.gif */ if (isset($_GET[&amp;#39;url&amp;#39;])){ $url = $_GET[&amp;#39;url&amp;#39;];  /** * Send a request vulnerable to SSRF since * no validation is being done on $url * before sending the request */ $image = fopen($url, &amp;#39;rb&amp;#39;);  /** * Send the correct response headers */ header(&amp;#34;Content-Type: image/png&amp;#34;);  /** * Dump the contents of the image */ fpassthru($image); } 在上面的例子中，因为攻击者对于url参数具有完整的控制，因此能够对于网上的任何网站都能够发送任意的GET请求。攻击者也能够向服务器中的资源发送请求。</description>
    </item>
    
    <item>
      <title>通过利用immutability的能力编写更安全和更整洁的代码</title>
      <link>https://madneal.com/post/%E9%80%9A%E8%BF%87%E5%88%A9%E7%94%A8immutability%E7%9A%84%E8%83%BD%E5%8A%9B%E7%BC%96%E5%86%99%E6%9B%B4%E5%AE%89%E5%85%A8%E5%92%8C%E6%9B%B4%E6%95%B4%E6%B4%81%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 21 May 2017 11:41:05 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%80%9A%E8%BF%87%E5%88%A9%E7%94%A8immutability%E7%9A%84%E8%83%BD%E5%8A%9B%E7%BC%96%E5%86%99%E6%9B%B4%E5%AE%89%E5%85%A8%E5%92%8C%E6%9B%B4%E6%95%B4%E6%B4%81%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>通过利用immutability的能力编写更安全和更整洁的代码  原文：Write safer and cleaner code by leveraging the power of “Immutability”
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 Immutability是函数式编程的重要基础之一。它允许你能编写更安全以及更整洁的代码。我将会通过一些JavaScript例子来向你展示如何来达到immutability。
根据维基百科：
 不可变对象是一个在创建之后不能修改其状态的对象。这正与可变对象相反，它能够在创建之后被修改。在某些情况下，对象被认为是不可变的，即使其内部的某些属性发生改变，但是从外部的角度来看这个对象的状态看起来还是没有发生变化的。
 Immutable数组 数组是理解immutability如何工作的很好的起点。让我们一起来看一看。
const arrayA = [1, 2, 3]; arrayA.push(4);  const arrayB = arrayA; arrayB.push(5);  console.log(arrayA); // [1, 2, 3, 4, 5] console.log(arrayB); // [1, 2, 3, 4, 5] 这个例子将arrayA的引用分配给arrayB，因此这个push方法在这两个变量中都会添加5这个值。我们的代码间接地修改其它的值，这并不是我们想要的。这也违反了immutability的原则。</description>
    </item>
    
    <item>
      <title>菜鸟程序员成长史 --记 Github 1000&#43; contributions</title>
      <link>https://madneal.com/post/programer/</link>
      <pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/programer/</guid>
      <description>其实一直以来想写一篇文章总结这几年的技术学习，刚好趁着自己的第一次 github contribution 达到1000+，写篇文章总结以下。本文篇幅较长，我会分为几个章节来分别阐述。
博客篇 为什么我要把博客放在第一位呢？因为我认为博客是developer学习技术的平台，也是developer分享知识的平台，博客差不多也就相当于是developer的名片。现如今，博客平台形形色色，有老牌的博客园，CSDN，也有现在比较新潮的SegmentFault，掘金，开发者头条，知乎等等。现在博客的形式已经发展得多种多样，现如今新潮的犹如各种各样的专栏等等。当然，在这么多博文中，有很多质量很高的文章，也有很多滥竽充数的垃圾文章。下面，我就就我个人的了解探探我接触的这些博客平台，仅是个人观点。
Github 哈哈。我为什么把Github列到博客篇呢？其实现在Github几乎已经成为了我生命中不可或缺的一部分，每天打开电脑的一件事，基本就是打开Github看看。作为世界上最大的同性交友网站，Github对于程序猿来说绝对是生命中不可或缺的部分。在此，我主要说说Github作为博客方面的内容。 很多人认为Github只不过是一个代码托管的地方，为什么会和博客有关系呢？其实，现在很多人都是在Github的issue里面开博客，因为issue里面方便作者和读者的沟通，而且支持markdown格式，各种功能也是很丰富。对于比较关注的博客，你可以设置watch，这样你就可以了解issue里面的每一次变化，并且还会有相应的邮件通知。在此，给出几个我关注的几个人的Github博客：
 iCSS：讲解CSS的，有的还是蛮有趣的。 梁少峰的个人博客：讲解vue讲解的很透彻，百度大牛，我觉得有些博文挺值得看，而且值得多看几遍，不过我好像都没看完。他的博文还是需要深度挖掘的。 ccforward/cc：应该是当初关注他的一个知乎爬虫，他的博客内容我没有看太多，但是内容貌似还不错。 underscore-analysis：解析underscroe源代码的，挺不错的，我看过一两篇，值得多读几篇，我自己也该去读了。 Front-end-tutorial：内容很多，我没有过多了解，可以了解一下。  以上就是我了解的一些在Github上面的博客，因为在Github我没有特别关注这方面，所以还不是特别多，当然Github也不是我主要逛博客的地方。
CSDN CSDN是我开启个人技术博客的地方，感兴趣的地方去我的博客逛逛http://blog.csdn.net/neal1991 。我应该是从2015年4月份开始写博客的，博客的内容主要有我研究生期间一开始做的道路识别的一些研究的论文，虽然这个方向没搞下去，这个方向的确很有前景，只能说老板很有眼光，但我没能力，没能搞下去。其它的也包括一些开发过程遇到的坑之内的，面试经历，技术文章翻译。老实说，CSDN现在的确不是一个很好的平台，因为本身它就偏老，在markdown的显示不是很完美，在移动端显示不是很好，还有一点很重要，广告特别多，还是莫名其妙的，看起来很讨厌。其实我一直都想弃坑，奈何就是github国内访问速度不稳定，还有毕竟在这边维护这么久了，所以还是一直维护着。在CSDN上，我基本上都是去写博客，基本不会在它上面浏览技术博客，因为它的浏览界面实在是太杂乱了，没有重点。这可能也是老牌博客的一个缺点，可能一时半会也没办法改过来。下面我主要讲一些我自己的一些比较稍微有用的博客内容：
 combox系列问题集：当初做winform开发遇到的问题，记得当初最坑爹的是调试combox的时候，visual studio老是崩溃，后来发觉居然是有道翻译的锅，也是醉了。。。 独立成分分析：这个应该是当初一个讨论班里面要做的一个presentation，我把内容整理出来写了这篇博文，阅读量快2000了，好像是我博客里面阅读次数最多的了。 如何查找django安装路径：非常简单的一个问题，但是当初搜遍了，没找到解决方法。 mongoose对象无法新增删除属性：当初在处理mongo遇到的一个问题，是个坑。 第一个chrome extension：第一次写chrome extension，没有想象中的那么复杂，不过还是有一些方法的，貌似360有翻译过谷歌相关的文档。老实说，谷歌真的很良心，现在很多开发者文档都已经是中文的了。 第一个pwa：第一次写progressive web application，其实写pwa和写其它单页面应用没有特别大的区别。pwa也是我非常看到的技术栈，我觉得这个比小程序好上一百倍，只不过现在在国内还是不温不火，但是我觉得很肯能哪一天就星星之火，可以燎原了。  鉴于CSDN平台的种种，我的确越来越不太愿意在这上面写文章。而且我最近的文章一向是以翻译国外技术文章为主，毕竟还是菜，所以只能靠英语吃饭啦。
掘金 老实说，掘金应该是同类这种网站访问量比较大的。的确，里面有不少的精品内容，当然也会参杂很多乱七八糟的东西。其实，现在一般的原创博主都不会只在一个平台发文章，所以基本上你这个平台看得到的，在其它平台也差不多都能看到。只不过我现在基本不看掘金了，因为他们的编辑对新人极度不友善，极度不友好。
众成翻译 360的一个专门翻译技术博客为主的平台，目前应该还是比较小众。360的前端其实还是蛮不错的，尤其是他们的齐舞团队，里面也有很多大牛。这个平台里面的文章一半质量还是比较高的，而且这个平台翻译操作也是蛮舒适的，感兴趣的非常值得试一试。而且他们的群沟通都很流畅，不像掘金那帮人。。。无力吐槽。
知乎 我本身一向是很排斥知乎的。讲心里话，知乎里面百分之八十的人都是在写故事，骗关注的，我也不明白知乎为什么充斥了这么多天天无事可做的人。当然，不可否认的是，知乎里面还是存在百分之二十的精品内容的，这也是让我能够忍受那剩余的百分之八十垃圾的原因。知乎里面那些回答我觉得没有太大的意义，看了也就是笑一笑，一般都是用来刷新三观用的，在此，我仅说一些技术专栏：
 饿了么前端：饿了么现在前端的确搞得风生水起，尤其是pwa，感觉他们是这方面搞得国内最为成熟的一家。可能并不是，但他们肯定是分享这方面内容最多的公司。感觉饿了么前端蛮多大牛，不过感觉他们都喜欢混国外圈，黄玄基本都是在medium发文章的。。。 某熊的全栈之路：这个应该是infoq的专栏，这个编辑每个礼拜会发一个国内外最新技术的文章集合，基本是前端为主。内容比较新颖，基本上最时髦的都在这里面。 Think In Vue：意如其名，现在vue在国内真的很火。火到我觉得用react的撕逼应该撕不过vue，vue的作者尤雨溪在知乎也是很活跃的，经常手撕任何喷vue的人，还有看他阮一峰每日一喷很有意思。阮老师也是个很有意思的人，感觉天天都有人喷他，但是阮老师的心态丝毫不受影响，剖有大师风范。不过值得一提的是，阮老师博客的广告位可价值不菲哦~~ 美团点评技术博客：算得上是大厂，值得一看。  知乎乱，前端乱，如何乱中取胜，就是要保持一颗平常心。
开发者头条 不温不火的平台，文章质量还行。我一般发文章这个里面也会发一份。感觉里面的内容偏机器学习以及架构方面，而且这发文章可以攒IO币，可以换书哟。
Medium 国外的一个博客平台，访问需要翻墙。这是国外一个专门写story的地方，样式很好看，应该算得上是国外非常知名的一个博客平台了。当然了，里面的内容也是多姿多彩的，同时里面的技术文章质量也有很多很高的文章。现在国内技术圈翻译的大多数文章基本都是来自于这个平台。
Quora 国外一个和知乎一样的网站。不过知乎由于国内人数优势，火爆异常。Quora则是不温不火，而且上面还有不少华人。我关注过一段时间，但貌似都没什么特别的内容。 以上基本就是我所有的对于一些博客平台的了解，可能不包含所有，但基本都是我自己的个人的亲身经历。可能部分言辞颇为激烈，但也都是我的肺腑之言。
微信公众号 微信公众号作为一种特殊的平台，现在也成为一种传播渠道，有点类似于报看订阅的形式。但这不一定是一种非常有效的传播方式，感觉深度还是不够的，我比较喜欢在电脑上看文章，因为在手机上看文章难以持续地专注于一篇有内容的文章，一般就只能浅尝则止。所以我一般都是把链接转到我的微信PC版，然后再用浏览器打开，下面介绍一些我关注的一些技术类公众号：
 前端之巅：我之前提过的，应该是infoQ的平台，其实和之前的知乎专栏应该是重叠的。 奇舞周刊：360奇舞团队，前面也介绍过了，国内的知名的前端团队，会有一些比较有价值的文章。 前端早读课：每天早上都会发送推文，但是文章质量嘛，参差不齐，基本上都是别人的文章。 FEX：百度FEX团队，收集最新技术文章，但是排版比较差，比较原始。 神秘的程序员们：里面会有一些脑洞大开的漫画，而且会有程序猿和产品经理以及架构师撕逼的故事，很有趣。  Github 为什么我要把Github单独作为一章节来讲呢？因为它实在太重要了！！！以至于我除了它，根本不想去尝试其它类似的平台。关于Github可以讲的东西太多太多，它带给程序员的则是无穷的魅力。在此，我也仅就几个方面谈谈我的个人理解：
star篇 Star是衡量一个开源项目是否受欢迎的重要标准之一（当然也有很多是骗star的）。其实，现在很多人看到一个项目都会去star，但是后续是否会关注，当然也就不一定了。曾经有一段时间，我对star深深着迷（其实现在还是很着迷），我每天都希望有人能给我的项目star，看着别人上千的star我都会超级羡慕。但我其实也能够深深体会到做一个开源项目的不容易，开发者有一个idea往往很简单，但是要去实现它，推广它，完善它。这真的很难很难，而且还会有各种各样形形色色的人问你各种问题，给你提出各种要求，这些都是很痛苦的。但是我依然希望自己有一天还是能够成为一名出色的开源项目的开发者。下面我就挑一些我star的项目来讲一讲：
 prepack：前几天，前端圈最火的技术，编译优化，facebook总是走在潮流之端。 sw-precache &amp;amp; sw-toolbox：谷歌关于pwa的相关工具，值得关注。 chrome-remote-interface：师妹介绍我的一个调用headless Chrome的工具，文档阅读起来比较痛苦，可以码，虽然你也不一定看。 hammer.</description>
    </item>
    
    <item>
      <title>基于Vue JS, Webpack 以及Material Design的渐进式web应用 [Part 1]</title>
      <link>https://madneal.com/post/%E5%9F%BA%E4%BA%8Evue-js-webpack-%E4%BB%A5%E5%8F%8Amaterial-design%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8Fweb%E5%BA%94%E7%94%A8-part-1/</link>
      <pubDate>Thu, 11 May 2017 09:28:40 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%9F%BA%E4%BA%8Evue-js-webpack-%E4%BB%A5%E5%8F%8Amaterial-design%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8Fweb%E5%BA%94%E7%94%A8-part-1/</guid>
      <description>基于Vue JS, Webpack 以及Material Design的渐进式web应用 [Part 1] 原文：基于Vue JS, Webpack 以及Material Design的渐进式web应用 [Part 1]
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
渐进式web应用是大势所趋。越来越多的大公司开始使用这些技术（比如推特：https://mobile.twitter.com/）。
想象你可以在地铁中浏览一个web应用，这个应用能够向用户推送通知并且提供实时的数据，以及提供类似于app的浏览，这些就是PWA的大致的能力。
渐进式web应用（PWA）是一个web应用能够提供给用户一种类似于app的体验。PWA得益于现代web科技创新（Service Workers, Native APIS, JS famework）以及提升的web应用质量标准。
如果你想了解更多关于PWA，请访问这个很棒的Google developer page。
看一下下面的PWA！看起来很像原生的app，是不是？
推特渐进式web应用
从开发者的角度来看，PWA相对于原生应用具有巨大的优点。它基本上就是一个网站，因此：
  你可以选择任何你喜欢的框架来进行开发；
  一段代码搞定一切：它是跨平台的以及跨设备的（代码是通过用户的浏览器执行的）；
  很容易获得：不需要通过应用商店来下载。
  然而，在2017年早期，PWA仍然面临一些限制条件：
  Safari不支持一些基本的PWA特性，比如 Service workers，但是苹果公司似乎已经准备开始着手了；
  一些原生的函数依然没有得到支持：对于更多信息，浏览这个页面What web can do。</description>
    </item>
    
    <item>
      <title>service worker介绍</title>
      <link>https://madneal.com/post/service-worker%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 02 May 2017 12:21:13 +0000</pubDate>
      
      <guid>https://madneal.com/post/service-worker%E4%BB%8B%E7%BB%8D/</guid>
      <description>原文：Service workers explained
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 那么它是什么？ Service worker正是被开发用于解决web平台上经常出现的问题和疑虑，包括：
 无法解释（Extensible Web Manifesto 中）的HTTP缓存以及高级HTTP交互比如HTML5 AppCache。 难以自然地构建一个离线优先地web应用。 缺乏可以利用很多提出功能的上下文执行。  我们也注意到了声明解决方案(Google Gears, Dojo Offline以及HTML5 AppCache都没能实现他们的承诺。每个连续的仅有声明的方法都以相同的方式失败了，所以service worker采取了一个不同的设计方法：一个可以用开发者牢牢把控的重要系统：
Service worker就好像它的内部有一个有一个shared worker ：
 在它自己的全局脚本上下文中运行（通常是在它自己的线程中） 不会和特定的页面绑定 不能够访问DOM  不像shared worker，它：
 即使没有页面也能够运行 如果不使用的话可以终止，还可以再次运行当需要的时候（比如，他不是事件驱动的） 拥有一个定义的升级模式 只允许HTTPS（更多的是在这一点上）  我们可以利用service workers：
 利用网络拦截可以让让网站更快以及/或者支持离线使用 作为其它&amp;rsquo;background&amp;rsquo;功能的基础比如消息推送以及后台同步  开始 首先你需要注册一个service worker:</description>
    </item>
    
    <item>
      <title>service worker之cache实践--sw-precache</title>
      <link>https://madneal.com/post/service-worker%E4%B9%8Bcache%E5%AE%9E%E8%B7%B5--sw-precache/</link>
      <pubDate>Sat, 22 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/service-worker%E4%B9%8Bcache%E5%AE%9E%E8%B7%B5--sw-precache/</guid>
      <description>Progressive web application是谷歌推出的一种渐进式应用，我觉得其实PWA是一种非常具有发展前景的技术。首先，PWA是由谷歌推出的，而且跨平台,PWA可以给你类似于原生APP的体验，通过service worker，你可以将资源缓存到本地。但是，PWA再国内一直都是不温不火，主要有好几个原因：一是因为国内的浏览器环境比较复杂，而PWA一般只是能够在chrome浏览器得到较好的支持。虽然chrome在桌面端占据了很大比例，但是在移动端还是一般般，普通的用户不一定会去安装Chrome。二是safari浏览器对于PWA的支持不是很完美，service worker目前还是没有得到支持的。
但是我是觉得PWA还是很好的，值得开发者们进一步探索。有一点偏题了，今天要讨论的其实是PWA里面service worker资源的缓存问题。主要问题的背景是这样的，我有一个上海地铁线路图的PWA，可以支持离线使用，有兴趣的同学可以尝试看看。我遇到一个问题，就是每次我更新之后代码之后，加入我的PWA被添加到主屏之后，这个APP的代码就没有更新，必须删除后重新重浏览器中添加到主屏。一开始我以为是PWA的问题，后来竟别人提醒，桌面上的APP其实也就是网站的链接。我这才恍然大悟，问题是因为我的servicer worker里面的缓存策略有问题。因为我的APP通过service worker来缓存资源，包括js,css以及图片文件，所以始终是从缓存中加载资源，所以我远程代码更新后，这个APP的代码却没有得到更新。OK，拿代码说话，我一开始的代码是：
var cacheName = &amp;#39;subway&amp;#39;; var filesToCache = [ 	&amp;#39;/&amp;#39;, 	&amp;#39;index.html&amp;#39;, 	&amp;#39;image/transfer.png&amp;#39;, 	&amp;#39;dist/alloy_finger.js&amp;#39;, 	&amp;#39;app.css&amp;#39; ];  self.addEventListener(&amp;#39;install&amp;#39;, function(e) { 	console.log(&amp;#39;service worker install&amp;#39;); 	e.waitUntil(caches.open(cacheName).then(function(cache) { 	console.log(&amp;#39;serviceworker caching app shell&amp;#39;); 	return cache.addAll(filesToCache); 	})); }); 可以看出我们在 install 事件后通过在 cache 里面加载文件，所以我们必须选择一种合适的策略能够让我们的APP在代码更新之后去请求新的代码呢？
Google其实在PWA推出的过程中也给出了很多有用的技术。比如sw-precache以及sw-toolbox，以及最近正在发展过程中的sw-helper。这里，我主要使用的是sw-precache来更新我的service worker策略。
sw-precache也是NODE中的一个模块，可以通过npm install sw-precache来进行安装。sw-precache可以配合多个工具使用，这里我主要介绍一下如何配合gulp来使用。我们通过利用sw-precache来帮助我们生成sw-precache。饿了么的huangxuan在medium写了一篇文章来渗入地介绍sw-precache，这篇文章写的不错，但是却是在墙外，主要是介绍sw-precache的工作方式。我就谈一下我对sw-precache的理解把，以一个gulpfile的一段代码为例：
gulp.task(&amp;#39;generate-sw&amp;#39;, function(callback) { 	var path = require(&amp;#39;path&amp;#39;); 	var swPrecache = require(&amp;#39;sw-precache&amp;#39;);  	swPrecache.</description>
    </item>
    
    <item>
      <title>Twitter Lite以及大规模的高性能React渐进式网络应用</title>
      <link>https://madneal.com/post/twitter-lite%E4%BB%A5%E5%8F%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BDreact%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 16 Apr 2017 08:27:46 +0000</pubDate>
      
      <guid>https://madneal.com/post/twitter-lite%E4%BB%A5%E5%8F%8A%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BDreact%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/</guid>
      <description>Twitter Lite以及大规模的高性能React渐进式网络应用  原文：Twitter Lite and High Performance React Progressive Web Apps at Scale
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
  让我们一起来了解世界最大的React.js PWA, Twitter Lite之中常见的和不太常见的性能瓶颈。
 创建一个快速的web应用包含很多方面，包括：时间花费在什么地方，理解其发生的原因并且应用潜在的解决方案。不幸的是，从来就没有一个快速的修复方法。性能是一个持续的问题，涉及到需要对需要提高的内容的持续观察和检测。在Twitter Lite中，我们在很多方面进行了一些小的提升：从初始加载时间搭配React组件的渲染（以及避免再次渲染）到图像的加载等等。大多数的变化往往是非常小的，当所有的变化叠加在一起让我们开发出了最大的以及最快的渐进式web应用。
在继续阅读之前： 如果你才开始观测并且提升你的web应用，我强烈推荐你学习如何阅读帧图，如果你还不知道如何去做的话。
下面的每个章节包括例子的 Chrome里面的开发者工具timeline记录的截图。为了让结果更清晰，我强调每一对例子坏的（左图）和好的（右图）进行对比（译者注：因为markdown图片显示的问题，因此原文的左右图在本文中是上图和下图）。
对于timeline和帧图特别的一点：因为我们针对的是很多种的手机设备，我们一般都会在一个模拟的环境中记录这些数据：比5x要慢的CPU以及3G的网络连接。这个不仅更现实，而且还会让问题更容易发现。
经过很多讨论，我们终于通过路由将公共区域分解成独立的块（例子如下）。当我们收件箱收到代码审查的通知的那一天终于来了：
const plugins = [  // 提取vendor和webpack模块的manifest  new webpack.optimiza.CommonChunkPlugin({  names: [ &amp;#39;vendor&amp;#39;, &amp;#39;manifest&amp;#39;],  minChunks: Infinity  }),  // 从所有的块中提取公共模块（不需要&amp;#39;name&amp;#39;属性）  mew webpack.</description>
    </item>
    
    <item>
      <title>第一个progressive web application，发车！</title>
      <link>https://madneal.com/post/%E7%AC%AC%E4%B8%80%E4%B8%AAprogressive-web-application%E5%8F%91%E8%BD%A6/</link>
      <pubDate>Sun, 19 Mar 2017 14:50:10 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E7%AC%AC%E4%B8%80%E4%B8%AAprogressive-web-application%E5%8F%91%E8%BD%A6/</guid>
      <description>progressive web application是谷歌推出的一种渐进式web应用，通过利用service-worker等来达到类似于原生应用，而且在chrome浏览器还可以添加到主页，完全就和一个app无异。老实说我觉得pwa是一个很好的发展方向，虽然小程序搞了一段时间不温不火，但是pwa的限制更少，再说还有谷歌支持，只不过现在部分浏览器可能支持的不是很好。 国内饿了么前段时间做了一个pwa，我觉得就挺好的 https://h5.ele.me/msite/ 。 我觉得和native app使用已经比较接近了，而且还无需安装。 扯得有点多，今天主要是讲下自己怎么做一个pwa。当然了，我也是新手，我的pwa也是基于谷歌的pwa的sample做了一些改进。谷歌现在很多开发者文档都做了翻译，sample主要是一个天气应用，里面具体的实现逻辑我就不讲了，我讲以下如何部署这个pwa。 在谷歌的sample里面是推荐使用firebase来部署你的pwa，但是由于国内的高墙，在firebase init的时候总是authentication error，stackoverflow上面说是代理的原因，但是不上代理又没办法使用firebase，所以这是一个死循环。但是！！我们有github page，github page是一个很好的展示静态页面的方面，以前只能支持渲染gh分支里面的内容，现在github对于github page功能做了完善，详细可以看下这篇文章http://blog.csdn.net/neal1991/article/details/53535914 。 下面跟我来： 1.进入https://github.com/neal1991/pwa 可以fork或者clone这个项目，我已经将里面的一些东西，改掉了，可以直接运行。 2.进入settings里面设置 现在你进入https://yourusername.github.io/your-reporistry-name/就可以发车了，是不是很快。 接着我还想讲一讲我这个项目做的一些改进的地方，因为这个weather pwa使用的是yahoo的一个api，通过利用woeid可以去查询各个城市的天气以及相关信息。但是网上却没有中国各个城市的数字代码，注意是WEPID代码，我后来发觉http://www.imeihua.net/tool/weathercode.aspx 这个网站是可以查询wepid的，本来想写一个爬虫爬取的，但是这个网站似乎做了什么限制，我使用curl模拟下请求，限制访问了，这个网站使用.NET实现的，.NET的web请求里面总是包含了一些奇怪的属性。后来我又发现一个国外的网站，很方便，直接get请求就能获取http://woeid.rosselliot.co.nz/lookup ，于是我就写了一个爬虫去爬取，源代码在https://github.com/neal1991/woeid-parser 核心代码
var request = require(&amp;#39;superagent&amp;#39;); var fs = require(&amp;#39;fs&amp;#39;); var cityConfig = [&amp;#39;wuhu&amp;#39;, &amp;#39;shanghai&amp;#39;, &amp;#39;beijing&amp;#39;, &amp;#39;hangzhou&amp;#39;, &amp;#39;nanjing&amp;#39;, &amp;#39;wuxi&amp;#39;, &amp;#39;xiamen&amp;#39;, &amp;#39;longyan&amp;#39;]; var cheerio = require(&amp;#39;cheerio&amp;#39;); var url = &amp;#39;http://woeid.rosselliot.co.nz/lookup/&amp;#39;; var attrNames = [&amp;#39;city&amp;#39;, &amp;#39;province&amp;#39;, &amp;#39;country&amp;#39;, &amp;#39;woeid&amp;#39;]; var result = [];  cityConfig.forEach(function(city) { 	request.get(url + city) 	.</description>
    </item>
    
    <item>
      <title>第一个chrome extension</title>
      <link>https://madneal.com/post/%E7%AC%AC%E4%B8%80%E4%B8%AAchrome-extension/</link>
      <pubDate>Sat, 04 Mar 2017 13:47:34 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E7%AC%AC%E4%B8%80%E4%B8%AAchrome-extension/</guid>
      <description>如今，chrome浏览器的使用如越来越流行，chrome extension往往能提供更多很丰富的功能。以前一直想了解这方面的东西，可是又担心很复杂。前段时间，在斗鱼看一个直播，想刷弹幕，但是每次自己输入有很麻烦，所以写个小脚本就可以了，后来想以下也可以使用chrome extension来实现。关于chrome extension,google就给出了相关的文档，另外国内360也翻译了这篇文档。当然我所做的东西还是很基础的，在此，也是就是说一下自己第一次尝试的经验。 其实，chrome extension似乎和现在很火的pwa有一点类似，对于chrome extension来说，有个文件是必不可少的，即manifest.json，这对于extension是非常重要的。这个文件主要是项目的某些描述，以及一些文件的引入。以我的文件为例：
{ &amp;#34;manifest_version&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;弹幕增强&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;This extension provides you a good experience of sending danmu at douyu&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;browser_action&amp;#34;: { &amp;#34;default_icon&amp;#34;: &amp;#34;icon.png&amp;#34;, &amp;#34;default_popup&amp;#34;: &amp;#34;popup.html&amp;#34; }, &amp;#34;content_scripts&amp;#34; : [{ &amp;#34;matches&amp;#34;: [ &amp;#34;http://*/*&amp;#34;, &amp;#34;https://*/*&amp;#34; ], &amp;#34;js&amp;#34; : [&amp;#34;app.js&amp;#34;], &amp;#34;run_at&amp;#34;: &amp;#34;document_end&amp;#34; }] } manifes_version好像是必须定义为2，这个好像是强制要求。提及一点的就是你可以使用开发者模式从而调试你的extension。你可以在tab右键打开更多工具，然后找到拓展程序打开，然后你可以通过加载已解压的拓展程序，只要选择你extension的文件夹就可以了，并且在右上角勾选上开发者模式。 接着主要讲一下“brower_action&amp;quot;里面定义的是extension的相关内容，&amp;ldquo;default_icon&amp;quot;即是插件的图标，&amp;ldquo;default_popup&amp;quot;就是弹出的页面，chrome extension规定html文件和js文件必须是分开来的。extension和当前打开的页面之间的环境是相互隔离的，是不可以直接通信的。&amp;ldquo;content_script&amp;quot;是定义插入到当前打开页面的相关js文件，“matches”可以让脚本再匹配到规定的正则才会执行，“js&amp;quot;则是插入到页面的js文件，你还可以插入css文件。需要注意的是，&amp;ldquo;content_script&amp;quot;虽然能够操纵当前页面的dom，但是他和当前页面的js环境是相互隔离的，不能够互相交互，当然也有相应的其他方法。 我的extension只是用到了”content_script&amp;rdquo;:
var times = 1000; for (var i = 0; i &amp;lt; times; i ++) { (function(i) { setTimeout(function() { console.</description>
    </item>
    
    <item>
      <title>Ext.js性能优化漫谈</title>
      <link>https://madneal.com/post/ext.js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%BC%AB%E8%B0%88/</link>
      <pubDate>Wed, 22 Feb 2017 21:40:16 +0000</pubDate>
      
      <guid>https://madneal.com/post/ext.js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%BC%AB%E8%B0%88/</guid>
      <description>Ext.js是一个用于建立企业级应用的纯JS框架。毫无疑问，它为我们提供了大量的组件，比如container,panel,field,grid，这些组件使用起来很方便，不需要去写js和html，但是ext.js的性能却存在很大的问题。比如，我在公司负责的页面，在本地的加载时间居然需要十几秒，当然这可能和后台服务有关，但是前台的渲染和执行也耗费了大量的时间。下面就我个人感受和网上的一些信息对Ext.js的性能优化做一些总结：
尽量不要使用Panel Panel是一个功能比较强大的组件，但是上面却附加了很多的功能和属性，所以也带来了更多的负担，因此在不必要的情况下，尽量不要使用panel，而去使用基类container。
事件监听 页面的render相关事件监听是比较花时间的，在不必要的情况下，尽量不要使用。还有在监听store的load时间的时候，应该监听一次：
listeners: { load: onFirstLoadData, single: true } 在页面渲染之后，尽量不要再去修改页面，从而避免页面reflow或者repaint。
避免组件封装 我们的项目代码往往总是container里面封装container，或者组件里面包裹了组件，其实有很多封装往往是不必要的。因此，减少不必要的组件封装，也可以简化页面DOM结构。
减少border布局 不需要一下再加载所有的元素
批量处理 如果需要处理大量数据，最好一次性修改，避免多次修改，从而提升性能。</description>
    </item>
    
    <item>
      <title>latex中large的作用域问题</title>
      <link>https://madneal.com/post/latex%E4%B8%ADlarge%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 06 Jan 2017 22:09:53 +0000</pubDate>
      
      <guid>https://madneal.com/post/latex%E4%B8%ADlarge%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid>
      <description>在毕业论文的写作过程中，遇到了一个\large 作用域的问题。假设下面有三种写法：
I am cool \large{you are right}, yeah, yeah, yeah I am cool {\large you are right}, yeah, yeah, yeah I am cool \begin{large} you are right \end{large}, yeah, yeah, yeah 我们希望的结果是you are right，这三个单词可以放大，而其他的文字仍然是正常大小，那么以后三个哪些是正确的呢？ 下面且看这三个命令的分别显示结果： 很明显可以看的出来，第二个和第三个是正确的，而第一个不是正确的。第一个后面的文字都受到了前面\large 的影响，也变成了放大的字体。这就是\large的作用域问题，第一条命令并没有限制好作用域。可以看的出来，应该要把命令放在花括号中。第三种写法也是可以工作的，像一般的环境都是有这种写法的，但是这种写法比较麻烦，不是特别推荐。</description>
    </item>
    
    <item>
      <title>Latex--入门系列三</title>
      <link>https://madneal.com/post/latex--%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%89/</link>
      <pubDate>Mon, 12 Dec 2016 15:48:08 +0000</pubDate>
      
      <guid>https://madneal.com/post/latex--%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%89/</guid>
      <description>Latex 专业的参考 tex对于论文写作或者其他的一些需要排版的写作来说，还是非常有意义的。我在网上看到这个对于Latex的入门介绍还是比较全面的，Arbitrary reference .所以将会翻译出来，供初学者学习。
TeX语法 TeX语法，编辑 你可能已经注意到，(La)TeX文档是蠢笨的基本上不包含什么具有特殊意义的符号，经常是依赖环境的并且很容易就可以看得出来。下面有一段LaTeX的代码，你也不用担心你还读不懂它，因为它可能包含不少的特别的符号：
I am text. Yes.  %comment: a semi-complex table with math in it: \begin{tabular}{|l|r|}  \hline  $a_1~~~b$ &amp;amp; $\sqrt[3]{a_1^2}$ \\ \end{tabular} 最终产生的表格的排版是这个样子的特殊符号的总结   **{和}**是作为一些命令参数来定义一些小块，比如临时的粗黑体在{\bf bold}
  **$**是用来开始和结束数学模式的，比如一些公式啊，数字之类的。你可以在你文本的任何地方插入$a+b=c$，输入$$a+b=c$$，那么你的公式就会在段与段之间以块的形式展现。
  **%**是用来注释的，这个是单行注释。如果你要注释大段的代码的时候，为了避免插入过多的百分号，你可以把这些字符放在\iffalse和\fi里面。
  **_和^**分别作为下标和上标。你也可以同时使用上标和下标，比如：  **~**是一个硬空格，它对于排版是有影响的，它是具有大小的，并且不可分连的空格，就像&amp;amp;nbsp一样的。它很有用比如：A.~Smith以及在引用的图表的时候Figure~\ref{dataflow},这确保了作者姓名或者图片和数字之间不会在行与行之间分隔。（也可以使用其他的办法来解决这个问题，比如mbox，不会强制使用特殊的空格大小）
  实际上，\ 经常和~拿起来一起来使用。尽管这两者之间还是有区别的：\ 是字间的空格，经常用来告诉LaTeX这不是句子的末尾，一般用于缩写或者标题。(Dr.\ Jones)
  **&amp;amp;**适用于在数组以及表格中定义列的。
  ****用于开始一个命令。有一些可能是比较特殊的(\\用于换行，\&amp;gt;用于tab缩进)，一般化的话应该是这样的\commandname。当然这可能会有看起来不太相同的使用方法：
  一次效果函数，比如使用\ss来获得一个德国字母。
  状态改变，比如粗体，强调，比如text-{\em a-tron}会产生。（花括号是来限制作用的范围的）
  使用命令取得相应的值，一般是使用{}或者[]。比如：
 \textsc{SmallCaps}产生 \caption{Description用于标题说明，一般用于图表。 口音和发声符号，比如\&#39;{e} \v{o}来产生    使用\begin和end是定义环境，从而和其他内容区分处理，比如：</description>
    </item>
    
    <item>
      <title>只要三步，你就可以在github上发布网站了</title>
      <link>https://madneal.com/post/%E5%8F%AA%E8%A6%81%E4%B8%89%E6%AD%A5%E4%BD%A0%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8github%E4%B8%8A%E5%8F%91%E5%B8%83%E7%BD%91%E7%AB%99%E4%BA%86/</link>
      <pubDate>Fri, 09 Dec 2016 10:41:39 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%8F%AA%E8%A6%81%E4%B8%89%E6%AD%A5%E4%BD%A0%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8github%E4%B8%8A%E5%8F%91%E5%B8%83%E7%BD%91%E7%AB%99%E4%BA%86/</guid>
      <description>今天，看到github推送了一个新的消息，Publishing with GitHub Pages, now as easy as 1, 2, 3。总结起来就是在github将你的文档或者发布网页将会变得十分简单。 三步：
 创建仓库 提交markdown文件 激活Github pages  现在github对于markdown文件真的支持的特别好，比csdn的markdown好多了。老实说，如果不是github在国内的访问速度感人，我早就把我的博客迁移到github上面去了。csdn的博客简直丑到不能忍了。 反正github的这次更新主要是针对GitHub Pages,这样markodown可以方便快捷的渲染成页面，而且还不会影响你现有的项目或者网站。而且还会给你进行一些默认的配置，对于新手来说，的确是非常友好的。当然了，实在不想用的话，还可以在设置里面禁用掉。更多详细情况，可以去GitHub上面去了解，试试看啊！！！</description>
    </item>
    
    <item>
      <title>Latex--入门系列二</title>
      <link>https://madneal.com/post/latex--%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%BA%8C/</link>
      <pubDate>Tue, 06 Dec 2016 20:24:10 +0000</pubDate>
      
      <guid>https://madneal.com/post/latex--%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%BA%8C/</guid>
      <description>Latex 专业的参考
tex对于论文写作或者其他的一些需要拍版的写作来说，还是非常有意义的。我在网上看到这个对于Latex的入门介绍还是比较全面的，Arbitrary reference .所以将会翻译出来，供初学者学习 基本的使用
基本的使用 TeX会产生什么 最基本的来说，你会生成一个.tex文件，即你的文档，即youfile.tex。
运行latex you file.tex可以让TeX工作并且生成your file.dvi，这是当下的输出。dvi是一个独立的排版语言。
因为dvi不能够存储图像， 所以它经常被用来作为媒介步骤来产生文档。
dvi也可以被转化成pdf文件，所以pdf文件经常是可以立即生成的，不要dvi文件作为媒介可以直接调用pdflatex yourfile.tex。
输出文件: LaTeX运行一次会产生很多文件，其中很多文件产生的原因是因为LaTeX是单流的;很多文件指示文档编译的信息文件，它们也能用于下次运行，当你编译文档的时候你还可以引用它们。比如，图的引用，章节的引用，以及其他文献的引用。鉴于此，它产生的数据是有特定用途的。(.aux文件是引用的，toc是给章头用的等等)，这些数据下次运行还可以继续使用。
注意这可能是你经常需要运行LaTeX两次来确保引用正常工作从而来更新它们。在一些特别变态的情况下，你甚至要运行更多次。你可以忽略掉这些额外的文件，你可以在生成文档后删除这些文件。
如果你用的是unix的系统，我建议你可以看看rubber。它的目的是为了在必要的时候重新编译文档。它不是特别简单的，但是能给你带来很多便利。
一个.log文件也会产生，它是tex文件编译产生的一些相关信息。
注意一点，一旦这个文件生成了，你无需担心保存除了原始数据(.text, .bib)其它的任何数据。log,aux, toc文件可能在运行之后看起来比较混乱，你也可以删掉它们。
其他可能输出的格式 除了在unix系统用于xdvi以及打印，dvi格式并不是很有用。上文曾经提到过，通过dvips软件可以将dvi文件转化为PostScript。你甚至可以先转成PS,然后再转成pdf文件，或者直接转成pdf文件。但是这些间接的步骤可能只是引发新的问题，在pdf方面经常不会怎么使用。更重要的是，这还会存在一个字体渲染的问题。对于pdf，我建议你使用pdflatex或者类似的工具从而避免字体的一系列问题。你必须将所有的.ps/.eps文件转化为pdf，但这不是很困难的事。你可以在图片章节找到更多的细节。</description>
    </item>
    
    <item>
      <title>Latex--入门系列一</title>
      <link>https://madneal.com/post/latex--%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/</link>
      <pubDate>Sat, 03 Dec 2016 22:54:13 +0000</pubDate>
      
      <guid>https://madneal.com/post/latex--%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B8%80/</guid>
      <description>Latex 专业的参考 tex对于论文写作或者其他的一些需要排版的写作来说，还是非常有意义的。我在网上看到这个对于Latex的入门介绍还是比较全面的，Arbitrary reference .所以将会翻译出来，供初学者学习。
TeX, LaTeX以及他们的用法 Tex:排版 Tex是Donald Knuth发明的一种排版语言。排版意味着从结构性的文本到审美的一个标准。在Tex里面，你可以控制文本的根本结构，而不是像word一样，是软件阴影的帮你管理文件的结构，而紧紧给你提供一个图形化的接口。在TeX/LaTeX里面，对于布局和样式都有着默认的合理的设置但是却是可以控制的。
Tex对于希望控制文本的人是非常友好的，一部分可能是因为它不会帮助你不能控制的东西。当然，简便也是一方面的－当TeX工作正常的时候，它运行的很好并且容易明白，但是当它有问题的时候，将会很麻烦，将会变得难以处理。（这点我深有体会）如果你稍微脱离了他的运作方式或者期望一个不太容易实现的功能，你可能需要头痛一下了。
还有其他的一些优点和缺点。TeX的公式拍版是它的强项之一。在以前它可能是唯一较为正式的选择，即使像现在可以使用MathML或者MathType的时候，TeX也被认为是使用起来还是比较便利的。假如你以前还没有接触过TeX，那么你可尝试穿件下面的公式：
在TeX仅仅使用t) = h(t) \otimes g(t) \equiv \int h(\nu) g(t-\nu) d\nu就可以搞定了。是不是看起来挺简单的。
它的缺点可能是将它用于不是它的目的功能的地方。比如，你希望得到一些奇特的表格，你可能会遇到问题并发现一些替代的解决方法，不过这意味着你需要用一些相应的包并且按照其相应的方式去实现了。
LATEX：文档编制 LaTeX是围绕TeX的一种文档编制的宏命令，它是一个比较高层次的能够利用它们产生一些比较常用的文档类型。它考虑到很多方面的内容，包括页眉和页尾，表格内容生成，自动两列的样式以及其他更多的细节。LaTeX现在被广泛得应用以及于它和TeX之间可以交换使用。TeX的实现方法大多数可以直接用在LaTeX的文档上面。当然你可以直接写TeX文件，但这不一定有什么用。如果希望看到更多的介绍，你可以参考这个。
书籍，报告以及PDF LaTeX对于写文章，报告以及书籍有些基本的设置。
它之所以受到喜爱的原因可能是对于大型的文档不容易搞混样式，于其它的一些工具截然不同，比如微软的word，随着文档长度的增长，它的处理复杂度也在逐渐增长，如果你曾经参与过大型的共同合作的文档项目，那么你将深有体会。
近些年以来，pafTeX编译器变得流行起来，因为它可以直接编译pdf文件（不需要dvi以及ps文件作为媒介），使用pdflatex 而不是latex，你可使用一些针对pdf的特点。
包 在TeX和LaTeX里面有各种各样的包，你可以用一些比较怪异的符号，制作一些表格包括输和公式，写活页曲谱，做CAD图，确保首字母大写以及单词拼写正确，或者仅仅只是用一些特别的地方。
版本变化以及实现 LaTeX最近通用经常写作是LaTeX2e。我认为你是在使用这个版本的。通常这也无关紧要，但是有一些老的命令我不会特别提及。
注意这个版本以及老版本的LaTeX209是最通用的语言以及实现规范，并不针对特别的包或者实现。
免费的TeX软件包括通常的&amp;rsquo;teTeX&amp;rsquo;也叫做&amp;rsquo;TeX Live&amp;rsquo;对于unix系列的系统，以及对于windows系统的&amp;rsquo;MikTex&amp;rsquo;。你也可以参考下面相关的软件。
你可以参考维基百科里面的TeX以及LaTeX。TUG是近些年的一些开发工作和相关文档。</description>
    </item>
    
    <item>
      <title>the sum of two fixed value</title>
      <link>https://madneal.com/post/the-sum-of-two-fixed-value/</link>
      <pubDate>Wed, 26 Oct 2016 17:34:25 +0000</pubDate>
      
      <guid>https://madneal.com/post/the-sum-of-two-fixed-value/</guid>
      <description>the sum of two fixed value
description
Input an array and an integer, fina a pair of number in the array so that the sum is equals to the inputed integer. If there are several pairs, you can output any pair. For example, if the input array is [1,2,4,5,7,11,15] and an integer 15, because 4 + 11 = 15, hence output 4 and 11.
analysis and solution
We try to figure out this problem step by step.</description>
    </item>
    
    <item>
      <title>你可能不知道谷歌浏览器开发工具的其他用处</title>
      <link>https://madneal.com/post/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E5%A4%84/</link>
      <pubDate>Mon, 03 Oct 2016 08:03:50 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E5%A4%84/</guid>
      <description>原文链接 原文链接似乎翻墙才可以访问   译者：neal github: https://github.com/neal1991  你可能不知道谷歌浏览器开发工具的其他用处
Chrome内嵌开发者工具。它具有丰富的功能特色，比如元素，网络以及安全。今天，我们将完全关注javascript的console.
当我才开始编程的时候，我只是将console用作纪录服务器的响应。但是后来经过一些教学的帮助，我开始发现console可以做的更多。
在这我们讲一些你可以用console做更多有用的事情。如果你是用chrome浏览这篇文章，你可以马上就试试效果。
 选择节点元素  如果你熟悉jquery的话，你应该知道$(&amp;rsquo;.class&amp;rsquo;)和$(&amp;rsquo;#id&amp;rsquo;)事多的么的重要。你可以根据id或者类名选择相应的元素。
同样你可以在console使用同样的方式来访问元素。$(&amp;rsquo;tagName&amp;rsquo;) $(&amp;rsquo;.class&amp;rsquo;) $(&amp;rsquo;#id&amp;rsquo;)和document.querySelector(&amp;rsquo;&amp;rsquo;)是等同的。这个将返回文档中第一个匹配这个选择器的元素。
你可以用$$(&amp;rsquo;tagName&amp;rsquo;)来访问，注意这边的两个美元符号可以访问所有符合这个选择器的元素。这些元素会组成一个数组
2.将你的浏览器转化成一个编辑器
你是否想过可以直接在浏览器中直接编辑？答案是肯定的，你可以将你的浏览器转化成一个文本编辑工具。你可以在dom元素中任意添加或者删除文本。
你不需要检测html中的元素。取而代之，你只要去console里面输入以下：
document.body.contentEditable = true
3.寻找dom中元素绑定的事件
当调试的时候你可能希望知道dom元素中绑定的事件。console工具能使你很轻松就找到这些事件。getEventListeners($(&amp;lsquo;selector&amp;rsquo;))将会返回一个数组包含所有事件的对象。你可以展开这个对象看到所有的事件：
如果希望找到某个特定事件的监听，你可以这么做：
getEventListeners($(&amp;lsquo;selector&amp;rsquo;)).eventName[0].listener
这将展示所有和这个事件相关的监听。比如：
getEventListeners($(&amp;rsquo;.firstName&amp;rsquo;)).click[0].listener
4.监听事件
如果你想监听特定元素绑定的事件的时候，你也可以在console里面这么做。你可以使用以下的这些命名：
 monitorEvents($(&amp;lsquo;selector&amp;rsquo;))将会监听符合这个选择器的元素的所有事件，并且将会显示这些事件当事件被触发的时候。 monitorEvents($(&amp;lsquo;selector&amp;rsquo;),&amp;rsquo;eventName&amp;rsquo;)将会监听符合这个选择器的特定事件。你可以将事件的名称作为一个参数传入到这个函数中。 monitorEvents($(&amp;lsquo;selector&amp;rsquo;),[&amp;rsquo;eventName1&amp;rsquo;,&amp;rsquo;eventName2&amp;rsquo;….])将会监听符合这个选择器的事件。 unmonitorEvents($(&amp;lsquo;selector&amp;rsquo;))这个会停止监听并且在console里面显示出所有的事件。  5.找到语句块执行的时间
console里面有一个很重要的函数叫做console.time(&amp;rsquo;labelTime&amp;rsquo;)能够启动一个计时器。另外又一个函数叫做console.timeEnd(&amp;rsquo;labelName&amp;rsquo;)能够结束相应的计时器。
比如我们想看到一个循环的执行时间，我们可以做如下处理：
console.time(&#39;myTime&#39;); //Starts the timer with label - myTime for(var i=0; i &amp;lt; 100000; i++){ 2+4+5; } console.timeEnd(&#39;mytime&#39;); //Ends the timer with Label - myTime //Output - myTime:12345.</description>
    </item>
    
    <item>
      <title>Bootstrap真的总是好的吗</title>
      <link>https://madneal.com/post/bootstrap%E7%9C%9F%E7%9A%84%E6%80%BB%E6%98%AF%E5%A5%BD%E7%9A%84%E5%90%97/</link>
      <pubDate>Mon, 15 Aug 2016 13:16:39 +0000</pubDate>
      
      <guid>https://madneal.com/post/bootstrap%E7%9C%9F%E7%9A%84%E6%80%BB%E6%98%AF%E5%A5%BD%E7%9A%84%E5%90%97/</guid>
      <description>原文地址：Bootstrap considered harmful
原文作者：Hidde de Vries
译文出自：neal
译者： Neal
个人主页：http://neal1991.pythonanywhere.com
这些年Bootstrap已经在前端项目中流行起来，它能够带来很多好处。然而，但是如果以你们的团队已经有了在职的前端开发人员，我觉得最好还是不要用Bootstrap，在某些地方，弊大于利。
Bootstrap的好处是什么 Bootstrap主要是栅格系统，但同时也带来了很多组件的样式表和脚本，包括表格，导航栏，进度条，页码，表单样式，模式和提示文本。在这篇文章，我所说的Bootstrap是包含它的所有功能的。
Bootstrap是一个很好的工具对于一个纸箱装饰他们的程序但是无须担心结果的样式问题的后端开发人员。如果因为某些原因，预算或者什么的，你的团队没有前端开发人员或者设计人员，Bootstrap是一个绝佳的弥补方法。
对于设计人员来说，Bootstrap也是有用处的：它可以快速地从设计软件切换到浏览器中，不需要过多担心前端的代码设计。
即使是对于那些基本只专注于数据但是很少关注UI和布局的前端开发人员来说，Bootstrap也是一个绝佳的工具。
什么时候你最好别用它 然而，如果你的团队已经拥有了前端开发人员，使用Bootstrap可能会潜在的浪费他们宝贵的时间，并让他们可能从解决实际问题上转移注意力。Bootstrap做的正是前端开发人员所擅长的事情，但是用的是一种很通用的方式。你的网站或者网络app是非常特别的，因此如果你使用一个通用的系统可能会不太合适。这意味着为了实现这种特殊性将会包含很多的异常发生。
当需要很多异常来复位Bootstrap Bootstrap曾经是被Twitter 的开发人员用于系统化他们网络app的样式。如果你的网站app和他们的样式不一样，这意味着你需要解除他们中的某些样式。
很多网站和Twitter的样式并不相同。因此，如果他们装载了Bootstrap的时候，他们可能需要卸载很多地方。
在某些网站上，我看到有9/10的Bootstrap样式已经被网站自己的样式所替代。坦白说，这很荒谬。
当它让简单的事情变得复杂 CSS是给网站添加一套简单的样式规则，这有时候可能会被重写。当你在你的网站使用Bootstrap的样式的时候，几乎所有的元素都是用一个复杂的样式规则。任何异常都会在它之上表现。问题是大多数网站他们的样式异常都被表现在Bootstrap之上。
Bootstrap的样式是非常复杂的：你可以利用12列的栅格系统和任何元素相结合起来，对于需要特别处理的列则要区别对待。很多网站十分简单：它们在小屏幕设备上没有列或者只有一到两列在大一点的屏幕上。
当它产生技术债务的时候 前端依赖Bootstrap的时间越长，就会牵扯到更多的东西，更多的规则需要设置来覆盖Bootstrap的某些规则。这或多或少地让技术代码背负技术债务，尤其前端代码的部署需要手动的更新。随着依赖的增多，Bootstrap将变得更加难以移除。
当它命名一些不是你app的规定 命名是一件很困难的事情，为团队的应用中的规定命名需要花费相当多的时间。使用&amp;rsquo;btn&amp;rsquo;之类的缩写并不能很好的给组件命名。
结论 Bootstrap可能对于产生网站的多个流程都起到了很大的帮助。但是它并不能让所有的事情都变得简单：相反，很多问题可以由前端开发人元专注于UI就能够更好地解决。</description>
    </item>
    
    <item>
      <title>sftp没有关闭session导致服务器sshd进程未关闭</title>
      <link>https://madneal.com/post/sftp%E6%B2%A1%E6%9C%89%E5%85%B3%E9%97%ADsession%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%99%A8sshd%E8%BF%9B%E7%A8%8B%E6%9C%AA%E5%85%B3%E9%97%AD/</link>
      <pubDate>Thu, 28 Jul 2016 17:09:59 +0000</pubDate>
      
      <guid>https://madneal.com/post/sftp%E6%B2%A1%E6%9C%89%E5%85%B3%E9%97%ADsession%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%99%A8sshd%E8%BF%9B%E7%A8%8B%E6%9C%AA%E5%85%B3%E9%97%AD/</guid>
      <description>项目中需要用Sftp上传下载文件，通过jsch中的sftp实现。代码上了服务器之后，发觉服务器多了很多进程没有被关闭。 连接sftp代码：
 protected boolean connectToServer() { try { JSch jsch = new JSch(); jsch.getSession(userName, hostname, port); Session sshSession = jsch.getSession(userName, hostname, port); logger.debug(&amp;#34;HostName:&amp;#34; + hostname + &amp;#34;|Port:&amp;#34; + port); logger.debug(&amp;#34;Session created&amp;#34;); sshSession.setPassword(password); Properties sshConfig = new Properties(); sshConfig.put(&amp;#34;StrictHostKeyChecking&amp;#34;, &amp;#34;no&amp;#34;); sshSession.setConfig(sshConfig); sshSession.setTimeout(TIMEOUT); //ms sshSession.connect(); sftp = (ChannelSftp) sshSession.openChannel(&amp;#34;sftp&amp;#34;); sftp.connect(); if (!sftp.isConnected()) { logger.error(&amp;#34;Failed to connect FTP server &amp;#34; + hostname); return false; } logger.debug(&amp;#34;Username:&amp;#34; + userName + &amp;#34;|Password:&amp;#34; + password); } catch (Exception ex) { logger.</description>
    </item>
    
    <item>
      <title>javascript中的对象字面量为啥这么酷</title>
      <link>https://madneal.com/post/javascript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%BA%E5%95%A5%E8%BF%99%E4%B9%88%E9%85%B7/</link>
      <pubDate>Tue, 26 Jul 2016 22:37:18 +0000</pubDate>
      
      <guid>https://madneal.com/post/javascript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%BA%E5%95%A5%E8%BF%99%E4%B9%88%E9%85%B7/</guid>
      <description>原文链接 : Why object literals in JavaScript are cool    原文作者 : Dmitri Pavlutin 译者 : neal1991 个人主页：http://neal1991.pythonanywhere.com  在ECMAScript 2015之前，Javascript中的对象字面量（也称为对象初始化器）是非常基础的。能够定义两种类型的属性：
  成对出现的名称以及相应的值{ name1: value1 }
  Getters { get name(){..} } 以及setters { set name(val){..} } 可以用于动态的属性值。
  遗憾的是，这个对象字面量可能会出现下面这样的情况：
var myObject = { myString: &amp;#39;value 1&amp;#39;, get myNumber() { return this._myNumber; }, set myNumber(value) { this._myNumber = Number(value); } }; myObject.myString; // =&amp;gt; &amp;#39;value 1&amp;#39; myObject.</description>
    </item>
    
    <item>
      <title>javascript中无法将string转化为json对象</title>
      <link>https://madneal.com/post/javascript%E4%B8%AD%E6%97%A0%E6%B3%95%E5%B0%86string%E8%BD%AC%E5%8C%96%E4%B8%BAjson%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 01 Jul 2016 16:34:48 +0000</pubDate>
      
      <guid>https://madneal.com/post/javascript%E4%B8%AD%E6%97%A0%E6%B3%95%E5%B0%86string%E8%BD%AC%E5%8C%96%E4%B8%BAjson%E5%AF%B9%E8%B1%A1/</guid>
      <description>在一次项目之中，我要对请求的相应做一些处理，得到的响应差不多是这中格式‘{total:1,result:[{&amp;ldquo;age&amp;rdquo;:1}]}&amp;rsquo;.可以看到我拿到的这个相应和JSON的格式是非常相似的，一开始我认为只要用JSON.parse进行转化，但是这始终会报错，无法进行转化。后来我用了个笨办法把前面的东西都去掉了拿到&amp;rsquo;[{&amp;ldquo;age&amp;rdquo;:1}]&amp;lsquo;进行转化。 后来我又找一找这个问题的原因，原来是我这个字符串中的key没有用双引号进行包裹，这并不是一个合法的JSON格式，它可以被人为是一个Javascript对象，但还不是一个合法的JSON，所以无法解析。JSON对象是由对象成员组成，而成员是由key-value键值组成。key值是一个字符串，字符串由unicode字符组成，用双引号包围，用反斜杠转义。可以是单个字符。 但是在现实应用中，很少有人知道JSON里的key需要双引号来包裹的，浏览器里面的属性都是没有双引号的，从而返回的结果无法解析。 知道问题的原因，就自然而然有相应的解决办法了。第一个办法就是本办法，手工加上双引号，也就是用正则表达式匹配；另外一个方法就是用eval直接执行, var obj = eval(&#39;(&#39;+str&#39;)&#39;) 不过你需要了解这个str里面到底有什么，这样才能防止一些恶意程序，避免带来安全问题。</description>
    </item>
    
    <item>
      <title>判断数组中元素多个属性是否重复</title>
      <link>https://madneal.com/post/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E9%87%8D%E5%A4%8D/</link>
      <pubDate>Fri, 01 Jul 2016 13:42:49 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E9%87%8D%E5%A4%8D/</guid>
      <description>js中判断数组元素的重复的方法有很多，可以用hash的方法或者排序之后再进行比较，但是我们这里说的case是这样的。假设我有一个数组[{name:&#39;neal&#39;,age:&#39;18&#39;},{name:&#39;neal&#39;,age:&#39;18&#39;},{name:&#39;jane&#39;,age:&#39;20&#39;}].假如数组中元素name和age这两个属性都相同我们则给这个元素加一个属性flag设置为true,否则设置为false.其实就是判断数组中元素中多个属性是否重复的问题了。 这种问题有一个比较死的方法就是拿两个循环来做处理
for (var i = 0,len = collection.length;i &amp;lt; len;i++) { var count = 0; for (var j = 0;j &amp;lt; len;j++) { if (collection[i].name === collection[j].name &amp;amp;&amp;amp; collection[i].age === collection[j].age) { count = count + 1; } } if (count &amp;gt; 1) { collection[i].flag = true; } else { collection[i].flag = false; } } return collection; }; 另外一种方法是使用underscore.js里面的方法了,不过由于underscore一次只能按照一个属性来groupBy，所以也需要多次嵌套
collection = _.groupBy(collection,&amp;#39;name&amp;#39;); for (var i in collection) { if (collection[i].</description>
    </item>
    
    <item>
      <title>moongoose对象无法新增删除属性</title>
      <link>https://madneal.com/post/moongoose%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%B3%95%E6%96%B0%E5%A2%9E%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Thu, 30 Jun 2016 21:40:33 +0000</pubDate>
      
      <guid>https://madneal.com/post/moongoose%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%B3%95%E6%96%B0%E5%A2%9E%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7/</guid>
      <description>昨天用nodes中的moongoose去查询一个结果遇到一个大坑，这个坑貌似用moongoose可能会遇到。背景是这样的，我在nodejs中去查询document，得到的可以看作是一个对象list。在这个结果集中，我要去寻找这个结果中的某个属性是否和其他的结果重复，并给它添加一个属性作为标志。举例子，我们获得的结果就像是[{name:&#39;neal&#39;,age:&#39;18&#39;},{name:&#39;neal&#39;,age:&#39;19&#39;}], 我希望把它变成[{name:&#39;neal&#39;,age:&#39;18&#39;,flag:true},{name:&#39;neal&#39;,age:&#39;19&#39;,flag:true}]。奇怪的事情发生了，我无法在这些对象中新增这个flag属性，这肿么可能。我尝试各种方法，但是还是存不进去。 后来去stack overflow一查，发觉居然是mongoose 的问题。。。。我压根没有想过是mongoose的问题。原来mongoose是ODM(object document mapper)，类似于操作关系型数据库的ORM,我们使用mongoose取到的数据结构依赖我们定义的schema结构，因为我们当初没有定义flag属性，所以最终返回的结果就没有这个属性了。 这个问题应该也有很多解决方法，这里就说一下我看到的一些方法。比如事先在schema增加这个属性，但是我觉得有时候就是不想定义这个属性才在后面加的；还有一个就是把返回的结果用toObject()方法进行转化，这样就可以像普通的对象一样增加属性了；其实本质的原因似乎是document .toObjet()里面需要一个vituals :true 的属性来实现，而默认的是false。可能我说的还不是特别透彻，可以去看一下官方的api http://mongoosejs.com/docs/api.html#document_Document-toObject</description>
    </item>
    
    <item>
      <title>nodejs回调大坑</title>
      <link>https://madneal.com/post/nodejs%E5%9B%9E%E8%B0%83%E5%A4%A7%E5%9D%91/</link>
      <pubDate>Wed, 27 Apr 2016 08:57:52 +0000</pubDate>
      
      <guid>https://madneal.com/post/nodejs%E5%9B%9E%E8%B0%83%E5%A4%A7%E5%9D%91/</guid>
      <description>最近看到nodejs，因为有一个处理里面有好几个异步操作，调入回调大坑，不禁觉得很恶心，真的很讨厌发明这种写法的人，简直反社会！！！遂转载一篇解坑的文章，原文地址：http://www.infoq.com/cn/articles/nodejs-callback-hell/。
 Node.js需要按顺序执行异步逻辑时一般采用后续传递风格，也就是将后续逻辑封装在回调函数中作为起始函数的参数，逐层嵌套。这种风格虽然可以提高CPU利用率，降低等待时间，但当后续逻辑步骤较多时会影响代码的可读性，结果代码的修改维护变得很困难。根据这种代码的样子，一般称其为&amp;quot;callback hell&amp;quot;或&amp;quot;pyramid of doom&amp;quot;，本文称之为回调大坑，嵌套越多，大坑越深。 坑的起源
后续传递风格
为什么会有坑？这要从后续传递风格（continuation-passing style&amp;ndash;CPS)说起。这种编程风格最开始是由Gerald Jay Sussman和Guy L. Steele, Jr. 在AI Memo 349上提出来的，那一年是1975年，Schema语言的第一次亮相。既然JavaScript的函数式编程设计原则主要源自Schema，这种风格自然也被带到了Javascript中。
这种风格的函数要有额外的参数：“后续逻辑体”，比如带一个参数的函数。CPS函数计算出结果值后并不是直接返回，而是调用那个后续逻辑函数，并把这个结果作为它的参数。从而实现计算结果在逻辑步骤之间的传递，以及逻辑的延续。也就是说如果要调用CPS函数，调用方函数要提供一个后续逻辑函数来接收CPS函数的“返回”值。 回调
在JavaScript中，这个“后续逻辑体”就是我们常说的回调(callback)。这种作为参数的函数之所以被称为回调，是因为它一般在主程序中定义，由主程序交给库函数，并由它在需要时回来调用。而将回调函数作为参数的，一般是一个会占用较长时间的异步函数，要交给另一个线程执行，以便不影响主程序的后续操作。如下图所示： 下面一个例子说明回调样例的恶心之处：
module.exports = function (param, cb) { asyncFun1(param, function (er, data) { if (er) return cb(er); asyncFun2(data,function (er,data) { if (er) return cb(er); asyncFun3(data, function (er, data) { if (er) return cb(er); cb(data); }) }) }) } 像function(er,data)这种回调函数签名很常见，几乎所有的Node.js核心库及第三方库中的CPS函数都接收这样的函数参数，它的第一个参数是错误，其余参数是CPS函数要传递的结果。比如Node.js中负责文件处理的fs模块，我们再看一个实际工作中可能会遇到的例子。要找出一个目录中最大的文件，处理步骤应该是：
 用fs.readdir获取目录中的文件列表； 循环遍历文件，获取文件的stat； 找出最大文件； 以最大文件的文件名为参数调用回调。 这些都是异步操作，但需要顺序执行，后续传递风格的代码应该是下面这样的：  var fs = require(&amp;#39;fs&amp;#39;) var path = require(&amp;#39;path&amp;#39;) module.</description>
    </item>
    
    <item>
      <title>利用tesseract-ocr进行验证码识别</title>
      <link>https://madneal.com/post/%E5%88%A9%E7%94%A8tesseract-ocr%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/</link>
      <pubDate>Tue, 26 Apr 2016 13:35:29 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%88%A9%E7%94%A8tesseract-ocr%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/</guid>
      <description>因为爬虫项目需要模拟登陆，可是有一个网站的登录需要输入验证码。其实这种登录有2种解决方案，一种是利用cookie，一种是识别图片。前者需要人工登录一次，而且有时效限制，故不太现实。后者可以，但是难点是如何识别出验证码。 这里面就要介绍一个神器了，tesseract-ocr这个项目是一个开源项目，可以用于图像识别。不过这个项目现在托管于google，所以不好下载，你可以搜一下，选择在国内下载。http://download.csdn.net/detail/neal1991/9502931 一开始我觉得我的验证码还挺好识别的，因为都是数字，如下图： 但是我发觉直接来识别还是来识别不了的，最好还是先要对图片进行一些预处理。说到图片的预处理就要说到另外一个软件了，就是imagemagick，这个是一个开源的图片处理项目，你可以去http://www.imagemagick.org/script/binary-releases.php根据你自己的系统进行相应得下载。这个软件还有相应的开发api，你可以自行的根据需要去下载。记住，这个软件安装后，配置环境变量后，需要重新启动的，一开始我还以为是什么问题呢。后来发现重新启动之后，就生效了，可以直接在cmd中使用。在这我就不说什么别的了。 首先是对图片进行预处理：
convert 1.jpg -colorspace gray -normalize -threshold 50% 1.tif 这里主要是先做一个灰度图转化，然后进行归一化处理，最后设立一个阈值，进行二值化，这样最后的结果还是比较清晰的，如下图：然后再用tesseract进行识别：
tesseract 1.tif result 是不是很简单？ 在github上面写了一个nodejs的程序可以直接执行，不过需要安装nodejs,链接如下： https://github.com/neal1991/code-recognition</description>
    </item>
    
    <item>
      <title>模拟.net post请求属性</title>
      <link>https://madneal.com/post/%E6%A8%A1%E6%8B%9F.net-post%E8%AF%B7%E6%B1%82%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 25 Apr 2016 17:02:51 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%A8%A1%E6%8B%9F.net-post%E8%AF%B7%E6%B1%82%E5%B1%9E%E6%80%A7/</guid>
      <description>这两天在做一个nodejs的爬虫项目，需要模拟post请求获得网站数据。遇到2个asp.net的网站，掉到坑里面，调试了好几天。总结一下过程。 一般我们模拟post请求的时候最重要的就是post请求里面的formdata就可以了。怎么看formdata呢，以谷歌浏览器为例，打开开发者工具，到network中，点击查询，然后找到你所请求的网页，点击，就能看到请求的各种详细信息了。 我们可以看到里面包含了各种各样的属性，但一般.net网站会多一些特殊的属性，比如上图里面的compressedviestate和eventvalidation属性。我查了一下这些属性貌似是.net机制自有的一些属性。compressedviewstate好像是反映webform的控件的状态信息，而eventvalidation好像是用于服务器端的验证。后来我发现一个规律，如果我在postdata不加这些属性，返回来的响应是一个空的页面，就是其他的部分都有，但是就是包含数据的div里面没有任何数据。但是如果你把这些属性的值填错，就会返回一些乱码的响应数据。后来就一直调试，也苦苦不知道原因。 后来，别人和我介绍了一个神器，curl，这个linux系统自带的，但是windows需要自己安装，不过下载的速度很慢。你用这个可以直接模拟post请求，这样就可以很方便的验证这个请求到底是不是有效的。你在network哪个请求的页面右键，copy as cURL,然后把这个命令拿去执行，这个其实就是一个curl命令。我把它放在linux终端执行能够获得正确的相应，但是放到windows下却不行，后来发现是因为windows里面命令行长度限制，而这个命令有一万多个字符。但是这表明如果使用正确的参数，是可以获得正确的响应的。 高潮来了，我准备在记事本删掉这些属性值的时候，突然发现__COMPRESSEDVIEWSTATE那个是2个下划线，我突然感觉就是这个原因，果然。。。。。。。 这个问题是在是太坑爹了，主要自己一开始写属性的时候也没注意，也没想到这一块，所以花了这么长时间来调试。绕来绕去，发现还不是那个问题。但是现在还有一个问题，我直接是把这些属性用一些固定值的，我并不知道这些值是不是一直有效的。本来我想先发送一个空的post请求然后获取这些属性的，然后填充进去再实现post请求，但是还是一些奇怪的问题，所以我也就没这么做了。 总的来说，写代码还是特别坑，小心入坑！！！！</description>
    </item>
    
    <item>
      <title>nodejs爬虫编码问题</title>
      <link>https://madneal.com/post/nodejs%E7%88%AC%E8%99%AB%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 16 Apr 2016 18:03:14 +0000</pubDate>
      
      <guid>https://madneal.com/post/nodejs%E7%88%AC%E8%99%AB%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <description>最近再做一个nodejs网站爬虫的项目，但是爬一些网站的数据出现了中文字符乱码的问题。查了一下，主要是因为不是所有的网站的编码格式都是utf-8,还有一些网站用的是gb2312或者gbk的编码格式。所以需要做一个处理来进行编码的解码。至于网站的编码怎么看，可以通过去检查中的network去看。 根据相应的编码格式，进行相应的设置。utf-8就不要说了，下面就以gbk为例，说一下解码的方式。
var request = require(&amp;#39;request&amp;#39;); var cheerio = request(&amp;#39;cheerio&amp;#39;); var iconv = require(&amp;#39;iconv-lite&amp;#39;); request ({ url : &amp;#39;http://www.taobao.com&amp;#39;, encodeing = null },function(err,res,body){ if (err) throw err; // decode the content of the website body = iconv.decode(body,&amp;#39;gbk&amp;#39;); var $ = cheerio.load(body); console.log($(&amp;#39;head title&amp;#39;).text()); }） 或者是使用一个gbk包，但我觉得还是上面的方式比较好。</description>
    </item>
    
    <item>
      <title>js的事件流理解</title>
      <link>https://madneal.com/post/js%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sat, 05 Mar 2016 17:19:32 +0000</pubDate>
      
      <guid>https://madneal.com/post/js%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%90%86%E8%A7%A3/</guid>
      <description>面试问到js的事件流，当时说的不是很清楚，现在觉得有必要把这个弄清楚。
事件捕获和事件冒泡 事件流描述的是从页面中接收事件的顺序,也可理解为事件在页面中传播的顺序。 事件流主要分为两种，即事件捕获和事件冒泡，这二者接受事件处理的顺序不同。假设下面的代码：
&amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;outer&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;inner&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; 这两个事件流分别的是IE公司和netspace公司提出来的，冒泡事件流支持的浏览器更多。 冒泡事件流中，事件的传递顺序是从子元素向父元素传递。假设我们给div绑定一个click事件。那么在冒泡事件流中，事件的传递顺序是：inner-&amp;gt;outer-&amp;gt;body。然而捕获事件流的顺序则截然想法：body-&amp;gt;outer-&amp;gt;innner。
DOM事件流 DOM2级事件规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。还是以上面的代码为例，单击inner则会按照下面的顺序触发事件：document-&amp;gt;html-&amp;gt;body-&amp;gt;outer-&amp;gt;ineer-&amp;gt;outer-&amp;gt;body-&amp;gt;html-&amp;gt;document。在DOM事件流中，实际的目标inner在捕获阶段不会接受到事件。这意味着在捕获阶段，事件到outer就停止了，下一个阶段是“处于目标”阶段，于是事件在inner 上发生，并在事件处理中呗看成是冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。
事件处理程序 响应某个时间的函数叫做事件处理程序。DOM0级的事件处理程序很简单,onclick就是常用的DOM0级事件处理函数，只会在冒泡阶段被处理。 而DOM2级事件定义了两个方法用于处理置顶和删除事件处理程序的操作addEventListener()和removeEventListener()，所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名，作为事件处理的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序，反之则是在事件冒泡阶段处理程序。DOM2级方法添加事件处理程序的好处是可以添加多个事件处理程序，会按照添加顺序被处理（无论是捕获还是冒泡）。 而IE不同的它有自己的方法attachEvent()和detachEvent,这两个接受相同的两个参数：事件处理程序名称和事件处理程序函数。
跨浏览器的事件处理程序 var EventUtil = { addHandler: function(element,type,handler) { if (element.addEventListener) { element.addEventListener(type,handler,false); } else if (element.attachEvent) { element.attachEvent(&amp;#39;on&amp;#39;+type,handler); } else { element[&amp;#39;on&amp;#39;+type] = handler; } }, removeHandler: function(element,type,handler) { if (element.removeEventListener) { element.removeEventListener(type,handler,false); } else(element.detachEvent) { element.detachEvent(&amp;#39;on&amp;#39; +type,handler); } else { element[&amp;#39;on&amp;#39;+type] = null; } } } </description>
    </item>
    
    <item>
      <title>百度前端实习生面试（连跪之旅）</title>
      <link>https://madneal.com/post/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E8%BF%9E%E8%B7%AA%E4%B9%8B%E6%97%85/</link>
      <pubDate>Fri, 04 Mar 2016 16:56:41 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E8%BF%9E%E8%B7%AA%E4%B9%8B%E6%97%85/</guid>
      <description>去百度面试基础架构部的前端开发实习生，感觉应该跪得很惨。百度上海研发中心挺偏的，离张江还挺远的，还要打车过去。到了百度那边门卫管的挺严的，还要面试官来接。后来，就一个程序员来接我，也就是我的面试官。后来就在他们三楼一个休息的地方开始面试。首先就是自我介绍了，然后就是blabla我一些经历项目而已了。他强调了了一下前端相关的项目经历，但是讲道理我是真心没有前端的项目经历，所以也说不上什么。唯一做的也就是我自己的个人主页，还基本上都是静态页面。然后开始正式面试，他首先问了我标签和标签有什么区别，然后我说了和的本质区别是他们的默认display 属性不同，然后他又问了有没有其他的不同，我并不知道。然后他接着问了常见的块级标签和行内标签有哪一些。接着他问了我清除浮动的知识，我只是临时记住了一些清楚浮动的方法，但是还是没有弄懂实际的原理，所以场面也是比较的尴尬。他问了怎么优化网页，说可以怎么做。我不禁一喜，把之前准备的东西背出来，刚说到第一条，减少 http请求，他就问我如何减少 http请求。尴尬，一下子gg，我也想不起来如何减少http请求。后来他看我说不上来就让我继续往下说，我又说了压缩，以及代码精简之类的。然后他又问了具体的，我说了一下，他好像也不是特别满意。我的简历，尼玛，我为什么要写个对于html5有充分的认识！！！我天天又懒得改，每个面试官都要问我这个问题。不过我事先也准备了，就把一些基础的特性说了一下。他说还有别的，然后提醒我缓存之类的，然后就说起来sessionStorage，localStroage之类的，并问了我和cache之间的区别之类的。这里面有个问题他炸了我一下，他说你确定localStorage在本地是不会删除的么，很明显是不会的。然后他问对于缓存请求有没有了解，很明显我并没有什么了解。他又问了我一些对于哪些开源的框架比较熟悉，那也就只有jQuery和bootstrap。他问我对于这些开源框架的更新清不清楚，很明显，宝宝不清楚啊！！！然后他问了一系列图标改变颜色如何实现，实现鼠标挪上去，就改变颜色。这个我说用hover改变css 属性，但他应该是质疑这样的做法吧。后来他又说道bootstrap其实有这样的实现，其实我好像也看到过，但是我也没关注过是如何实现的，真是悲剧。接着他问了js的问题。首先问了一下事件流，这个地方我说错了，事件流应该是补货，处理，冒泡。我把顺序说反了，反正事件流还问了详细的问题，但是我对这个并不是特别了解，所以说的也是不好的。后来出了一个js的题目，如何实现像trim一样去掉两端的空白，我用js写了一下，里面有很多问题，具体就是不说了。后来他提示说是用正则表达式，我说我只会python的，然后他说可以。但是宝宝也写不出来啊，然后他说那你就说下原理吧。然而我并不知道如何做，然后就罢了。 第二个面试官就长得更像程序员了，直接穿个拖鞋就过来了。他是直接让我写代码的，第一题如何实现三列布局，两边各100px，中间自动拓展，我说了用float或者css3的新属性。他直接让我写代码了，然后就写一写，估计也不太对。第二个，他说ie和chrome等绑定的事件的方法不同，如何写一个函数进行不同的处理。这一题我并不知道如何区分，所以也就没写。第三题，他说有没有做过移动端的开发，我说没有。然后我就老实说了，其实自己并没有接触太多的前端。然后她说也看了我简历没什么前端的经历之类的，然后就是说说，然后就没了。 总结一下，这次面试经历讲道理并不是特别困难的。前端的书我也是看了好几本，但其实并没有什么特别的意思，还是做项目成长的比较快。所以，赶紧实习，实际参与项目对于我来说实在是太重要了。</description>
    </item>
    
    <item>
      <title>前端面试题——系列一</title>
      <link>https://madneal.com/post/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97%E4%B8%80/</link>
      <pubDate>Tue, 01 Mar 2016 19:08:46 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97%E4%B8%80/</guid>
      <description>html语义话  img标签alt属性和title属性的区别
alt属性是图片在因浏览器兼容、加载失败活着地址出错等原因无法显示为浏览用户所做的代替语言，其性质为图片的代替；而title属性是表达该图片的一些额外信息，其性质为一种备注或注释，鼠标过去显示该文字。
 css布局  常见的布局有四种：表格布局，浮动布局，css框架，flexbox 两列布局，三列布局可以由浮动来实现 css3已经实现了多列布局，主要属性包括 column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width
div{ -webkit-column-count: 3; Chorome, Safari, Opera -moz-column-count :3; Firefox -column-count:3; }
 清除浮动的知识  在浮动元素后面增加标签 在浮动元后面增加一个清楚浮动层：
 ajax 基本实现步骤  1、创建XMLHttpRequest对象 2、使用XMLHttpRequest对象打开一个连接，制定连接方式&amp;lt;post/get&amp;gt; 和链接地址以及是否同步 3、设置请求的头部（请求的类型和请求的编码格式） 4、设置回调函数 5、发送请求 6、更新页面显示
XMLHttpRequest状态码： 0 uninitialized 初始化状态，XMLHttpRequest已经被创建或者重置 1 open open 方法已经调用，但是send 方法还没有调用，还没有发送请求 2 sent send方案已经发送，请求已经发送到服务器，但是还没有接受到请求 3 receiving 所有响应头已经接受到，响应体开始接受，但没有接受完成 4 loaded 请求已经完全接受
 取消a链接默认跳转行为  href属性设置为javascript:void(0)
 水平垂直居中  居中文告中的字句：text-align;center 对于div：margin: 0 auto</description>
    </item>
    
    <item>
      <title>演化计算会议</title>
      <link>https://madneal.com/post/%E6%BC%94%E5%8C%96%E8%AE%A1%E7%AE%97%E4%BC%9A%E8%AE%AE/</link>
      <pubDate>Fri, 08 Jan 2016 19:11:08 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%BC%94%E5%8C%96%E8%AE%A1%E7%AE%97%E4%BC%9A%E8%AE%AE/</guid>
      <description>作为一名演化计算会议的学生，要懂得这方面的会议啦，不过我最熟悉的只是CEC了，其他的会议还真没怎么见过。 【原创】演化计算&amp;amp;演化硬件相关会议评价(07.07.15) Copy to clipboard Posted by: dareios Posted on: 2007-07-13 00:27
欢迎大家提意见，补充^^
Revised Date(v4): 2007/10/03 (修改: ICES) Revised Date(v3): 2007/07/15 (追加:CEC, AUS-AI, ICCS) Revised Date(v2): 2007/06/05(追加:GECCO, ICONIP) Revised Date(v1): 2007/05/29
写这个段子纯粹是因为受了南大周志华教授写的AI Conferences那篇文章的影响,于是起了写一篇自己心目中的conferences tier list的念头. List中的会议评价主要根据我本人这几年接触到的会议论文集的质量,参加会议过程的感观,CiteSeer的那个Estimated impact of publication venues in Computer Science,会议的专业性-我本人偏重evolvable hardware,大部分的LNCS出版的会议和少量的其他重要相关会议将做探讨. grade A 的会议是演化硬件方向最权威的国际会议,其中发表的论文大多有一读的价值. B 的会议也是质量非常不错的会议, C 的会议, 我个人认为去发表论文还是不错的,但是通常不会在这个档次的会议proceeding中找参考论文.D 的会议,通常是一些发表论文数量超过500篇,或者永远在中国国内打转的＂国际＂会议.
 grade A:
ICES (A0): International Conference on Evolvable Systems: From Biology to Hareware. 基本上是从90年代evolvable hardware(EHW)的研究引起学术界的关注就开始举行的重要会议.EHW方面最重要的2个会议之一.首次举行是在1995年的瑞士(当时还不叫 ICES,96年才开始现在的名字),基本上当时的EHW开创性人物瑞士的Eduardo Sanchez,日本的Tetsuya Higuchi等人都参加了这次会议.</description>
    </item>
    
    <item>
      <title>数据结构线性表相关操作</title>
      <link>https://madneal.com/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 28 Dec 2015 15:50:34 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>数据结构线性表是数据结构最基础的一章内容，也是数据结构最基础的一段，包括线性表的定义，线性表的初始化，线性表的插入，删除，合并。下面贴上代码
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;malloc.h&amp;gt; #include&amp;lt;iostream&amp;gt; using namespace std; //线性表的定义 typedef int ElemType; typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; //线性表的初始化 int InitList_L(LinkList &amp;amp;L) { L = (LinkList)malloc(sizeof(LNode)); L-&amp;gt;next = NULL; return 1; } //线性表的插入 int ListInsert_L(LinkList &amp;amp;L,int i,ElemType e) { LinkList p; p = L; int j = 0; while(p&amp;amp;&amp;amp;j&amp;lt;i-1) { p=p-&amp;gt;next; ++j; } if(!p||j&amp;gt;i-1) return 0; LinkList s = (LinkList)malloc(sizeof(LNode)); s-&amp;gt;data = e; s-&amp;gt;next=p-&amp;gt;next; p-&amp;gt;next=s; return 1; } //清空线性表 void Delete_L(LinkList L) { LinkList p = L-&amp;gt;next; if(!</description>
    </item>
    
    <item>
      <title>installsheild2011打包程序internal build error 6213</title>
      <link>https://madneal.com/post/installsheild2011%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8Finternal-build-error-6213/</link>
      <pubDate>Sun, 20 Dec 2015 13:23:21 +0000</pubDate>
      
      <guid>https://madneal.com/post/installsheild2011%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8Finternal-build-error-6213/</guid>
      <description>今天打包一个安装程序，总是出现报错，internal build error -6213，然后搜遍都没有找到什么解决方案。看到一个帖子，说是因为installsheild里面的build的时候自动扫描.NET依赖库造成的原因，要把这个自动扫描功能给关掉，但是他说的在什么地方关说的不是很清楚，所以我一直找不到。 http://1978l.blog.163.com/blog/static/4494441620098704049756/原文帖子如下 后来找了半天，终于找到地方了。 如图1，图2所示，把components里面所有.NET scan at Build设置为none,这个可能是这个软件的bug把，我使用的是2011版本，免费的版本。 真心的，我实验室解决问题的能手，实验室这些妹子如果没有我，我都不知道她们该怎么活下去。</description>
    </item>
    
    <item>
      <title>常用的正则表达式</title>
      <link>https://madneal.com/post/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 15 Dec 2015 21:19:43 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式的用处很多，在很多地方都可以用得到，下面介绍一些常用的正则表达式 一、校验数字的表达式
数字：^[0-9]*$
n位的数字：^\d{n}$
至少n位的数字：^\d{n,}$
m-n位的数字：^\d{m,n}$
零和非零开头的数字：^(0|[1-9][0-9]*)$
非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$
正数、负数、和小数：^(-|+)?\d+(.\d+)?$
有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$
非零的负整数：^-[1-9][]0-9″$ 或 ^-[1-9]\d$
非负整数：^\d+$ 或 ^[1-9]\d*|0$
非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0$
非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d*.\d*|0.\d*[1-9]\d*))|0?.0+|0$
正浮点数：^[1-9]\d*.\d*|0.\d*[1-9]\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$
负浮点数：^-([1-9]\d*.\d*|0.\d*[1-9]\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$
浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0)$
二、校验字符的表达式
汉字：^[\u4e00-\u9fa5]{0,}$
英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
长度为3-20的所有字符：^.{3,20}$
由26个英文字母组成的字符串：^[A-Za-z]+$
由26个大写英文字母组成的字符串：^[A-Z]+$
由26个小写英文字母组成的字符串：^[a-z]+$
由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
可以输入含有^%&amp;amp;’,;=?$\”等字符：[^%&amp;amp;&amp;rsquo;,;=?$\x22]+
禁止输入含有~的字符：[^~\x22]+
三、特殊需求表达式
Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$
域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;amp;=]*)?$
手机号码：^(13[0－9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$
国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$</description>
    </item>
    
    <item>
      <title>latex如何给表格添加注释</title>
      <link>https://madneal.com/post/latex%E5%A6%82%E4%BD%95%E7%BB%99%E8%A1%A8%E6%A0%BC%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Thu, 10 Dec 2015 15:41:52 +0000</pubDate>
      
      <guid>https://madneal.com/post/latex%E5%A6%82%E4%BD%95%E7%BB%99%E8%A1%A8%E6%A0%BC%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A/</guid>
      <description>在latex中，想给表格添加注释，可以使用threeparttable这个包 代码如下：
\usepackage{threeparttable} \begin{table*} \begin{threeparttable} \centering \caption{Statistical results of the IGD values of the final populations obtained by RM-MEDA and RM-MEDA-II on the 10 test instances over 30 runs.} \label{TAB1} \begin{tabular}{l|cccc|cccc}\hline\hline instance&amp;amp;\multicolumn{4}{c}{RM-MEDA}&amp;amp;\multicolumn{4}{|c}{RM-MEDA-II}\\ &amp;amp;mean&amp;amp;std.&amp;amp;best&amp;amp;worst&amp;amp;mean&amp;amp;std.&amp;amp;best&amp;amp;worst\\\hline $F_{1}$	&amp;amp;$3.90e-03$	&amp;amp;$1.39e-04$	&amp;amp;$3.70e-03$	&amp;amp;$4.20e-03$	&amp;amp;$\textbf{3.60e-03}$	&amp;amp;$1.02e-04$	&amp;amp;$3.40e-03$	&amp;amp;$3.80e-03$\\\\ $F_{2}$	&amp;amp;$3.80e-03$	&amp;amp;$1.43e-04$	&amp;amp;$3.50e-03$	&amp;amp;$4.10e-03$	&amp;amp;$\textbf{3.70e-03}$	&amp;amp;$9.83e-05$	&amp;amp;$3.50e-03$	&amp;amp;$3.90e-03$\\\\ $F_{3}$	&amp;amp;$7.20e-03$	&amp;amp;$3.90e-03$	&amp;amp;$3.60e-03$	&amp;amp;$1.55e-02$	&amp;amp;$\textbf{6.70e-03}$	&amp;amp;$1.10e-03$	&amp;amp;$3.80e-03$	&amp;amp;$8.50e-03$\\\\ $F_{4}$	&amp;amp;$5.03e-02$	&amp;amp;$1.30e-03$	&amp;amp;$4.82e-02$	&amp;amp;$5.35e-02$	&amp;amp;$\textbf{5.08e-02}$	&amp;amp;$2.10e-03$	&amp;amp;$4.81e-02$	&amp;amp;$5.62e-02$\\\\ $F_{5}$	&amp;amp;$5.</description>
    </item>
    
    <item>
      <title>从后台看python--为什么说python是慢的</title>
      <link>https://madneal.com/post/%E4%BB%8E%E5%90%8E%E5%8F%B0%E7%9C%8Bpython--%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4python%E6%98%AF%E6%85%A2%E7%9A%84/</link>
      <pubDate>Tue, 08 Dec 2015 10:14:12 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BB%8E%E5%90%8E%E5%8F%B0%E7%9C%8Bpython--%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4python%E6%98%AF%E6%85%A2%E7%9A%84/</guid>
      <description>python越来越作为一种科学技术研究的语言越来越流行，可是我们经常听到一个问题，python是慢的。那么我们从后台分析一下，为什么python是慢的。 python是一种动态类型，解释型语言，它的值都是存储在分散的对象中，而不是紧密的缓存之中。
1.python是动态类型语言 这意味着编译器在程序执行之前并不知道变量定义的类型。C定义变量和Python定义变量的方式的区别： 对于C，编译器通过定义知道变量的类型；然而对于python中的变量，当你知道变量的类型的时候已经是程序执行的时候了。 我们分析一小段代码分别在python和C中执行的具体区别： 在C中，如果你写如下代码：
int a = 1; int b = 2; int c = a + b; 1.分配一个类型1给a 2.分配一个类型2给b 3.调用一个二进制加法&amp;lt;int,int&amp;gt;(a,b) 4.将结果分配给c
在python中，同样的
a = 1 b = 2 c = a + b 1.分配1给a
  设置一个对象，然后将它的类型设置为整数
  将它的值设为1 2.分配2给b
  设置一个对象，然后将它的类型设置为整数
  将它的值设为2 3.调用一个二进制加法(a,b)
  寻找一个类型在对象中
  a是一个整数，它的值是a
  寻找一个类型在对象中
  b是一个整数，它的值是b
  调用一个二进制加法
  返回结果，结果是一个整数 4.</description>
    </item>
    
    <item>
      <title>谈谈CS英文论文写作</title>
      <link>https://madneal.com/post/%E8%B0%88%E8%B0%88cs%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</link>
      <pubDate>Fri, 27 Nov 2015 12:39:32 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%B0%88%E8%B0%88cs%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</guid>
      <description>作为一个CS的研究生，发篇文章是你毕业的必要条件。现如今，学校对于文章的要求也越来越高，一般来说，还是国外的期刊或者会议更加受到认可，这样对于毕业也有好处。因此，以我自己的感受来说，论文的写作以及表达方式，合理地呈现你的实验结果，清楚的逻辑解释，显得尤为重要。让人看得懂的论文往往比一个拥有的好的想法的论文更能得到别人的认可，当然这也并不是推崇只是为了专注于论文的写作，毕竟想法才是一篇论文的灵魂。然而事实如此，做好论文的写作的重要性实在很大。 作为一个研究生，很显然并没有很多的论文的写作经验。所以，我们一般的做法就是模仿别人的论文写作。我们需要阅读大量别人的论文，这样其实也是对自己的语感的培养。当然，这里推荐你还是多读读外国人写的论文，因为他们的论文写作表达方式相对来说更为的地道。我觉得论文写作的词汇使用很讲究的，同一种意思可以有很多种表达方式。就比如说你的算法很好，你可以说：outperforms than other algorithm, has advantages over other algorithm, has impressive performances, has remarkable performances等等。我前段时间，看到有个单词就很好，circumvent，这个单词的意思是绕开。其实，我们算法的改进，很多时候并不是对这个问题的直接改进，而是绕开这个问题，从而避免这个问题，所以我就觉得这个单词用的很精妙。 其实现在的论文写作也和古代的八股文一样，有一样的套路。其实对于一个给定方向的论文，他们的套路其实基本都是一致的。老实说，对于所有的论文我们基本都有一个一致的框架结构。首先，一般在abstract里面，我们会简要的说一下我们的思想，这里要言简意赅，并且能够最大化吸引别人，突出你想发的优点。然后，在introduction里面，就是介绍相关背景知识的时候，像我们专业，一般都是介绍一些相关的算法，或者你提出的算法的基础，这些都是我们提出的算法基础。接着才是提出我们自己的算法的正确的时机。在正文里面，首先就是介绍你算法或者思想的基础，然后就是你的算法和思想了。记住，这个才是你论文的核心部分。你的论文大部分应该都是讲你自己的想法而不是别人的想法，否则也就是本末倒置了。计算机的论文，很多都是需要实验结果来佐证的。没有实验结果，你的所有想法都不具有说服力。同时，实验结果需要相应的详细的分析过程，对于实验结果你要分析的多一点，虽然觉得有时候觉得自己说的是废话，但也尽量多说一点，多换点角度表达。一般你可以从性能上去说，说我们算法的性能好；如果算法的性能差不多，那就可以从运行时间去说，可以说我们算法的运行速度快。当然，我觉得写别的方向的论文应该也是差不多的，从多个角度去表现你算法和想法的优点，这一点很有必要。另外一点，多用图和表格来表达你的实验结果，图优于表格，表格优于文字，文字最次。优秀的表达方式往往更容易吸引别人的目光，所以多学一下怎么画图。看一些TOP期刊的文章，他们是怎么画图的，这样装逼也会好一点。 其他的我也不知道还有什么好说的把。自己真心的体会，是中国人真的灌了好多水，尤其是我自己的这个方向。有时候自己也觉得很愤慨，但想想自己，何曾不是也在灌水。可能还是自己也是推动这个方向恶性循环的一份子，还是希望以后这个方向有更良性的发展吧，当然，与我无关了。</description>
    </item>
    
    <item>
      <title>剑指offer--字符串</title>
      <link>https://madneal.com/post/%E5%89%91%E6%8C%87offer--%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 14 Nov 2015 14:49:14 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%89%91%E6%8C%87offer--%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>C/C++中每个字符串都以字符&amp;rsquo;\0&amp;rsquo;作为结尾，这样我们就可以很方便的找到字符串最后的尾部。由于这个特点，每个字符串中都有一个额外字符的开销，稍不留神就会造成字符串的越界。 为了节省内存，C/C++把常量字符串放到单独的一个内存取余。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。
int main() { char str1[] = &amp;#34;hello world&amp;#34;; char str2[] = &amp;#34;hello world&amp;#34;; char* str3 = &amp;#34;hello world&amp;#34;; char* str4 = &amp;#34;hello world&amp;#34;; if(str1 == str2) printf(&amp;#34;str1 and str2 are same.\n&amp;#34;); else printf(&amp;#34;str1 and str2 are not same.\n&amp;#34;); if(str3 == str4) printf(&amp;#34;str3 and str4 are same.\n&amp;#34;); else printf(&amp;#34;str3 and str4 are not same.\n&amp;#34;); return 0; } str1和str2是两个字符串数组，我们会为它们分配两个长度为12个字节的空间，并把&amp;quot;hello world&amp;quot;的内容复制上去。这是两个初始地址不同的数组，因此str1和str2的值也不相同。 str3和str4是两个指针，我们无须为它们分配内存以存储字符串的内容，而只需要把它们指向&amp;quot;hello world&amp;quot;在内存中的地址就可以了。由于&amp;quot;hello world&amp;quot;是常量字符串，它在内存中只有一个拷贝，因此str3和str4指向的是同一个地址。
在C#中，封装字符串的类型System.String有一个非常特殊的性质：String中的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。
String str = &amp;#34;hello&amp;#34;; str.ToUpper(); str.Inser(0,&amp;#34;world&amp;#34;); 虽然我们对str做了ToUpper和Insert两个操作，但操作的结果都是生一个新的String实例并在返回值中返回，str本身的内容都不会发生改变，因此str最终的内容不变。由此可见，试图多次改变String的内容，改变之后的值只可以通过返回值得到。用String做连续多次修改，每一次修改都会产生一个临时对象，这样开销太大。为此C#定义一个新的与字符串相关的类型StringBuilder，它能容纳修改后的结果。</description>
    </item>
    
    <item>
      <title>剑指offer学习读书笔记--二维数组中的查找</title>
      <link>https://madneal.com/post/%E5%89%91%E6%8C%87offer%E5%AD%A6%E4%B9%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sat, 14 Nov 2015 12:08:09 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%89%91%E6%8C%87offer%E5%AD%A6%E4%B9%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都是按照从上到下递增的顺序排序。请设计一个函数，输入这样的一个二维数组和一个整数，判断数组是否含有这个整数。 1	2	8	9 2	4	9	12 4	7	10	13 6	8	11	15 我们可以发现以下规律：首先选取数组右上角的数字。如果这个数字是要寻找的数字，则返回结果。若这个数字大于我们要寻找的数字，则去除这个数字所在的列；若这个数字小于我们要寻找的数字，则去除这个数字所在的行。也就是说如果查找的数字不在数组的右上角，则每一次都在数组查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围了，直到找到需要查找的数字或者查找的范围为空。
从另外一个角度看，从左下角的数字来看，如果这个数字大于查找的数字，则剔除该行，若这个数字小于查找的数字，则剔除该列。
bool Find(int* matrix,int rows,int cols,int num) { bool found = false; if (matrix != null &amp;amp;&amp;amp; rows &amp;gt; 0 &amp;amp;&amp;amp; cols &amp;gt; 0) { int row = 0; int col = cols - 1; while(row &amp;lt; rows &amp;amp;&amp;amp; col &amp;gt;= 0) { if (matrix[row*cols + col] == num) { found = true; break; } else if(matrix[row*cols + col] &amp;gt; num) -- col; else ++ row; } } return found; } </description>
    </item>
    
    <item>
      <title>剑指offer学习--实现单例模式</title>
      <link>https://madneal.com/post/%E5%89%91%E6%8C%87offer%E5%AD%A6%E4%B9%A0--%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 13 Nov 2015 12:48:17 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%89%91%E6%8C%87offer%E5%AD%A6%E4%B9%A0--%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>只能生成一个实例的类是为了实现单例模式的类型。
加同步锁前后两次判断实例是否已存在 我们只是在实例还没有创建之前加锁操作，以保证只有一个线程创建出实例。而当实例已经创建之后，我们已经不需要再做加锁操作了。
public sealed class Singleton { private Singelton() { } private static object syncObj = new object(); private static Singleton instance = null; public static Singleton Instance { get { if (instance == null) { locak(syncObj) { if (instance == null) instance = new Singleton();	} } return instance; } } } 利用静态构造函数 public seled class Singleton { private Singelton() { } private static Singleton instance = new Singleton(); public static Singleton Instance { get { return instance; } } } 由于C#中调用静态构造函数时初始化静态变量，.</description>
    </item>
    
    <item>
      <title>latex算法步骤如何去掉序号</title>
      <link>https://madneal.com/post/latex%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E5%BA%8F%E5%8F%B7/</link>
      <pubDate>Fri, 06 Nov 2015 19:03:15 +0000</pubDate>
      
      <guid>https://madneal.com/post/latex%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E5%BA%8F%E5%8F%B7/</guid>
      <description>想去掉latex算法步骤前面的序号，如下 我想去掉每个算法步骤前面的数字序号，1，2，3，因为我已经写了step。我们只需要引用a lgorithmic这个包就可以了，代码如下：
\usepackage{algorithmic} \begin{algorithm}[htb] \caption{SDE} \label{alg2} \begin{algorithmic} \STATE Step 1. Compute the covariance matrix $C$ of the current population, then apply Eigen decomposition to $C$ as follows: \begin{equation} \label{eve} C=EDE^T \end{equation} where $E$ is the eigenvector matrix of the population, $E^T$ is the corresponding transposed matrix. $D$ is a diagonal matrix composed of eigenvalues. \STATE Step 2. Compute the the projection of the population with eigenvector matrix $E$. \begin{equation} \label{proj} P=X_G\cdot{E} \end{equation} \STATE Step 3.</description>
    </item>
    
    <item>
      <title>前端面试基础题目</title>
      <link>https://madneal.com/post/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</link>
      <pubDate>Fri, 30 Oct 2015 14:38:23 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</guid>
      <description>行内元素有哪些？块级元素有哪些？CSS的盒模型？ 行内元素：a b br i span input select 块级元素：div p h1 h2 h3 h4 form ul css盒模型：content border margin padding
前端页面由哪三层构成，分别是什么，作用是什么？ 结构层：主要指DOM节点：HTML/XHTML 样式层：主要指页面渲染：CSS 脚本层：主要指页面动画效果：JS/AS
CSS引入的方式有哪些?link和@import的区别是？ 内联 内嵌 外链 导入 区别：同时加载
css选择符号有哪些 标签选择符 类选择符 ID选择符
标签上title和alt属性的区别是什么？ alt当图片不显示用文字代表 title为该属性提供信息
什么是语义话的HTML？ 直观的认识标签，对于搜索引擎抓取有好处
清除浮动的几种方式以及优缺点： 1 使用空标签清除浮动 clear:both（理论上可以清楚任何标签，缺点增加无意义的标签） 2 使用overflow:auto 3 使用afert伪元素清除浮动
IE和标准下有哪些兼容性的写法
var ev = ev || window.event document.documentElement.clientWidth || document.body.clientWidth var target = ev.srcElement || ev.target 闭包就是能够读取其他函数内部变量的函数
添加，插入，替换，删除，到某个节点的方法
obj.appendChildl() obj.innersetBefore() obj.replaceChild obj.removeChild </description>
    </item>
    
    <item>
      <title>每日一练--直接插入排序</title>
      <link>https://madneal.com/post/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83--%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 28 Oct 2015 14:17:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83--%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>现在找工作的压力这么大，为了以后好找工作，现在开始要多看看算法，所以以后可以每天做个小题目，练习一下。今天作为第一天，说个最简单的直接插入排序。 直接插入排序可以这么理解，把A[j]和A[0]&amp;hellip;.A[j-1]的数进行比较，如果比他们小，就插入到比它小的前一位，直接插入排序的时间复杂度是O(n^2). 先给出伪代码分析
//the index of array is from 0 for j=1 to num.length key = num[j]; i = j-1; while i &amp;gt;= 0 and num[i] &amp;gt; key { num[i+1] = num[i]; i--; } num[i+1] = key; 下面用c++来实现
// insertsort.cpp : 定义控制台应用程序的入口点。 // #include &amp;#34;stdafx.h&amp;#34; #include&amp;lt;iostream&amp;gt; #include&amp;lt;stdlib.h&amp;gt; using namespace std; int main() { int num[10] = {10,20,1,78,34,99,12,21,2,55}; int key; cout &amp;lt;&amp;lt; &amp;#34;the number has not been sorted:&amp;#34; &amp;lt;&amp;lt; endl; for (int i = 0;i &amp;lt; 10;i++) { cout &amp;lt;&amp;lt; num[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;the number has been sorted:&amp;#34; &amp;lt;&amp;lt; endl; for (int j =1;j &amp;lt;10;j++) { int key = num[j]; int i = j-1; while(i &amp;gt;=0&amp;amp;&amp;amp;num[i]&amp;gt;key) { num[i+1] = num[i]; i--; } num[i+1] = key; } for (int m = 0;m &amp;lt; 10;m++) { cout &amp;lt;&amp;lt; num[m] &amp;lt;&amp;lt; &amp;#39; &amp;#39;; } cout &amp;lt;&amp;lt; endl; return 0; } 今天一练，到此结束。</description>
    </item>
    
    <item>
      <title>differential evolution代码实例（DE算法）</title>
      <link>https://madneal.com/post/differential-evolution%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8Bde%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 26 Oct 2015 08:44:06 +0000</pubDate>
      
      <guid>https://madneal.com/post/differential-evolution%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8Bde%E7%AE%97%E6%B3%95/</guid>
      <description>DE算法是遗传算法中一种比较流行的算法，这种算法比较简单，速度也比较快，下面给出一份示例代码
clear all; close all; clc 2 %Function to be minimized 3 D=2; 4 objf=inline(’4*x1^2é2.1*x1^4+(x1^6)/3+x1*x2é4*x2^2+4*x2^4’,’x1’,’x2’); 5 objf=vectorize(objf); 6 %Initialization of DE parameters 7 N=20; %population size (total function evaluations will be itmax*N, must be &amp;gt;=5) 8 itmax=30; 9 F=0.8; CR=0.5; %mutation and crossover ratio 10 %Problem bounds 11 a(1:N,1)=é1.9; b(1:N,1)=1.9; %bounds on variable x1 12 a(1:N,2)=é1.1; b(1:N,2)=1.1; %bounds on variable x2 13 d=(béa); 14 basemat=repmat(int16(linspace(1,N,N)),N,1); %used later 15 basej=repmat(int16(linspace(1,D,D)),N,1); %used later 16 %Random initialization of positions 17 x=a+d.</description>
    </item>
    
    <item>
      <title>github命令大全</title>
      <link>https://madneal.com/post/github%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Sun, 25 Oct 2015 22:30:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/github%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</guid>
      <description>github是一种开源的版本控制工具，现在已经得到很多人的应用。所以想介绍一下github的一些使用。
github安装 github提供了桌面客户端，我们也可以通过命令行的方式来进行控制。 windows https://windows.github.com mac https://mac.github.com
配置工具 对于本地版本配置用户信息
git config --global user.name &amp;#34;username&amp;#34; git config --global user.email &amp;#34;email&amp;#34; 上面的分别是设置用户名和邮箱
建立版本库 git init project-name //create a new local repost with the specified name git clone url //download a project and its entire version history 提交变化版本 git status // list all new of modified files to be committed git diff //show file differences not yet staged git add file //snapshot the file in preparation for versioning git diff --staged //show file difference between staging and the last file version git reset file //unstage the file, but preserve its contents git commit -m &amp;#34;description message&amp;#34; 群组版本控制 git branch //list all local branches in the current respority git branch branch-name //create a new branch git checkout branch-name //switch to the specific branch and update the working directory git merge branch //combine the specified branch&amp;#39;s history into the current branch git branch -d branch-name //delete the specified branch 重构文件名 git rm [file] //delete the file from the working directory and stage the deletion git rm --cached [file] //remove the file from version control but pressure the file locally git mv [file-origin] [file-renamed] //change the file name and prepare it for commit 排除版本控制 *.</description>
    </item>
    
    <item>
      <title>javascript的继承模式</title>
      <link>https://madneal.com/post/javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 24 Oct 2015 14:03:33 +0000</pubDate>
      
      <guid>https://madneal.com/post/javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</guid>
      <description>在javascript里面看到javascript的继承模式和传统的继承模式是有区别的，就想查资料看一下到底有区别，就看到了这篇文章，觉得讲得还可以，暂时先放上来，以后有别的东西再补充： http://segmentfault.com/a/1190000000766541
基本模式 var Parent = function(){ this.name = &amp;#39;parent&amp;#39;; ｝; Parent.prototype.getName = function(){ return this.name; }; Parent.prototype.obj = {a:1}; var Child = function(){ this.name = &amp;#39;child&amp;#39;; } Child.protytype = new Parent(); var parent = new Parent(); var child = new Child(); console.log(parent.getName());//parent console.log(child.getName());//child 这种事最简单实现原型继承的方法，直接把父类的对象复制给子类的构造函数的原型，这样子类的对象就可以访问到父类以及父类构造函数的protytype 这种方法的优点就是实现起来比较简单，不需要任何特殊的操作；同时他的缺点也很明显，如果子类需要做跟父类构造函数中相同的初始化动作，那么就得在子类构造函数中再重复一遍父类中的操作：
var Parent = function(name){ this.name = name || &amp;#39;parent&amp;#39;; }; Parent.prototype.getName = function(){ return this.name; }; Parent.prototype.obj = {a:1}; var Child = function(name) { this.</description>
    </item>
    
    <item>
      <title>css盒子模型设置的缩略形式</title>
      <link>https://madneal.com/post/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BC%A9%E7%95%A5%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Sat, 24 Oct 2015 10:48:23 +0000</pubDate>
      
      <guid>https://madneal.com/post/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BC%A9%E7%95%A5%E5%BD%A2%E5%BC%8F/</guid>
      <description>css里面的盒子模型里面设置padding,margin的上下或者左右的大小有很多方式，下面说说两种不同的方式： original method:
padding-top:0px padding-right:20px padding-bottom:30px padding-left:10px new method:
padding:0px 20px 30px 10px // top right bottom left respectively 同理：
margin-top:0px margin-right:20px margin-bottom:30px margin-left:10px margin:0px 20px 30px 10px 如果上下左右的值都是一样的话，那我们可以这样设置： the old method:
padding-top:20px padding-right:20px padding-bottom:20px padding-left:20px the new method:
padding:20px 如果上下值和左右值分别一样呢： the old method:
margin-top:0px margin-right:20px margin-bottom:0px margin-left:20px the new method
margin:0px 20px // top and bottom right and left respectively border的属性设置: the old method
border-width:thin border-style:solid boder-color black the new method:</description>
    </item>
    
    <item>
      <title>在pythonanywhere部署你的第一个应用</title>
      <link>https://madneal.com/post/%E5%9C%A8pythonanywhere%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 21 Oct 2015 21:03:10 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%9C%A8pythonanywhere%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8/</guid>
      <description>pythonanywhere是一个免费的托管python的代码，可以测试你的web应用，用起来还是比较方便的，现在就来介绍如何在pythonanywhere部署你的应用。 下载你的代码 我的代码是托管在github，我们首先从github下代码：
git clone https://github.com/&amp;lt;username&amp;gt;/my-first-blog.git 产生一个virtualenv
cd my-first-blog // create virtualenv virtualenv myvenv // activate vitalness . myvenv/bin/activate 数据库什么的我就不说了，pythonanywhere支持两种数据库，另外由于django本身就是支持sqlite数据库的，所以这里我们就不说了。 这里讲一下如何发布你的应用： 在他那个dashboard里面的vitualenv里面设置路径： /home//my-first-blog/myvenv/. 配置wsgi文件：
import os import sys path = &amp;#39;/home/&amp;lt;your-username&amp;gt;/my-first-blog&amp;#39; # use your own username here if path not in sys.path: sys.path.append(path) os.environ[&amp;#39;DJANGO_SETTINGS_MODULE&amp;#39;] = &amp;#39;mysite.settings&amp;#39; from django.core.wsgi import get_wsgi_application from whitenoise.django import DjangoWhiteNoise application = DjangoWhiteNoise(get_wsgi_application()) ok,可以访问你的网站了，网站地址：http://neal1991.pythonanywhere.com。那个是我的用户名，你可以设置成你自己的用户名。</description>
    </item>
    
    <item>
      <title>使用js实现图片轮滑效果</title>
      <link>https://madneal.com/post/%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E6%BB%91%E6%95%88%E6%9E%9C/</link>
      <pubDate>Wed, 21 Oct 2015 19:57:40 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E6%BB%91%E6%95%88%E6%9E%9C/</guid>
      <description>经常在购物网站，看到那种图片轮滑的效果，所以看到有人实现了，所以我也就学习下了。 首先贴出html代码：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;document&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;style.css&amp;#34;&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;javascript.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;flash&amp;#34;&amp;gt; &amp;lt;ul id=&amp;#34;pic&amp;#34;&amp;gt; &amp;lt;li style=&amp;#34;display:block&amp;#34;&amp;gt;&amp;lt;img src=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;img src=&amp;#34;&amp;#34; &amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;img src=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;img src=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;img src=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;img src=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;ol id=&amp;#34;num&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;activate&amp;#34;&amp;gt;1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;6&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;a href=&amp;#34;javascript:;&amp;#34; class=&amp;#34;arrow&amp;#34; id=&amp;#34;left&amp;#34;&amp;gt;&amp;amp;lt;&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;javascript:;&amp;#34; class=&amp;#34;arrow&amp;#34; id=&amp;#34;right&amp;#34;&amp;gt;&amp;amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 图像的原路径我就不制定了，css文件
* { margin: 0; padding: 0; list-style: none; } a { text-decoration: none; color: #fff; } #flash { width: 730px; height: 454px; margin: 100px auto; position: relative; cursor: pointer; } #pic li { position: absolute; top: 0; left: 0; z-index: 1; display: none; } #num { position: absolute; left: 40%; bottom: 10px; z-index: 2; cursor:default; } #num li { float: left; width: 20px; height: 20px; border-radius: 50%; background: #666; margin: 3px; line-height: 20px; text-align: center; color: #fff; cursor: pointer; } #num li.</description>
    </item>
    
    <item>
      <title>剑指offer学习--初级c&#43;&#43;面试题</title>
      <link>https://madneal.com/post/%E5%89%91%E6%8C%87offer%E5%AD%A6%E4%B9%A0--%E5%88%9D%E7%BA%A7c&#43;&#43;%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Wed, 21 Oct 2015 13:28:02 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%89%91%E6%8C%87offer%E5%AD%A6%E4%B9%A0--%E5%88%9D%E7%BA%A7c&#43;&#43;%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>定义一个空的类型，里面没有任何成员函数和成员变量，对该类型求sizeof,得到的结果是多少？ 答案是1。空类型中的实例中不包含任何信息，本来求sizeof应该是0，但是当我们声明该类型的实例的时候，他必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio中每个空类型的实例占用1字节的空间。
  如果在该类型中添加一个构造函数和析构函数，在对该类型求sizeof，得到的结果又是多少？ 和前面一样，还是1.调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址止于类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外的信息。
  那如果把析构函数标记为虚函数呢？ C++的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型中的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4字节的空间，因此求sizeof是4；如果是64位的机器，那么结果就是8.
分析下面代码运行结果：
class A { private: int value; public: A(int n) { value = n; } A(A other) { value = other.value; } void print() { std::cout&amp;lt;&amp;lt;value&amp;lt;&amp;lt;endl; } }; int main() { A a = 10; A b = a; b.print(); } 在上述代码中，复制构造函数A（A other)传入的参数是A的一个实例。由于是传值参数，我们把形参复制到实参会调用复制构造函数。因此如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无止境的递归调用从而导致栈溢出。因此C++的标准不允许复制构造函数传递参数，因此会编译出错。要解决这个问题，我们可以把构造函数修改为A(const A&amp;amp;other)，也就是把传值参数改为常量引用。
C++中可以使用struct和class来定义类型，这两种类型有什么区别？ 如果没有标明成员函数或者成员变量的访问权限级别，在struct中默认的是public,而在class中默认的是private。 那么在C#中呢？ C#和C++不一样。在C#中如果没有标明成员函数或者成员变量的访问权限，struct和class都是private。struct和class的区别是struct定义的是值类型，值类型的实例在栈上分配内存；而class定义的是引用类型，引用类型的实例是在堆上分配内存的。</description>
    </item>
    
    <item>
      <title>matlab调试技巧</title>
      <link>https://madneal.com/post/matlab%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Tue, 13 Oct 2015 18:49:10 +0000</pubDate>
      
      <guid>https://madneal.com/post/matlab%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
      <description>Matlab的调试总体分为，直接调试和间接调试。 1.直接调试： （1）去掉句末的分号； （2）单独调试一个函数：将第一行的函数声明注释掉，并定义输入量，以脚本方式执行 M 文件； （3）适当地方添加输出变量值的语句； （4）添加keyboard命令；
2.工具调试： 1.）以命令行为主的调试： （1）设置断点： dbstop in mfile:在文件名为mfile的M文件第一个可执行语句前设断点； dbstop in mfile at lineno:在mfile的第lineno行设断点； dbstop in mfile at subfun:当程序执行到子程序subfun时，暂时中止执行，并设断点； dbstop if error:遇到错误时，终止M文件运行，并停在错误行（不包括try&amp;hellip;catch语句中检测到的的错误，不能在错误后重新开始运行）； dbstop if all error:遇到任何类型错误均停止（包括try&amp;hellip;catch语句中检测到的的错误）； dbstop if warning:程序可恢复运行； dbstop if caught error:当try&amp;hellip;catch检测到运行时间错误是，停止M文件执行，可恢复运行； dbstop if naninf 或 dbstop if infnan （2）断点清除： dbclear all:清除所有M文件中的所有断点； dbclear all in mfile:清除文件名为mfile的文件中的所有断点； dbclear in mfile:清除文件名为mfile中第一个可执行语句前的断点； dbclear in mfile at lineno: dbclear in mfile at subfun: dbclear if error/warning/naninf/infnan: （3）恢复运行： dbcount:从断点处恢复程序的执行，直到下一个断点或错误后返回Matlab基本工作空间； （4）调用堆栈： dbstack： 1.</description>
    </item>
    
    <item>
      <title>柯西分布</title>
      <link>https://madneal.com/post/%E6%9F%AF%E8%A5%BF%E5%88%86%E5%B8%83/</link>
      <pubDate>Mon, 12 Oct 2015 18:49:39 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%9F%AF%E8%A5%BF%E5%88%86%E5%B8%83/</guid>
      <description>柯西分布的概率密度函数是： t是location parameter,s是scale parameter.当t=0以及s=1的时候称为标准柯西分布，标准柯西分布的密度函数是： 下面的是标准柯西分布概率密度函数分布图： </description>
    </item>
    
    <item>
      <title>Django学习——开发你的第一个Django应用2</title>
      <link>https://madneal.com/post/django%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAdjango%E5%BA%94%E7%94%A82/</link>
      <pubDate>Sun, 11 Oct 2015 13:02:59 +0000</pubDate>
      
      <guid>https://madneal.com/post/django%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAdjango%E5%BA%94%E7%94%A82/</guid>
      <description>接着上一节的内容来说。我们将继续关注与上一节制作的polls应用以及Django自动产生额度管理网站。
产生一个管理员用户 首先我们需要产生一个管理员用户，运行如下命令； python manage.py createsuperuser 下面会让你输入用户名，邮箱以及用户密码，按照要求填写就可以了，这样我们就产生了一个管理员账户了。
开发服务器 Django的管理员网站是默认激活的，我们可以通过上节讲到的方式激活服务器： python manage.py runserver 现在打开浏览器，输入http://localhost:8000/admin/你就可进入管理员登录界面了，输入用户名和密码就可以登录了。
进入管理员网站 当你以超级管理员的身份进去管理员网站，你就可以看到管理员的默认界面了。
在管理员中修改poll应用 在默认管理员界面中我们看不到我们的poll应用。我们需要高速管理员Question对象具有一个管理员接口，打开polls/admin.py
from django.contrid import admin from .models import Question admin.site.register(Question) 定制管理员表单 现在我们来开始定制管理员表单，打卡polls/admin.py
from django.contrib import admin from .models import Question,Choice //Register your models here. class ChoiceInline(admin.TabularInline): model = Choice extra = 3 class QuestionAdmin(admin.ModelAdmin): #fields = [&amp;#39;pub_date&amp;#39;,&amp;#39;question_text&amp;#39;] list_display = (&amp;#39;question_text&amp;#39;,&amp;#39;pub_date&amp;#39;,&amp;#39;was_published_recently&amp;#39;) list_filter = [&amp;#39;pub_date&amp;#39;] search_fields = [&amp;#39;question_text&amp;#39;] fieldsets = [ (None,{&amp;#39;fields&amp;#39;:[&amp;#39;question_text&amp;#39;]}), (&amp;#39;Date information&amp;#39;,{&amp;#39;fields&amp;#39;:[&amp;#39;pub_date&amp;#39;],&amp;#39;classes&amp;#39;:[&amp;#39;collapse&amp;#39;]}), ] inlines = [ChoiceInline] admin.</description>
    </item>
    
    <item>
      <title>如何查找django安装路径</title>
      <link>https://madneal.com/post/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BEdjango%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 10 Oct 2015 18:35:51 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BEdjango%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84/</guid>
      <description>需要找到django的安装路径，官方说的那个方法不好用，国内搜索都是都不到的，后来谷歌搜到了很简单 import django django 这样就可以找django的安装路径了，真心不懂为什么国内都看不到</description>
    </item>
    
    <item>
      <title>Django学习——开发你的第一个Django应用1</title>
      <link>https://madneal.com/post/django%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAdjango%E5%BA%94%E7%94%A81/</link>
      <pubDate>Sat, 10 Oct 2015 16:39:31 +0000</pubDate>
      
      <guid>https://madneal.com/post/django%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAdjango%E5%BA%94%E7%94%A81/</guid>
      <description>突然对Django热情似火，所以就开学习了，我是根据官方文档学习的，所以我打算把官方文档翻译一遍，全当学习，首先贴官方文档的地址：https://docs.djangoproject.com/en/1.8/intro/tutorial01/。我是根据我自己的理解翻译，可能和官方有一些差入，如有不当之处，还望指正。 首先请确保你已经安装了python,Django是建立在python的基础之上，所以首先要安装python,mac上面的这些安装都比较简单，用pip 就可以了。下面就开始来创建项目吧
创建一个项目 进入到一个文件件下来创建你自己的项目，文件夹路径看你自己喜欢了，运行以下命令 django-admin statrtproject mysite 这就将会产生一个mysite文件夹，这个文件夹的名字可以随便定义的，没有什么影响。让我们一起看看产生了什么： mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py  关于这些文件的详细内容我就不一一介绍了，可以进入文件夹看看，下面还会提到这些文件的用法。
建立数据库 好现在打开mysite/settings.py。默认来说的配置是使用SQLite数据库，这是一种轻量级的数据库，在手机上面使用的还是蛮多的，感兴趣的同学可以去查一查。SQLite是包括在python之中的，所以你也不需要另外去安装了，同时你也可以使用其他的数据库，不过要改一下配置文件。如果对数据库有更多的想法可以去https://docs.djangoproject.com/en/1.8/ref/settings/#std:setting-DATABASES里 main有关于数据库配置更为详细的介绍。 同时注意INSTALLED_APPS设置这个文件的顶层。一般来说INSTALLED_APPS 包含一下apps:
 django.contrib.admin django.contrib.auth django.contrib.contenttypes django.contrib.sessions django.contrib.messages django.contrib.staticfiles 这些应用的具体功能我就不一一介绍，反正就是为了配置更方便，到时还会用到。上面的这些应用可能会用到数据库中的表格，所以在应用他们以前我们要创建这些表格： python manage.py migrate  开发服务器 让我们看一下我们的项目能否正常工作，切换到mysite文件夹下，运行命令行： python manage.py runserver 然后就可以看到服务器正常运行的一些提示信息了
创建模型 创建你自己的应用，确定你是在和manage.py同一及的文件路径下，运行命令行： python manage.py startapp polls 这回创建一个polls文件件： polls/ __init__.py admin.py migrations/ __init__.py models.py tests.py views.py  在web应用中创建数据库的第一步是定义你自己的模型。 在我们这个简单的应用中，我们会创建两个模型Question Choice 编辑polls/models.py文件：
from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.</description>
    </item>
    
    <item>
      <title>http响应代码解释</title>
      <link>https://madneal.com/post/http%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Sat, 10 Oct 2015 11:19:41 +0000</pubDate>
      
      <guid>https://madneal.com/post/http%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/</guid>
      <description>200：成功响应 302：找到，但是请求的资源在另外一个不同的url中。 400：错误请求。这个请求不能被服务器所理解，客户端必须修改请求。 401：未认证，这个请求需要用户认证。 404：未找到。服务器没有找到任何和这个请求符合的资源。</description>
    </item>
    
    <item>
      <title>全栈开发系列学习2——django项目搭建</title>
      <link>https://madneal.com/post/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A02django%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 10 Oct 2015 11:16:11 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A02django%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid>
      <description>项目代码：http://yunpan.cn/cHajgT4HvgHqx （提取码：8350） 配置项目：
 首先确保你的机器安装了python和pip，这两种安装比较简单，这里就不说了。 在你的机器上安装mysql服务，这个也不细说了。然后安装Mysql-python,只要输入命令&amp;quot;pip install MySQL-python&amp;quot;就可以了。 解压项目文件代码。 进入src文件夹下，输入&amp;quot;make install&amp;quot;这样会自动安装所有的依赖库。 现在我们可以创建一个数据库：web_dev_tutorial  mysql -u &amp;lt;your username&amp;gt; -p&amp;lt;yourpassword&amp;gt; 注意用户名前面有空格，而密码前面是没有空格的，这一点格外注意。 在数据库中创建实例： create database web_dev_tutorial 然后将数据库和我们的项目链接在一起，打开src/web_dev_tutorial/settings.py找到以下配置 DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;, &#39;NAME&#39;: &amp;quot;web_dev_tutorial&amp;quot;, &#39;USER&#39;: &#39;root&#39;, &#39;PASSWORD&#39;: &#39;root&#39;, } } 把相应的用户名密码改成你的数据库的用户名密码就可以了。 6. 现在我们可以载入一些测试数据到数据库。检查data文件夹是否有个叫parse.py的文件，还有一个文件夹是rawdata，里面包含了很多的文本文件。进入文件夹test，打开一个叫做config.py的文件，你会看到以下内容 ` MYSQL_HOST = &amp;lsquo;127.0.0.1&amp;rsquo; MYSQL_PORT = 3306
MYSQL_USERNAME = &amp;lsquo;root&amp;rsquo; MYSQL_PASSWORD = &amp;lsquo;root&amp;rsquo;
MYSQL_DB_NAME = &amp;lsquo;web_dev_tutorial&amp;rsquo;  同样把数据库用户名密码改成你相应的用户名密码就可以了。接着，在文件夹test下，输入make load`会自动擦除文本文件，并保存结果，这些结果也会被载入到数据库中。 7. 在文件夹src下，输入&amp;quot;make&amp;quot;,你将会看到： ｀ MYSQL_HOST = &amp;lsquo;127.0.0.1&amp;rsquo; MYSQL_PORT = 3306</description>
    </item>
    
    <item>
      <title>一个神奇却很简单的css特效</title>
      <link>https://madneal.com/post/%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E5%8D%B4%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84css%E7%89%B9%E6%95%88/</link>
      <pubDate>Wed, 07 Oct 2015 16:49:41 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E5%8D%B4%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84css%E7%89%B9%E6%95%88/</guid>
      <description>在网上看到一个前端大牛的主页，觉得他有一个特效特别酷，一开始还以为是要用什么javascript代码来实现，但仔细看一下，发觉只是用几行css代码就搞定了，我觉得挺好的。 他这个效果就是鼠标放在左半部分和右半部分，整个网页的布局颜色会相互变化，我贴上前后两张图来比较一下，你们就明白了。 当鼠标放在左半部分： 当鼠标放在右半部分： 可能静态的图片看不太出效果，但是动态看起来还是比较酷的，最关键的是它的代码其实很简单。
.panel, .panel-left:hover + .panel-right { background-color: #22c3aa; color: white; } .panel-right, .panel:hover { background-color: white; color: #22c3aa; } .panel-right:hover + img#avatar { transform: rotateY(180deg); } 第一段和第二段代码主要就是背景颜色和主体颜色的改变，他把做面板鼠标移动到上面时的效果和右面板的效果设为一致，从而达到左右颠倒的效果，最后一段代码主要是下面一张图片的旋转180度。 真的是前端的东西很变化莫测，往往很简单的思路能够达到意想不到的效果，我觉得真的是值得我们很多时候多多思考的。 再贴上这个前端大神的网页http://zhangwenli.com/。真的很佩服她，一个女生居然代码写的这么好，看看别人做的东西，再看看自己的东西，简直惭愧不已，我觉得人丑还是多读书，尤其是我这种长的那么丑的人就更应该读了。</description>
    </item>
    
    <item>
      <title>全栈开发教学学习系列1——前言</title>
      <link>https://madneal.com/post/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E6%95%99%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%971%E5%89%8D%E8%A8%80/</link>
      <pubDate>Wed, 07 Oct 2015 14:47:02 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E6%95%99%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%971%E5%89%8D%E8%A8%80/</guid>
      <description>在网上看到一个全栈开发教学的例子，他是一个使用Django来作为服务器后端结合前端来做的东西，是一个全栈教学的案例。虽然作者是中国人，但是他做的东西都是用英文做出来的，http://webcoursify.github.io。在这里，我们就把他的学习教程一步步翻译出来，也当是自己学习。 开篇部分zhuyao1讲一下Django的基本概念，这个部分主要分为三个小结：
一. 客户端服务器模型和MVC设计模式 首先用一张图来简单的描述一下： 基本上所有的网络系统都符合这个模型。在网络系统中，服务器通过标准协议响应来自各种客户端发来的请求。客户端之间的请求被认为是相互独立的。这就意味着服务器如果正在响应某个客户端的请求时，他就不需要处理来自其他客户端的请求或者相同客户端的其他请求。 MVC 架构模式 这种架构模式被广泛应用于各种软件开发中，而不仅仅只是网络系统的开发。下面简单介绍一下MVC：
 Model 这个组件时系统的核心问题，比如数据结构，数据存储遗迹核心逻辑等等。它经常注重的是整个系统的基础，和其他两个组件没有特别多的交互。 View 这个组件注重向用户展示信息以及接受用户的交互信息。这个组件在网络系统中往往就是前端层次。 Controller 这个组件连接前两个组件。这个组件中的函数往往是被事件所触发得。 当然这里面的名称可能和在Django里面的叫法不太一样，但具体内容应该是差不多的。  </description>
    </item>
    
    <item>
      <title>indexDB的概念</title>
      <link>https://madneal.com/post/indexdb%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 07 Oct 2015 09:49:59 +0000</pubDate>
      
      <guid>https://madneal.com/post/indexdb%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>IndexDB利用数据键(key)访问，通过索引功能搜索数据，适用于大量的结构化数据，如日历，通讯簿或者记事本。
 以key/value成对保存数据 IndexDB和WebStorage都是以数据键值的方式来保存数据，只要创建索引，就可以进行数据搜索和排序。 交易数据库模型 IndexDB进行数据库操作之前要先进行交易。所谓交易，就是将数据库所做的访问操作（比如增删改查）包装成一个任务来执行，这个任务可以包含多个步骤，只有所有的步骤执行成功，交易才算成功；只要有一个步骤失败，整个交易就会取消所做的更改都会被恢复。 IndexDB大部分的异步API IndexDB数据库操作并不会立即执行，而是先创建数据库操作要求，然后定义事件处理函数来响应这些要求是成功还是失败。 通过监听DOM事件取得执行结果 数据操作完成时，通过监听DOM事件来取得执行结果，DOM事件的type属性会返回成功或者失败。 每个读写操作都是请求 IndexDB随时随地都在使用请求 面向对象 IndexDB是面向对象数据库，不使用sql语法，必须以面向对象的方式来获取数据。 NOSQL的数据库系统 IndexDB的查询语言并非sql，而是查询索引获取指针，然后用指针访问查询结果。  </description>
    </item>
    
    <item>
      <title>markdown语法规则</title>
      <link>https://madneal.com/post/markdown%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</link>
      <pubDate>Tue, 06 Oct 2015 20:47:17 +0000</pubDate>
      
      <guid>https://madneal.com/post/markdown%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</guid>
      <description>标题 标题是每篇文章最常用的格式，在markdown中如果要定义标题的话，只要在这段文字之前加#号就可以了。
一级标题 二级标题 三级标题 以此类推，总共六级标题，建议在#号之后加上一个空格，这是标准的markdown语法。 列表 列表主要分为有序列表和无序列表。只需要在文字前加上-或*即可变成无序列表，有序列表直接在文字前加上1. 2. 3. 符号和要在文字之前加一个空格就可以了。
 1 2 3    1 2 3  引用 如果你要饮用一段话的话，那么你只要在引用的文字前加上&amp;gt;这种尖括号就可以了
 这是我要引用的文字
 图片和链接 插入链接和图片的方法很像，区别在于一个感叹号 图片为：{ImgCap}{/ImgCap} 链接为：
粗体和斜体 粗体和斜体也很简单，用两个包含一段文本就是粗体的语法，用一个包含一段文本就斜体的语法。 这是粗体 这是粗体
表格
   Tables are cool     col1 clo2 col3    分割线 分割线的语法只需要三个*号就可以了 分割线上
 分割线下</description>
    </item>
    
    <item>
      <title>css样式表的引入方式</title>
      <link>https://madneal.com/post/css%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 06 Oct 2015 16:11:46 +0000</pubDate>
      
      <guid>https://madneal.com/post/css%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/</guid>
      <description>一般来说，css 有两种样式表的引入方式，在这里我记录一下，比较这两种引入方式的区别：
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;css文件&amp;#34;&amp;gt; @import &amp;#34;css文件&amp;#34; 显然第一种方式似乎是更常见的。事实上，使用这两种方式引入css文件的效果都是一致的，区别在于是html标记，而@import是css语法。标记有rel,type和href属性，可以制定css样式表的名称，这样可以利用javascript的语法来控制。举例来说，我们可以在一个网页中链接多个css样式文件，在利用javascript语法控制不同情况下显示的样式文件，例如让用户在点击某个按钮之后更换网页的背景颜色，或者随着时间来更换网页的背景颜色，正因为link方式的弹性更大，这也是为什么这种方式更为常见的原因。</description>
    </item>
    
    <item>
      <title>如何用latex画一个简单的表格</title>
      <link>https://madneal.com/post/%E5%A6%82%E4%BD%95%E7%94%A8latex%E7%94%BB%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E6%A0%BC/</link>
      <pubDate>Sat, 26 Sep 2015 08:40:35 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%A6%82%E4%BD%95%E7%94%A8latex%E7%94%BB%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E6%A0%BC/</guid>
      <description>latex毫无疑问是一个十分强大的论文写作工具，所以掌握它就显得非常有意义，讲一下如何画一个简单的表格，代码如下： \begin{table} \centering \begin{tabular}{||c|c||} \hline algorithm &amp;amp; time complexity\ \hline RM-MEDA &amp;amp; O(NM)\ \hline IRM-MEDA &amp;amp; O(NK)\ \hline \end{tabular} \caption{The time complexity comparing result} \label{TAB1} \end{table} 呈现的效果如下： 是不是很简单
欢迎搜索微信号 mad_coder 或者扫描二维码关注公众号：</description>
    </item>
    
    <item>
      <title>matlab批量修改变量的名称</title>
      <link>https://madneal.com/post/matlab%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8D%E7%A7%B0/</link>
      <pubDate>Tue, 08 Sep 2015 09:31:21 +0000</pubDate>
      
      <guid>https://madneal.com/post/matlab%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8D%E7%A7%B0/</guid>
      <description>使用matlab做实验的时候，保存的文件里面的变量名都是一样的 ，所以希望能够把变量名全部都重命名。我举个个例子，假设我一堆文件，文件名分别是gds1,gds2,gds2,&amp;hellip;.. 但是实际上load进来之后的变量名称都是gds，所以我希望能够把变量名能够改成相对应的文件名称。在这里，我使用了eval这个函数，这个函数到是一个非常方便的选择。 %% 变量批量重命名 clear all rootname = &#39;gds&#39;; extension = &#39;.mat&#39;; for i = 1:n variable = [rootname,int2str(i)]; filename = [variable,extension]; load(filename); eval([&#39;gds&#39;,num2str(i),&#39;=&#39;,&#39;gds&#39;,&#39;;&#39;]); save(filename,variable); clear gds variable filename; end clear all</description>
    </item>
    
    <item>
      <title>奇异值分解基础(SVD)</title>
      <link>https://madneal.com/post/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%9F%BA%E7%A1%80svd/</link>
      <pubDate>Sat, 27 Jun 2015 18:10:15 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E5%9F%BA%E7%A1%80svd/</guid>
      <description>最近要了解一下Incremental PCA的一些知识，然后看到一篇论文里面讲到了SVD（奇异值分解），奈何自己以前没有把机器学习的课好好上，现在很多东西还是要补回来。所以，我就想了解一些SVD的基础知识。 PCA的实现一般有两种方法，一种是用特征值分解去实现，一种是用奇异值分解去实现的，SVD貌似在很多领域都有很重要的应用。
特征值和特征向量 特征值和特征向量是线性代数里面的基础知识，相信大部分人都知道： 很显然，λ就是特征向量v对应的特征值，一个矩阵的一组特征向量都是相互正交的，相信这些大家在线性代数都有学习。特征值分解是将一个矩阵以下面的形式进行分解： 其中Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线上的元素就是一个特征值。 特征值分解可以得到特征值和特征向量，特征值表示的是这个特征值的重要性，而特征向量表示的是这个特征是什么，可以将每一个特征向量理解为一个线性的子空间。不过特征值分解也有很多的局限，比如变换的矩阵必须是方阵。
奇异值 特征值分解只能针对于方阵，局限性较大，而奇异值分解是一个能够用于任意的矩阵的一种分解方法： 假设A是一个NM的矩阵，那么U是一个NN的方阵（里面的向量是正交的，U里面的向量称为左奇异向量），Σ是一个NM的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），V&amp;rsquo;（V的转置矩阵）是一个NN的矩阵，里面的向量也是正教的，称为右奇异向量。 我们将矩阵A和他的转置矩阵相乘，就可以得到一个方阵，我们利用方阵的求特征值可以得到： 这里面的v，就是我们上面所说的右奇异向量，由此我们可以得到 这里的σ就是上面所说的奇异值，u就是上面说的左奇异向量。奇异值σ跟特征值类似，在矩阵Σ中也是从打到小排列，而且σ的减少特别的快。在很多情况下，前10%的甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们可以用前r大的奇异值来近似描述矩阵，因此部分奇异值分解可以如下定义： r是一个远小于m、n的数， 右边的三个矩阵相乘的结果将会是一个接近于A的矩阵，r越接近于n，则相乘的结果越接近于A。而这三个矩阵的面积之和要远远小于原始的矩阵A。
SVD和PCA## PCA的问题其实是一个基的变换，使得变换后的数据有着最大的方差。方差的大小描述的是一个变量的信息量，我们在讲一个东西的稳定性的时候，往往说要减小方差，如果一个模型的方差很大，那就说明模型不稳定了。但是对于机器学习的数据，方差大反而有意义，不然输入的数据就是同一个点了，那方差九尾0了。 这个假设是一个摄像机采集一个物体运动得到的图片，上面的点表示物体运动的位置，假设我们想用一条直线去拟合这些点，那我们应该选择什么方向的线？当然是图上标有signal的那条线。如果我们把这些点单纯的投影到x轴或者y轴上，最后在x轴和y轴上得到的方差就是相似的。 一般来说方差大的方向就是信号的方向，方差小的方向就是噪声的方向，我们在数据挖掘或者数字信号处理中，往往是要提高信噪比。就上图说，如果我们只保留signal方向的数据，就可以对原始数据进行不错的近似了。 PCA的就是对原始的空间中顺序地找一组相互正教的坐标轴，第一个轴使得方差最大，第二个轴是在与第一个轴相交的平面中使得方差最大，第三个轴也是在与第1,2个轴正交的平面中使得方差最大，这种假设在N维空间中，我们就可以找到N个这样的坐标轴，我们取前r个去近似这个空间，这样就从一个N维的空间压缩到r维的空间，但是我们可以选择r个坐标轴使得空间的压缩使得数据的损失最小。 假设我们矩阵的每一行代表一个样本，每一列代表一个feature，将一个mn的矩阵A进行坐标轴的变化，P就是一个变换的矩阵从一个n维的空间变换到另外一个n维的空间 而将一个mn的矩阵A变成一个m*r的矩阵，我们就会使得本来有n个feature的，变成有r个feature了(r小于n)，这r个其实就是对n个feature的一种提炼，我们把这个称为feature的压缩： 之前的SVD的式子是： 在矩阵的两边同时乘上一个矩阵V，由于v是一个正交的矩阵 我们对SVD分解的式子两边乘以U的转置矩阵U&#39; PCA几乎可以说是对SVD的一种包装，如果我们实现了SVD，那也就实现了PCA。</description>
    </item>
    
    <item>
      <title>PCA算法和实例</title>
      <link>https://madneal.com/post/pca%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sat, 20 Jun 2015 09:11:39 +0000</pubDate>
      
      <guid>https://madneal.com/post/pca%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B/</guid>
      <description>PCA算法 算法步骤： 假设有m条n维数据。
 将原始数据按列组成n行m列矩阵X 将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值 求出协方差矩阵C=1/mXXT 求出协方差矩阵的特征值以及对应的特征向量 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P Y=PX即为降维到k维后的数据  实例## 以这个为例，我们用PCA的方法将这组二维数据降到一维 因为这个矩阵的每行已经是零均值，所以我们可以直接求协方差矩阵：
然后求其特征值和特征向量，求解后的特征值为： λ1=2,λ2=2/5 其对应的特征向量分别是： 由于对应的特征向量分别是一个通解，c1和c2可取任意实数。那么标准化后的特征向量为：
因此我们的矩阵P是： 可以验证协方差矩阵C的对角化： 最好我们用P的第一行诚意数据矩阵，就得到了降维后的数据表示： 降维后的投影结果如下图： PCA本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据“离相关”，也就是让它们在不同的正交方向上没有相关性。 因此，PCA也存在一些限制，例如它可以很好地解除线性相关，但是对于高阶相关性就没有办法了。对于存在高阶相关性的数据，可以考虑Kernel PCA,通过Kernel将非线性相关转化为线性相关。另外，PCA假设数据各特征分布在正交方向上，如果在非正交方向上存在几个方差较大的方向，PCA的效果就大打折扣。 PCA是一种无参数技术，也就是说面对同样的数据，如果不考虑清晰，谁来做结果都一样，没有主观参数的介入，所以PCA便于通用实现，但是本身没有个性化的优化。
本文主要参考：http://blog.codinglabs.org/articles/pca-tutorial.html</description>
    </item>
    
    <item>
      <title>WWDC2015</title>
      <link>https://madneal.com/post/wwdc2015/</link>
      <pubDate>Tue, 09 Jun 2015 15:05:11 +0000</pubDate>
      
      <guid>https://madneal.com/post/wwdc2015/</guid>
      <description>ios9功能  Proactive：整合siri、联系人、日历以及第三方应用。 Notes： 可调节字体、插图片、支持手写注记等功能。 Maps： 加入新公交试图，Transit提供公交系统和换乘细节。 News：聚合新闻应用，可根据西兴趣选择不同的新闻源。 电池续航：充满殿后设备使用时间延长1小时。 安装包更小，只有1.3G。 用户隐私：数据只会保存在本地，不会上传到云。  OS X EI Capitan  新增多种触控板手势。 safari增加固定标签页功能。 窗口自适应功能，不必手动调整窗口大小和拖动窗口。 Spotlight能够理解日常语言。 Metal首次引入图形管理接口。 swift2将在今年年底开源。 split view将自动并排两个app共用一个屏幕。 邮箱app增强全屏显示功能。  ipad最新功能  quick type键盘 传说中的分屏 支持“画中画”功能  </description>
    </item>
    
    <item>
      <title>道路模型--linear-parabolic model</title>
      <link>https://madneal.com/post/%E9%81%93%E8%B7%AF%E6%A8%A1%E5%9E%8B--linear-parabolic-model/</link>
      <pubDate>Mon, 18 May 2015 19:23:28 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%81%93%E8%B7%AF%E6%A8%A1%E5%9E%8B--linear-parabolic-model/</guid>
      <description>读过很多道路追踪的论文，经常都需要道路模型的建模。我不知道是不是因为自己太笨还是怎样，好多人建的模型我实在无法理解他的用意何在，而且我真的深刻怀疑他们那些模型的参数是不是真的可以求出来。就比如这篇文章“lane detection and tracking using a new lane model and distance transform&amp;quot;,我实在无法理解他的建模，还有他的建模参数到底如何求解： 我无法理解他为什么要设置那个角度，我也不知道那个顶点的位置如何获取，如果有大神知道的，还望告知一下。 好，说完不好的，我就要说个我觉得很通俗易懂的模型，这是我第一个遇到一个我能看的懂，而且我又觉得具有实用意义的道路模型，首先如图所示： 这个图片被xm分成为了两个部分，一个部分我们称为far feild,一个部分我们称为near feild，对于这两个部分采用了不同的建模方法。道路模型f(x)由这两个部分组成，near feild线性的，而far feild是抛物线的，定义如下： 这里的xm就是代表了原图中的边界线，同时我们根据道路模型的连续性，可以得出 因为在xm两边的函数值是相等的，并且导数也是相等的。 从而我们就能得到下面的公式： 这样我们可以把c和e用别的变量来表达 因此我们可以把最终的道路模型参数用下面的函数来表达 这就是这个论文提出的道路模型，这样是不是很好理解，而且很有根据。 Reference Jung C R, Kelber C R. A robust linear-parabolic model for lane following[C]//Computer Graphics and Image Processing, 2004. Proceedings. 17th Brazilian Symposium on. IEEE, 2004: 72-79.</description>
    </item>
    
    <item>
      <title>常用颜色的RGB分布</title>
      <link>https://madneal.com/post/%E5%B8%B8%E7%94%A8%E9%A2%9C%E8%89%B2%E7%9A%84rgb%E5%88%86%E5%B8%83/</link>
      <pubDate>Sun, 10 May 2015 11:55:27 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%B8%B8%E7%94%A8%E9%A2%9C%E8%89%B2%E7%9A%84rgb%E5%88%86%E5%B8%83/</guid>
      <description>RGB色彩模式是工业界的一种颜色标准，它通过对红（RED）、绿（GREEN）、蓝（BLUE）三种基本颜色的相互组合从而叠加出各种颜色。RGB色彩模式为每一个红、绿、蓝分类了0-255范围内的亮度值。 RGB色彩模式通常RGB(0，0，0）的格式来表示颜色，括号中的3个数字分别表示红、绿、蓝的亮度值，常用的颜色的RGB颜色分布有以下这些：
 品红色 （255,0,255） 蓝色 （0,0,255） 青色 （0,255,255） 绿色 （0,255,0） 黄色 （255,255,0） 红色 （255,0,0） 紫色 (128,0,128) 深蓝色 （0,128,128） 鸭绿色 （0,128,128） 深绿色 （0,128,0） 橄榄绿 （128,128,0） 栗色 （128,0,0） 黑色 (0,0,0) 灰色 （128,128,128） 银色 （192,192,192） 白色 （255,255,255）  </description>
    </item>
    
    <item>
      <title>实现combobox模糊查询的时候报错 InvalidArgument=“0”的值对于“index”无效</title>
      <link>https://madneal.com/post/%E5%AE%9E%E7%8E%B0combobox%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%A5%E9%94%99-invalidargument0%E7%9A%84%E5%80%BC%E5%AF%B9%E4%BA%8Eindex%E6%97%A0%E6%95%88/</link>
      <pubDate>Sat, 02 May 2015 17:51:23 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%AE%9E%E7%8E%B0combobox%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%A5%E9%94%99-invalidargument0%E7%9A%84%E5%80%BC%E5%AF%B9%E4%BA%8Eindex%E6%97%A0%E6%95%88/</guid>
      <description>因为要对combobox实现模糊查询，因为系统实现的匹配只能从左到右进行匹配，所以利用两个list来进行模糊匹配，主要代码如下：
 List&amp;lt;string&amp;gt; listOnit = new List&amp;lt;string&amp;gt;(); //绑定原始数据源 List&amp;lt;string&amp;gt; listNew = new List&amp;lt;string&amp;gt;(); private void comboBox1_TextUpdate(object sender, EventArgs e) { this.comboBox1.Items.Clear(); listNew.Clear(); //在原始数据源中遍历，把包含当前输入的内容添加到listNew中 foreach (string item in listOnit) { if (item.Contains(this.comboBox1.Text)) { listNew.Add(item); } } this.comboBox1.Items.AddRange(listNew.ToArray()); this.comboBox1.SelectionStart = this.comboBox1.Text.Length; Cursor = Cursors.Default; this.comboBox1.DroppedDown = true; } 这个代码可以实现模糊匹配，但是有个诡异的错误，就是当你输入某些内容先匹配到，但是最后却没有匹配项就会报错。打个比方，你想输入“张四”，数据源中有“张三”，你先输入“张”，然后出现所有带有“张”的匹配项，然后你在输入“四”，则没有了匹配项，则会出现报错，报错信息如下:
************** 异常文本 ************** System.ArgumentOutOfRangeException: InvalidArgument=“0”的值对于“index”无效。 参数名: index 在 System.Windows.Forms.ComboBox.ObjectCollection.get_Item(Int32 index) 在 System.Windows.Forms.ComboBox.get_Text() 在 System.Windows.Forms.ComboBox.WmReflectCommand(Message&amp;amp; m) 在 System.Windows.Forms.ComboBox.WndProc(Message&amp;amp; m) 在 System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam) 我在网上找，一直找不到原因，我也找不到这个问题具体错在什么地方。要吐槽的是这个Textupdate事件根本没办法调试，因为当你输入第一个字匹配之后，他就会默认选择第一项从而进入selectchange事件，也就没办法调试了，后来苦苦思索终于想到一个解决方法，虽然不知道原因，但终究还是解决了。就是当combobox没有匹配项的时候，就在它的下拉框添加空字符串，这样就能组织报错了，稍微改了一下代码就可以了。</description>
    </item>
    
    <item>
      <title>微软Visual Studio Code基本特征</title>
      <link>https://madneal.com/post/%E5%BE%AE%E8%BD%AFvisual-studio-code%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/</link>
      <pubDate>Sat, 02 May 2015 07:09:46 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%BE%AE%E8%BD%AFvisual-studio-code%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/</guid>
      <description>Visual Studio Code它的核心功能还是作为一个代码编辑器。和其他的代码编辑器一样，VScode采取通用的UI和布局，浏览器在左边，显示所有的文件和文件夹，右边你打开的文件的编辑页面。
文件，文件夹以及项目 VScode是基于文件和文件夹的，你可以立即开始通过打开一个文件和文件夹。除了这些，VScode能够读不同框架和平台定义的项目文件。比如，如果你打开的文件夹包含一个或者多个package.json，project.json，tsconfig.json,或者ASP.NET 解决方案和项目文件，VScode可以读取这些文件并且利用他们来提供额外的功能比如代码补全功能。
打开VScode 你可以从命令行利用VScode打开文件，文件夹或者项目。 打开VScode中的一个index.html文件：
code index.html 打开文件夹c:\src\Contents：
code c:\src\contents VScode中并不区分是打开文件夹还是打开项目。如果你打开的文件夹包含项目文件，VScode会读取这些文件并且显示这些项目内容在状态栏中。在这你也可以进行不同的项目之间的切换。 打开文件夹c:src\WebApp中包含的项目：
code c:\src\webapp 换句话说，打开包含项目的文件夹能够有效地打开项目： 打开当前文件夹：
code . 基本布局 VScode布局简单，能够最大化编辑界面并且也能够留下足够的空间浏览文件夹或者项目的内容。UI可以分成四个部分
 编辑器 最主要地区域编辑文件。最多可以打开三个编辑页面。 边栏 包括不同的视图，比如你在处理项目时候地浏览器 状态栏 显示你正在打开项目和文件的状态 视图栏 可以让你在不同的视图中进行切换  每次你打开VScode都会恢复到上一次关闭的状态。文件夹布局如下所示。 不是把文件放在不同的tab之中，VScode可以最多同时打开3个编辑器。
并排编辑 你可以最多可以并排打开3个编辑器。 如果你已经有一个编辑器打开，你可以通过各种不同的途径打开另外的编辑器。
 Ctrl 在浏览器中打开一个文件 comman+\ 将编辑器分成两个 无论何时你打开另外一个文件，编辑器将会激活正在打开的文件。  </description>
    </item>
    
    <item>
      <title>如何将网络流转化为内存流 C#</title>
      <link>https://madneal.com/post/%E5%A6%82%E4%BD%95%E5%B0%86%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%86%85%E5%AD%98%E6%B5%81-c#/</link>
      <pubDate>Tue, 28 Apr 2015 11:45:14 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%A6%82%E4%BD%95%E5%B0%86%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%86%85%E5%AD%98%E6%B5%81-c#/</guid>
      <description>//将获取的文件流转化为内存流 public static MemoryStream ConvertStreamToMemoryStream(Stream stream) { MemoryStream memoryStream = new MemoryStream(); if (stream != null) { byte[] buffer = ReadFull(stream); if (buffer != null) { var binaryWriter = new BinaryWriter(memoryStream); binaryWriter.Write(buffer); } } return memoryStream; } public static byte[] ReadFull(Stream input) { byte[] buffer = new byte[16 * 1024]; using (MemoryStream ms = new MemoryStream()) { int read; while ((read = input.Read(buffer, 0, buffer.Length)) &amp;gt; 0) { ms.Write(buffer, 0, read); } return ms.</description>
    </item>
    
    <item>
      <title>datagridview里面的checkbox全选和取消全选</title>
      <link>https://madneal.com/post/datagridview%E9%87%8C%E9%9D%A2%E7%9A%84checkbox%E5%85%A8%E9%80%89%E5%92%8C%E5%8F%96%E6%B6%88%E5%85%A8%E9%80%89/</link>
      <pubDate>Wed, 22 Apr 2015 10:25:19 +0000</pubDate>
      
      <guid>https://madneal.com/post/datagridview%E9%87%8C%E9%9D%A2%E7%9A%84checkbox%E5%85%A8%E9%80%89%E5%92%8C%E5%8F%96%E6%B6%88%E5%85%A8%E9%80%89/</guid>
      <description>全选 设置全选button，选中所有的checkbox
 private void selectAll_Click(object sender, EventArgs e) { //遍历datagridview中的每一行，判断是否选中，若为选中，则选中 for (int i = 0; i &amp;lt; dataGridView1.Rows.Count; i++) { if ((Convert.ToBoolean(dataGridView1.Rows[i].Cells[0].Value) == false)) { dataGridView1.Rows[i].Cells[0].Value = &amp;#34;True&amp;#34;; } else continue; } } 取消全选 设置取消全选button，取消选中的所有checkbox
 private void cancelAll_Click(object sender, EventArgs e) { for (int i = 0; i &amp;lt; dataGridView1.Rows.Count; i++) { if ((Convert.ToBoolean(dataGridView1.Rows[i].Cells[0].Value) == true)) { dataGridView1.Rows[i].Cells[0].Value = &amp;#34;False&amp;#34;; } else continue; } } </description>
    </item>
    
    <item>
      <title>独立成分分析（Independent Component Analysis）</title>
      <link>https://madneal.com/post/%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90independent-component-analysis/</link>
      <pubDate>Sun, 19 Apr 2015 12:52:51 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90independent-component-analysis/</guid>
      <description>ICA是一种用于在统计数据中寻找隐藏的因素或者成分的方法。ICA是一种广泛用于盲缘分离的(BBS)方法，用于揭示随机变量或者信号中隐藏的信息。ICA被用于从混合信号中提取独立的信号信息。ICA在20世纪80年代提出来，但是知道90年代中后期才开始逐渐流行起来。 ICA的起源可以来源于一个鸡尾酒会问题，我们假设三个观测点x1,x2,x3,放在房间里同时检测三个人说话，另三个人的原始信号为s1,s2,s3，则求解的过程可以如下图所示：
定义 假设n个随机变量x1,x2,&amp;hellip;.xn,由n个随机变量s1,s2,&amp;hellip;sn组成，并且这n个随机变量是相互独立的，可以用下面的公示表达： 为了表达的方便，我们可以用向量的形式来表达： x = As 这个只不过是ICA最基本的定义，在很多实际问题中，应该包含了噪声。但是为了简化问题，我们这里忽略了噪声。因为如果模型中包含噪音，处理起来将会十分困难，而且大多数不包含噪音的模型已经能够解决很多问题，所以这里我们就将噪声先忽略。
ICA的限制条件  独立成分应该是相互之间独立的。这是ICA成立的基本原则，同时，基本上可以说只需要这个原则我们就可以估计这个模型。 独立成分必须是非高斯分布的。高斯分布的高阶累计量是0，但是高阶信息对于ICA的模型的估计却是十分必要的。 为了简化，我们假设未知的混合矩阵A是一个方阵。  白化 白化是一种比不相关性要稍微强一些的性质。对一个零均值的随即向量y进行白化处理，就是让它的组成成分不相关，并且让变量的方差相等。也就是说，变量y的协方差矩阵是单位矩阵： 为什么独立成分是非高斯的 ICA最基本的限制条件就是独立成分必须是非高斯分布的，这或许也是ICA早期没有流行起来的原因。我们假设变量x1和x2是高斯分布的，不相关的，且方差相等： 下面的图表示联合概率分布，可以看出，我们无法判断任何关于变量x1和x2的方向信息，这就是为什么混合矩阵A不能被估计出来的原因： 峭度 在这我们讲述一个利用峭度来进行ICA模型估计的方法，ICA的估计方法很多，这只是最基础的一个方法。 对于变量y峭度可以由下面的公式定义： 峭度是可正可负的，高斯分布变量的峭度是0，这也是为什么独立成分必须是非高斯分布的原因之一。峭度为负的变量分布称为次高斯分布，峭度为正的变量的分布则为超高斯分布，下图分别是拉普拉斯分布（超高斯分布）和均匀分布（次高斯分布）： 基于峭度的梯度算法 我们经常利用峭度的绝对值或者平方来进行求解： 我们通过优化这个目标函数来估计ICA模型，z表示白化后的观察数据x。 实际上，我们是使峭度极大化。我们会从某个方向向量w开始，然后计算在什么方向峭度的增长最快，我们则将方向向量w向这个方向移动。 峭度绝对值的梯度可以如下计算： 下面是一个快速不动点算法基于峭度计算的流程图： ## ICA估计的主要方法 ##   通过极大化非高斯性来估计 通过极大似然性来估计 通过极小互信息来估计 通过张量的方法来估计 通过非线性分解和非线性PCA来估计 这里，我们只是讲了其中的一个基础方法之一，并不就是最好的方法。  ICA算法的思想可以用下面的公式来描述： ICA method = objective funtion + optimization algorithm
引用 [1]Hyvärinen A, Karhunen J, Oja E. Independent component analysis[M]. John Wiley &amp;amp; Sons, 2004. [2]Hyvärinen A, Oja E. Independent component analysis: algorithms and applications[J].</description>
    </item>
    
    <item>
      <title>CHEVP算法（CannyHough Estimation of Vanishing Points)</title>
      <link>https://madneal.com/post/chevp%E7%AE%97%E6%B3%95cannyhough-estimation-of-vanishing-points/</link>
      <pubDate>Sat, 18 Apr 2015 19:38:02 +0000</pubDate>
      
      <guid>https://madneal.com/post/chevp%E7%AE%97%E6%B3%95cannyhough-estimation-of-vanishing-points/</guid>
      <description>这个算法是汪悦在 Lane detection and tracking using B-spline中提出来的。他在这篇论文中主要用的是B-spline模型，这个模型的主要优点是鲁棒性好，可以针对不同的情景进行处理，而且他将检测道路两边的边缘的问题转化成求解道路中间线的问题。 下面主要描述一下CHEVP算法：
 边缘像素提取 我们使用Canny边缘检测来获得边缘映射和边缘定位映射。选择方差σ = 1 并且模板的尺寸是9*1在X方向和Y方向上进行高斯卷积。边缘映射是通过一个合适的阈值处理得到的结果。在图表1中，图b是通过Canny边缘检测得到的边缘映射，图c则是边缘定位映射。  通过霍夫变化检测直线 检测到的边缘点将被用于对直线参数空间中可能的存在的线进行投票。图像被水平地分为几个部分，如图2a所示，为了适应因为道路弯曲从而导致道路消失点的变化。图像部分自下而上高度越来越小。每个图像分割部分都有它们自己的直线参数空间，每个图像分割部分中边缘点分别为可能的直线进行投票。通过对于规范化后的累加空间的阈值处理，直线分割最终能够在每一个图像分割部分中检测出来。  地平线和消失点检测 每一个图像分割部分中检测到的直线都是成对出现的，任意一队直线的相交部分会为另外一个霍夫空间中的消失点进行投票。投票的权重是根据最后一步产生的成对直线的规范化累加值决定的。这个过程在每个图像分割部分中分别重复，但是会在相同的霍夫空间中投票。 霍夫空间中对于每一列的投票会归总起来从来检测可能的消失点。获得投票最多的一行将会被选择座位地平线在图像平面中，如下图所示： 对于每个图像分割部分来说，它的消失点由地平线附近投票最多的点所决定。所有检测到的消失点可以再图4b中看到。注意一点，对于图像部分5，没有消失点存在，因为在这个图像分割部分并没有检测到直线。  根据检测的道路线估计道路中间线的参数k 对于消失点进行投票的直线被认为是每个图像分割部分中道路线。从图像最下面的图像分割部分往上，挑选出在各个图像分割部分中的左右两边挑选出最接近去中间一列的检测到的道路线。如果这两条道路线在这个图像分割部分中并不存在，这个过程就会在更高的图像分割部分中进行，知道获得需要的道路线。图6表示两条直线L1和L2在图像分割部分4中，因为没有直线存在图像分割部分5中。 然后连接图像分割部分4中的消失点和P-l4和P-r4的中点P-m4（直线L1和直线L2的相交的部分） 参数k可以通过以下公式进行估计： 对于图7中中间线的估计的例子如下所示： 从图像分割部分4开始，因为图像分割部分5中不存在消失点，我们假设这个部分的消失点跟在分割部分4中的消失点。延伸通过vp4和P-m4交于图像分割部分5的P-m5点。同样的，我们在图像分割部分3中我们也能够检测到消失点。直线（vp3-P-m3)交于图像分割部分2的底部的P-m2处。同样的道理，适用于以上的部分 通过构建道路中间线，通过参数k和道路中间线我们可以估计处道路的两条边缘线，图8给出了例子  计算道路模型的控制点来接近检测的道路中间线 可以利用很多方法来计算B-spline中的控制点通过中间线。因为B-spline后面的部分会准确地逼近道路边缘，这里我们只是粗略地使用B-spline来接近检测到的道路中间线。 我们是通过使用3个不同的控制点来构成两个部分的B-spline。为了让B-spline通过第一个和最后一个控制点，我们使用三倍的第一个和最后一个控制点。因此事实上一共有7个控制点，3个第一个控制点和3个最后一个控制点都是相同的。 我们首先选择P-m0和P-m5分别代表道路模型中的第一个控制点Q0和最后一个控制点Q2.节点P1的选择取决于图9中β1和β2的值。如果β1和β2的值不等于0，我们则选择P-m作为Q1。即P1=P-m，P-m是P-m1和P-m2的中点。如果β1为0，而β2不等于0.我们则选择P-m1作为P1(Q1).其他的情况，我们则选择P-m2作为P1(Q1).因此控制点Q1可以通过下面的公式计算： ![控制点初始化] (http://img.blog.csdn.net/20150418193033394)![道路模型初始化](http://img.blog.csdn.net/20150418193239246)  实验结果## 引用： Wang, Yue, Eam Khwang Teoh, and Dinggang Shen. &amp;ldquo;Lane detection and tracking using B-Snake.&amp;rdquo; Image and Vision computing 22.4 (2004): 269-280.</description>
    </item>
    
    <item>
      <title>winform中进行post上传文件</title>
      <link>https://madneal.com/post/winform%E4%B8%AD%E8%BF%9B%E8%A1%8Cpost%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 17 Apr 2015 18:04:50 +0000</pubDate>
      
      <guid>https://madneal.com/post/winform%E4%B8%AD%E8%BF%9B%E8%A1%8Cpost%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</guid>
      <description>winform中要上传文件到远程的服务器上面，我在本地用的是post方式传递数据，用的是HTTP协议，具体代码如下： 下面的代码就是一个上传的方法，参数需要路径和文件路径就可以了，我本地winform只需要提交post请求就可以了，止于对于post请求如何处理，那就是远程服务端的事情了。
 private string uploadFile(string uriAddress, string uploadfilePath) { HxSpecCore.SpectrumSet ss = new SpectrumSet(); try { // 设置提交的相关参数 HttpWebRequest request = WebRequest.Create(uriAddress) as HttpWebRequest; Encoding myEncoding = Encoding.UTF8; request.Method = &amp;#34;POST&amp;#34;; WebHeaderCollection headers = request.Headers; //提交请求数据 FileInfo fi = new FileInfo(uploadfilePath); FileStream fs = new FileStream(uploadfilePath, FileMode.Open, FileAccess.Read); byte[] postData = new byte[(int)fs.Length]; request.Headers.Set(&amp;#34;md5data&amp;#34;, Convert.ToBase64String(GetMD5(Convert.ToBase64String(GetMD5(Encoding.Default.GetString(postData))) ))); fs.Read(postData, 0, Convert.ToInt32(fs.Length)); fs.Close(); System.IO.Stream outputStream = request.GetRequestStream(); outputStream.Write(postData, 0, postData.Length); outputStream.Close(); HttpWebResponse response; Stream responseStream; response = request.</description>
    </item>
    
    <item>
      <title>sqlite操作</title>
      <link>https://madneal.com/post/sqlite%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 15 Apr 2015 15:48:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/sqlite%E6%93%8D%E4%BD%9C/</guid>
      <description>导入excel到表格 本来想使用sqlite expert personal导入表格的，后来发现软件里面没有import/export菜单，后来问只有professional版本才有这个菜单的，我晕，穷人那只能敲命令行了。 注意导入的excel表格是要把表头给去掉的，然后按照sqlite表格里面标头的顺序进行导入，excel的表格用csv的格式来保存。
sqlite3 .separator &amp;#39;,&amp;#39; .import filename tablename 导入文件乱码 经常会出现导入的文件的中文出现乱码的情况，建议就是把文件用记事本打开，然后用UTF-8的格式另存为csv的文件。
datatime()函数时间出错 使用sqlite数据库时，使用datatime函数获取当前时间的时候，时间总是错误的，总是晚了好几个小时，结果在datatime()函数里面加上参数就好了，datetime(&amp;rsquo;now&amp;rsquo;,&amp;rsquo;localtime&amp;rsquo;)。
database is locked 读完数据库一定要关闭，无论是reader还是dataset，必须统统都要close</description>
    </item>
    
    <item>
      <title>Iplimage versus Mat</title>
      <link>https://madneal.com/post/iplimage-versus-mat/</link>
      <pubDate>Wed, 15 Apr 2015 12:08:20 +0000</pubDate>
      
      <guid>https://madneal.com/post/iplimage-versus-mat/</guid>
      <description>我们可能经常面临这样的困惑，Iplimage和Mat这两种数据结构，我们应该用哪一种数据结构。 Iplimage一开始就存在opencv库之中，他来源于Intel的另外一个函数库Intel Image Processing Library(IPL)，这是一种非常重要的数据结构。在经典书籍里面的sample用的基本都是Iplimage这个数据结构。但是这是一种C风格的数据结构，你必须为他分配以及释放内存。 Mat则是一种新的数据结构，越来越多的人也在使用这种数据结构了，因为它是面向对象的。所以我们不需要自己来为它管理内存。它是通过计数的方式来进行引用，如果它的引用计数为0的话，那么它就会自动释放内存。 老实说，用什么数据结构，我也不知道。因为我觉得有些方法，Mat数据结构还不具备，有的方法只有运用Iplimage才可以。
将Iplimage转化为Mat IplImage* ipl; Mat m = cvarrToMat(ipl); </description>
    </item>
    
    <item>
      <title>道路识别demo</title>
      <link>https://madneal.com/post/%E9%81%93%E8%B7%AF%E8%AF%86%E5%88%ABdemo/</link>
      <pubDate>Wed, 15 Apr 2015 09:55:48 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%81%93%E8%B7%AF%E8%AF%86%E5%88%ABdemo/</guid>
      <description>最近做的道路识别一开始终于弄懂了点东西，一开始在网上找到了一个简单的道路识别的opencvsharp的版本。我觉得opencvsharp真的是一个很好的东西，它封装了比opencv更多的数据结构和库，而且得益于.net平台的强大，使用起来也非常的便捷。唯一的缺点就是目前关于这方面的资料还是少之又少，后来我还是想一想把这个demo转换成cpp版本，也是一个非常简单的demo。
opencvsharp版本 using System; using System.Collections.Generic; using System.Linq; using System.Windows.Forms; using OpenCvSharp; namespace LaneDetection { class Program { [STAThread] static void Main() { CvCapture cap = CvCapture.FromFile(&amp;#34;test1.mp4&amp;#34;); CvWindow w = new CvWindow(&amp;#34;Lane Detection&amp;#34;); CvWindow canny = new CvWindow(&amp;#34;Canny&amp;#34;); IplImage src, gray, dstCanny, halfFrame, smallImg; CvMemStorage storage = new CvMemStorage(); CvSeq lines; while (CvWindow.WaitKey(10) &amp;lt; 0) { src = cap.QueryFrame(); halfFrame = new IplImage(new CvSize(src.Size.Width / 2, src.Size.Height / 2), BitDepth.U8, 3); Cv.</description>
    </item>
    
    <item>
      <title>combox系列问题集</title>
      <link>https://madneal.com/post/combox%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E9%9B%86/</link>
      <pubDate>Tue, 14 Apr 2015 09:04:09 +0000</pubDate>
      
      <guid>https://madneal.com/post/combox%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E9%9B%86/</guid>
      <description>visual studio崩溃 你是不是经常会遇到一编辑combox，visual studio就会立马崩溃。一直都无法理解是什么原因，然后后来发现居然是因为有道的截屏翻译，关掉截屏翻译就好了。
combox绑定数据源  SqliteDataReader dr; if (dr.Read()) { this.comboBox1.Items.Add(dr[0]); } 自动补全的功能 我们希望在combox中实现输入的时候，有推荐的文本自动补全功能。我们主要只需要设置AutoCompleteMode和AutoCompleteSource这两个属性就可以了。
模糊查询 上面那个自动补全的功能只能实现从左到右进行匹配，而不能进行模糊匹配。假设我们的combobox里面有“张三“，如果输入”张“可以进行匹配，但是我们如果输入”三“的话就无法实现匹配，而combobox自身并没有这个属性，所以我们需要自己写一个方法来实现。
 List&amp;lt;string&amp;gt; listOnit = new List&amp;lt;string&amp;gt;(); List&amp;lt;string&amp;gt; listNew = new List&amp;lt;string&amp;gt;(); //用于模糊查询 private void BindComboBox() { string str = &amp;#34;select License from tb_drug&amp;#34;; SQLiteDataReader sdr = sh.getcom(str); while (sdr.Read()) { if (sdr[0].ToString() != &amp;#34; &amp;#34; &amp;amp;&amp;amp; sdr[0].ToString() != null) listOnit.Add(sdr[0].ToString()); } sdr.Close(); this.comboBox1.Items.AddRange(listOnit.ToArray()); } private void comboBox1_TextUpdate(object sender, EventArgs e) { this.comboBox1.Items.Clear(); listNew.Clear(); foreach (var item in listOnit) { if (item.</description>
    </item>
    
    <item>
      <title>初识NuGet</title>
      <link>https://madneal.com/post/%E5%88%9D%E8%AF%86nuget/</link>
      <pubDate>Sun, 12 Apr 2015 16:32:36 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%88%9D%E8%AF%86nuget/</guid>
      <description>因为想查一查opencvsharp的东西，然后发觉这个包可以再NuGet上面可以直接下载。我也经常在很多地方都可以看到NuGet，所以我想写下来，记录下来。 NuGet是一个免费的并且开源的包管理器在微软的开发平台上。NuGet发布在Visual Studio的拓展插件上。 NuGet现在已经移植到代码管理平台github了，链接地址为https://github.com/nuget/home。他们打算以后新的东西都在这个网址更新了。
资源 NuGet Gallery: http://nuget.org Documentation: http://docs.nuget.org Blog: http://blog.nuget.org Twitter: @nuget JabbR chat: https://jabbr.net/#rooms/nuget TeamCity continuous build server: http://build.nuget.org Latest successful VS Extension build: http://build.nuget.org/NuGet.Tools.vsix Latest successful NuGet.exe build: http://build.nuget.org/NuGet.exe
NuGet貌似自从vs2012版本之后就默认在系统中了，所以不需要再安装了。如果想确保你的版本有没有安装NuGet，你可以看一下工具栏。你也可以在扩展和更新中可以进行NuGet的更新和管理。 只要你安装了，就可以非常方便的引用第三方的库，直接在引用里面添加就可以了。</description>
    </item>
    
    <item>
      <title>回调函数</title>
      <link>https://madneal.com/post/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 12 Apr 2015 13:43:26 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>回调函数 在计算机程序设计中，回调函数，是指通过函数参数传递到其他代码的，某一块可执行代码的引用。这一设计允许了底层的代码调用高层的子程序。回调函数在.net平台中相当于委托。
回调函数的机制  定义一个回调函数。 提供函数实现的一方在初始化的时候，将回调函数的函数指针给调用者。 当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。  为什么要使用回调函数 因为可以把调用者和被调用者分开，所以调用者不关心谁是被调用者。它只需要知道存在一个具有特定原型和限制条件的被调用函数。
代码实现 下面创建了一个sort.dll的动态链接库，它导出了一个名为CompareFunction的类型&amp;ndash;typedef int (__stdcall CompareFunction)(const byte,const byte*），它就是回调函数的类型。另外，它也导出了两个方法：Bubblesort（）和Quicksort（），这两个方法原型相同，但实现了不同的排序算法。
void DLLDIR __stdcall Bubblesort(byte* array,int size,int elem_size,CompareFunction cmpFunc); void DLLDIR __stdcall Quicksort(byte* array,int size,int elem_size,CompareFunction cmpFunc); 这两个函数接受以下参数：
·byte * array：指向元素数组的指针（任意类型）。
·int size：数组中元素的个数。
·int elem_size：数组中一个元素的大小，以字节为单位。
·CompareFunction cmpFunc：带有上述原型的指向回调函数的指针。
回调函数实例 int __stdcall CompareInts(const byte* velem1,const byte* velem2) { int elem1 = *(int*)velem1; int elem2 = *(int*)velem2; if(elem1 &amp;lt; elem2) return -1; if(elem1 &amp;gt; elem2) return 1; return 0; } int __stdcall CompareStrings(const byte* velem1,const byte* velem2) { const char* elem1 = (char*)velem1; const char* elem2 = (char*)velem2; return strcmp(elem1,elem2); } int main(int argc,char* argv[])</description>
    </item>
    
    <item>
      <title>opencv视频流的读取和处理</title>
      <link>https://madneal.com/post/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 12 Apr 2015 13:16:58 +0000</pubDate>
      
      <guid>https://madneal.com/post/opencv%E8%A7%86%E9%A2%91%E6%B5%81%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%A4%84%E7%90%86/</guid>
      <description>Opencv提供一个简单易用的框架以提取视频文件和USB摄像头中的图像帧，如果只是想读取某个视频，你只需要创建一个VideoCapture实例，然后在循环中提取每一帧。下面是一个简单的代码  #include&amp;lt;opencv2\core\core.hpp&amp;gt; #include&amp;lt;opencv2\imgproc\imgproc.hpp&amp;gt; #include&amp;lt;opencv2\highgui\highgui.hpp&amp;gt; #include&amp;lt;iostream&amp;gt; using namespace cv; using namespace std; int main() { VideoCapture capture(&amp;#34;d:\\road.avi&amp;#34;); //检测视频是否读取成功 if (!capture.isOpened()) { cout &amp;lt;&amp;lt; &amp;#34;No input image&amp;#34;; return 1; } //获取图像帧率 double rate = capture.get(CV_CAP_PROP_FPS); bool stop = false; Mat frame; namedWindow(&amp;#34;Example&amp;#34;); int delay = 1000/rate; while (!stop) { if (!capture.read(frame)) break; imshow(&amp;#34;Example&amp;#34;,frame); if (waitKey(delay) &amp;gt;= 0) stop = true; } return 0; } 要正确地打开视频文件必须确保电脑具有相应的解码器。同时也应该注意文件路径的未知是否正确，路径为止错误经常也会提示错误warning: Error opening file (../../modules/highgui/src/cap_ffmpeg_impl.hpp:545)。这个错误一般都是文件路径错误而导致的。
处理视频帧 为了对视频中的每一帧进行处理，我们可以创建自己的类VideoProcessor,其中封装OopenCV的视频获取框架，该类允许我们制定每帧调用的处理函数。 首先，我们希望制定一个回调处理函数，（关于回调函数，另外一个帖子http://blog.</description>
    </item>
    
    <item>
      <title>歌德巴赫猜想</title>
      <link>https://madneal.com/post/%E6%AD%8C%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/</link>
      <pubDate>Sat, 11 Apr 2015 18:16:39 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E6%AD%8C%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3/</guid>
      <description>题目 Description
歌德巴赫猜想，是指对于每一个大于4的偶数ｎ，都能表示成两个质数之和。 现在，你需要写程序验证这一猜想。对于n，找出质数a和b, 满足a+b=n, a≤b，且a*b最大。例如n=8，满足条件的a和b分别为3和5； 又如n=10，质数3、7以及5、5满足a+b=n, a≤b，而乘积大的那组是5、5。 Input
每行一个偶数n（4 &amp;lt; n &amp;lt;= 20000）
Output
对应于每个输入的偶数，输出a、一个空格、b、一个换行符
Sample Input
8 10 1000 Sample Output
3 5 5 5 491 509
代码 #include&amp;lt;stdio.h&amp;gt; #include&amp;lt;math.h&amp;gt; bool isPrime(int x); int main() { int n,i,j; while (scanf(&amp;#34;%d&amp;#34;,&amp;amp;n) != EOF) { for (i = n/2;i &amp;gt; 0;i -= 2) { if(i%2 == 0) i --; j = n - i; if(isPrime(i)&amp;amp;&amp;amp;isPrime(j)) { printf(&amp;#34;%d %d\n&amp;#34;,i,j); break; } } } return 0; } bool isPrime(int x) { int len = sqrt((float)x); for (int i = 2;i &amp;lt;= len;i ++) { if(x % i == 0) return false; } return true; } </description>
    </item>
    
    <item>
      <title>道路识别</title>
      <link>https://madneal.com/post/%E9%81%93%E8%B7%AF%E8%AF%86%E5%88%AB/</link>
      <pubDate>Sat, 11 Apr 2015 13:29:14 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E9%81%93%E8%B7%AF%E8%AF%86%E5%88%AB/</guid>
      <description>我们老板希望我能在道路识别这个方面做一些东西，这方面的东西一直在看，但是一直都是模模糊糊，我希望自己能够用一个合适的方式总结一下道路识别的问题。
道路识别问题其实也正正恰好是识别问题中的一个方面，所以道路识别问题的关键也是在于如何选取一个特征来进行识别。道路识别问题可以使用不同的方法来解决，我打算从下面这些方面来阐述一下我自己对道路识别的一个理解：
  我们要解决什么情况下的道路问题 其实我觉得这点挺重要的，因为很多计算机视觉的问题在不同的要求之下有各种各样的方法。我觉得很有必要弄清楚自己需要的目标，我是要解决什么样的问题。道路识别问题可以分为结构化的道路和非结构化的道路。结构化的道路就是比较标准的道路，有着清晰地道路线，高速公路，城市公路，这些都是典型的结构化道路。而非结构化道路就是往往没有规则，没有明显的道路线或者根本没有道路线，显然，这样的道路识别比较复杂。因为我自己还是一个菜鸟，所以我一直以来看的问题都是针对结构化的道路。
  我们用什么样的特征来识别道路 我们道路识别是通过道路的特征来识别道路，要么或者道路线，或者区域什么的。我们通常所使用的方法就是检测道路线，比如道路之间的道路线，或者道路边缘。特征，我觉得就可以分为多个特征，包括边缘特征，纹理特征，颜色特征等等。道路线的检测，往往相当于一个边缘检测的问题，往往是等同于直线的检测。所以霍夫变换经常是应用于道路检测中。
  我们要以什么样的方法来解决道路识别问题 设想我们在汽车上设置一个摄像头，在不停的获取道路的实时数据。我们如何通过对道路视频进行实时的相应处理从而帮助我们驾驶。道路识别现如今已经慢慢应用到辅助驾驶系统中，在国外已经有一些不少的成熟应用，但只是至今还未达到高度商业化的地步。而且这个问题在未来的无人驾驶肯定也是有着一席之地。我所了解的基本都是基于对视频图像的处理从而来解决道路是别的问题。
  </description>
    </item>
    
    <item>
      <title>计算机视觉领域的一些牛人博客，超有实力的研究机构等的网站链接</title>
      <link>https://madneal.com/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E9%A2%86%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B6%85%E6%9C%89%E5%AE%9E%E5%8A%9B%E7%9A%84%E7%A0%94%E7%A9%B6%E6%9C%BA%E6%9E%84%E7%AD%89%E7%9A%84%E7%BD%91%E7%AB%99%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Sat, 11 Apr 2015 12:47:41 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E9%A2%86%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%9B%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B6%85%E6%9C%89%E5%AE%9E%E5%8A%9B%E7%9A%84%E7%A0%94%E7%A9%B6%E6%9C%BA%E6%9E%84%E7%AD%89%E7%9A%84%E7%BD%91%E7%AB%99%E9%93%BE%E6%8E%A5/</guid>
      <description>转载：http://blog.csdn.net/carson2005/article/details/6601109
提示：本文为笔者原创，转载请注明出处：blog.csdn.net/carson2005
 以下链接是本人整理的关于计算机视觉（ComputerVision, CV）相关领域的网站链接，其中有CV牛人的主页，CV研究小组的主页，CV领域的paper,代码，CV领域的最新动态，国内的应用情况等等。打算从事这个行业或者刚入门的朋友可以多关注这些网站，多了解一些CV的具体应用。搞研究的朋友也可以从中了解到很多牛人的研究动态、招生情况等。总之，我认为，知识只有分享才能产生更大的价值，真诚希望下面的链接能对朋友们有所帮助。  （1）googleResearch； http://research.google.com/index.html （2）MIT博士，汤晓欧学生林达华； http://people.csail.mit.edu/dhlin/index.html （3）MIT博士后Douglas Lanman； http://web.media.mit.edu/~dlanman/ （4）opencv中文网站； http://www.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5 （5）Stanford大学vision实验室； http://vision.stanford.edu/research.html （6）Stanford大学博士崔靖宇； http://www.stanford.edu/~jycui/ （7）UCLA教授朱松纯； http://www.stat.ucla.edu/~sczhu/ （8）中国人工智能网； http://www.chinaai.org/ （9）中国视觉网； http://www.china-vision.net/ （10）中科院自动化所； http://www.ia.cas.cn/ （11）中科院自动化所李子青研究员； http://www.cbsr.ia.ac.cn/users/szli/ （12）中科院计算所山世光研究员； http://www.jdl.ac.cn/user/sgshan/ （13）人脸识别主页； http://www.face-rec.org/ （14）加州大学伯克利分校CV小组； http://www.eecs.berkeley.edu/Research/Projects/CS/vision/
（15）南加州大学CV实验室； http://iris.usc.edu/USC-Computer-Vision.html （16）卡内基梅隆大学CV主页；
http://www.cs.cmu.edu/afs/cs/project/cil/ftp/html/vision.html
（17）微软CV研究员Richard Szeliski；http://research.microsoft.com/en-us/um/people/szeliski/ （18）微软亚洲研究院计算机视觉研究组； http://research.microsoft.com/en-us/groups/vc/ （19）微软剑桥研究院ML与CV研究组； http://research.microsoft.com/en-us/groups/mlp/default.aspx
（20）研学论坛； http://bbs.matwav.com/ （21）美国Rutgers大学助理教授刘青山； http://www.research.rutgers.edu/~qsliu/ （22）计算机视觉最新资讯网； http://www.cvchina.info/ （23）运动检测、阴影、跟踪的测试视频下载； http://apps.hi.baidu.com/share/detail/18903287 （24）香港中文大学助理教授王晓刚； http://www.ee.cuhk.edu.hk/~xgwang/ (25)香港中文大学多媒体实验室（汤晓鸥）; http://mmlab.ie.cuhk.edu.hk/ (26)U.C. San Diego. computer vision;http://vision.ucsd.edu/content/home (27)CVonline; http://homepages.inf.ed.ac.uk/rbf/CVonline/ (28)computer vision software; http://peipa.essex.ac.uk/info/software.html (29)Computer Vision Resource; http://www.</description>
    </item>
    
    <item>
      <title>关于计算机视觉研究</title>
      <link>https://madneal.com/post/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Sat, 11 Apr 2015 12:44:04 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6/</guid>
      <description>本文是UCLA教授朱松纯的见解，我翻译下作为见解，尽管以后不一定做这些东西，但我觉得这些道理还是有价值的。
  我们如何知道我们是不是在以错误的方式做研究？ 视觉问题是一个在现代科学以及工程上一个非常具有挑战性和潜力的问题，因为它非常复杂并且包罗万象。对于如此复杂的一个问题，我们必须十分谨慎地选择一个长期有效的解决方案以免走入一个死胡同中。人们喜欢享受能够感觉到的进程，但实际地研究过程就回事十分枯燥无味的在普通人的眼中。
  视觉问题是一个可以用机器学习来解决的分类问题吗？ 经常有些学生说：视觉问题是不是仅仅只是机器学习地应用而已，他们经常是这么觉得。如果是这样的话，那么对于视觉问题的研究者来说，他们的任务仅仅只是设计好的特征而已就可以了。这个问题真的是对视觉问题的侮辱，这反映了对与视觉问题的误解并将其简单的划分为分类问题。这对于我来说毫不奇怪，因为现在的年轻一代不仅不知道Ulf Genander（模式理论之父）同时也不知道David Marr（计算机视觉之父）。打个比方来说，机器学习的方法就好像是三千年来中国中国中药临床经验总结出来的方法。古代的人们由于对于现代医学缺乏足够的认知，他们往往尝试不同的药材组合，就像机器学习的研究者尝试不同的特征。这些成分通过不同的权重被混合在一起，然后通过煎煮最后变成一味中药，这是一个迭代回归的过程。据信这些药可以治疗一切疾病包括癌症，禽流感等等，而不需要理解这些药的生物作用或者相应的病理机制。所有你需要做的仅仅是找到正确的成分然后以合适的比例把它们混合在一起。理论上来说，这是现实可行的，就像机器学习保证可以解决所有问题如果机器学习能够找到足够的特征和例子。但是问题是：组成成分的范围如此之广，我们如何才能有效地找到合适的组成成分呢？对于视觉问题，我们需要研究图像的复杂的结构，以及丰富的空间和他们的组成部分，还有各种各样的模型和代表。
  为什么我们需要忍受不同风格的视觉问题？ 视觉问题中的方法论可以概括成三个部分：Hack, Math,Stat。Hacks是一种启发式的方法，或者是某种方法在某个问题可以起到作用，但是我们无法分辨出它到底在哪其作用。Math恰恰相反，它告诉我们在某种特定的条件下，事情可以在某种性能的保证下进行分析，但是这些条件经常是有限的，所以难以应用到现实世界中的通用场景中。Stat是一个回归过程。通过很多的参数，你最终可以拟合任何的数据但是缺乏足够的物理解释。所以这三者是不同等级的解释或者模型。
  如果你不能解决一个简单的问题，那么你就必须要解决一个复杂的问题！ 简化论是现代科学中很多领域中一个非常受欢迎的研究策略。经常说一个问题你可以把它分成几个小的组成部分或者一个复杂的系统是由几个不同的组成部分组成而来的。这些方法轮在十九世纪八十年代被一些视觉研究者所实践，比如边缘检测，分割等等。但是人们发现仅仅是边缘检测这样最简单的问题都不能够很好的解决，因为边缘的定义取决不同等级的任务需求，即使是人类如果没有特定的任务等级也无法决定是否存在边缘。不象物理学家可以选择一个给定的规模或者现象来进行研究，计算机视觉研究者发现他们自己非常的不幸：每一个简单的图像对于不同的等级包含了很多的模式以及任务。下面的表格包含了一系列我们需要解决的问题对于理解一幅图像来说。
  </description>
    </item>
    
    <item>
      <title>OPENCV</title>
      <link>https://madneal.com/post/opencv/</link>
      <pubDate>Sat, 11 Apr 2015 11:22:35 +0000</pubDate>
      
      <guid>https://madneal.com/post/opencv/</guid>
      <description>[转载] http://blog.csdn.net/carson2005/article/details/6979806
尽管之前写过一篇关于OpenCV的介绍（http://blog.csdn.net/carson2005/article/details/5822149），但依然有朋友对其不甚了解。所以，经常能碰到有人问我诸如以下一些问题：OpenCV能不能实现人脸识别？OpenCV有没有车辆检测的API？OpenCV有没有三维重建的函数？面对这样的问题，我也很困惑。到底该如何给他们解释，才能让它们明白，OpenCV确实很强大，但还没有他们想象中的那么强大。其实，OpenCV的全称，是Open source Computer Vision Library,开放源代码计算机视觉库。也就是说，它是一套关于计算机视觉的开放源代码的API函数库。这也就意味着，(1)不管是科学研究，还是商业应用，都可以利用它来作开发;(2)所有API函数的源代码都是公开的，你可以看到其内部实现的程序步骤；(3)你可以修改OpenCV的源代码，编译生成你需要的特定API函数。但是，作为一个库，它所提供的，仅仅是一些常用的，经典的，大众化的算法的API。一个典型的计算机视觉算法，应该包含以下一些步骤：(1)数据获取（对OpenCV来说，就是图片）；(2)预处理;(3)特征提取;(4)特征选择;(5)分类器设计与训练;(6)分类判别;而OpenCV对这六个部分，分别（记住这个词）提供了API。下面我分别就这六个部分对一些常见问题进行必要的解释。 对于数据获取，计算机视觉领域的数据，无非就是图片和视频两种。图片，有bmp,jpg,png,tiff&amp;hellip;.各种压缩和非压缩格式。所以，对压缩格式的图片而言，OpenCV内部必然包含了对应的图片解压缩函数(一般都是包含了开源的图片解压函数库，例如，对于jpg压缩格式而言，就包含了libjpg开源库)。而对于视频而言，常见的有.rmvb,.avi,.asf等格式，不同的格式，代表着不同的视频压缩算法(对于AVI格式，尽管都是avi格式，但内部的压缩算法仍然不相同。具体原因请参考我的另一篇博客:http://blog.csdn.net/carson2005/article/details/6314089)，也就需要对应的解压算法来解压。尽管OpenCV提供了一些读写视频文件的API，但是，它也仅仅是一个接口而已，其内部，依然需要调用相应的视频编解码器的API来进行解码。常用的视频编解码器有：xvid,ffmpeg等。也就是说，如果你想利用OpenCV来进行视频读写之类的操作，是需要安装此类视频编解码器的。安装了相应的视频解码器之后，你就可以调用OpenCV的视频相关API来进行视频文件的读取操作了，当然，视频文件被解码之后，变成了一张一张的图片，然后才能被OpenCV所处理。另外，还有一种情况，就是数据来自于相机，包括数字相机和模拟相机。不管是哪种相机，你都要想办法获取到相机发送给PC的图片数据（PC在内存里面接收到的来自相机的数据可能是jpg格式，也可能是bmp格式）。如果，你在PC内存中接收到的是相机发送过来的jpg压缩格式，还需要进行图片数据的内存解压。关于相机和OpenCV的这部分内容，请见我另一篇博客：
http://blog.csdn.net/carson2005/article/details/6243476
对于预处理，一般就是去除或者降低噪声，光照归一化，亮度归一化，模糊化，锐化，膨胀，腐蚀、开闭等这些操作（详见，冈萨雷斯，《数字图像处理》一书）。而对于这些操作，OpenCV分别(又提到这个词了)提供了相应API函数。而光照的预处理，OpenCV提供了一个直方图均衡化的API，后续可能会提供一些gammar矫正之类的函数。
对于特征提取，个人认为，可以算是整个计算机视觉系统中最为复杂也最难的部分（纯属个人意见，如有异议，请保留），到底什么是特征，该如何来理解这个看似简单却又包罗万象的名词呢？其实，要想仔细解释，还真的花费很多时间（有兴趣的可以看看，Richard O.Duda（著），李宏东（译），《模式识别》，机械工业出版社）。简单点说，特征，就是一个可以将若干个类别可以尽量分开的一种描述。举例来说，如果你要进行男人和女人的分类，显然，用“身高和体重”这一描述来衡量，是可以的，但是，这两个描述没有“胸部大小”这一描述更加准确，而“胸部大小”这一描述，又没有“喉结的有无”这一描述更准确。很显然，“身高和体重”，“胸部大小”，“喉结的有无”，这三种描述，都可以用来进行男人和女人的分类，只不过，它们对事物的描述的准确（或者说全面）程度是不同的，而诸如此类的描述，有一个更加专业的称谓，叫做“特征”。OpenCV里面，提供了一些特征描述的API，比如，对于人脸检测而言，它提供了haar特征的API，行人检测，提供了hog特征的API，甚至，它提供了LBP纹理特征的API。但是，这些还远远不够。例如，如果你要进行字符识别，OpenCV并没有提供字符识别所对应的特征。这个时候，就需要你自己来编程实现了。当然，该选择什么特征来描述字符呢？哪些特征更好呢？对于这些问题，我建议你去阅读相应的会议，期刊，杂志，硕士、博士毕业论文（毕竟硕士、博士研究生本就该从事“研究”工作），看看别人写的文章，自然就知道了。
对于特征选择，OpenCV并没有提供特定的函数来进行衡量。而特征的分类能力的高低评价，有很多种分析方法，有兴趣的朋友，可以阅读&amp;quot;《机器学习》Tom. Mitchell(著),曾华军(译)，机械工业出版社&amp;quot;这本书；
对于分类器部分，OpenCV提供了SVM,CART,boost,bayes,bdt,ANN,这几种常用的算法。而这些基本已经覆盖了常用的分类器。所以，你需要做的，就是知道怎么调用其接口，各种分类器的优点和缺点（该部分，建议阅读“机器学习”这本书）。
通过以上的分析，你或许已经发现，OpenCV不过是一个工具而已。或者，你可以将它理解为幼儿园小朋友过家家玩的积木，而OpenCV中的函数，则可以理解为一个一个的积木块，利用所有或者部分积木块，你可以快速的搭建起来具体的计算机视觉方面的应用（比如，字符识别，车牌识别，遗留物检测）。想必你也已经发现，在利用OpenCV这个积木来搭建具体的计算机视觉应用的时候，真正核心的，应该是这些积木块，如果你明白了积木块的工作原理，那么，是不是就可以不用这些积木块了呢？完全正确！不过，一般部分情况下，我们不需要这么做，因为，OpenCV已经帮你做好了一些工作（已经帮你做好了一些积木块，直接拿来用就是了）。但是，诸如前面提到的特征提取模块，很多情况下，OpenCV就无能为力了。这个时候，你就需要翻阅计算机视觉、模式识别、机器学习领域顶级会议、期刊、杂志上面发表的文章了。然后，根据这些文章中阐述的原理和方法，来编程实现你要的东西。实际上，也就等于搭建一个属于你私有的积木块。其实，OpenCV中的每一个API函数，也就是这么来的。</description>
    </item>
    
    <item>
      <title>ROT13加密和解密</title>
      <link>https://madneal.com/post/rot13%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Sat, 11 Apr 2015 10:16:26 +0000</pubDate>
      
      <guid>https://madneal.com/post/rot13%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/</guid>
      <description>问题 ROT13（回转13位）是一种简易的替换式密码算法。它是一种在英文网络论坛用作隐藏八卦、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。ROT13 也是过去在古罗马开发的凯撒密码的一种变体。ROT13是它自身的逆反，即：要还原成原文只要使用同一算法即可得，故同样的操作可用于加密与解密。该算法并没有提供真正密码学上的保全，故它不应该被用于需要保全的用途上。它常常被当作弱加密示例的典型。
应用ROT13到一段文字上仅仅只需要检查字母顺序并取代它在13位之后的对应字母，有需要超过时则重新绕回26英文字母开头即可。A换成N、B换成O、依此类推到M换成Z，然后串行反转：N换成A、O换成B、最后Z换成M（如图所示）。只有这些出现在英文字母里的字符受影响；数字、符号、空白字符以及所有其他字符都不变。替换后的字母大小写保持不变。
例如，下面的英文笑话，精华句被ROT13所隐匿：
How can you tell an extrovert from an
introvert at NSA? Va gur ryringbef,
gur rkgebireg ybbxf ng gur BGURE thl&amp;rsquo;f fubrf.
通过ROT13转换，该笑话的解答揭露如下：
Ubj pna lbh gryy na rkgebireg sebz na
vagebireg ng AFN? In the elevators,
the extrovert looks at the OTHER guy&amp;rsquo;s shoes.
第二次使用ROT13将恢复为原文。
Input
第1行：一个整数T（1≤T≤10）为问题数。
接下来共T行。每行为长度不超过1000个字符的一段文字。内含大小写字母、空格、数字和各种符号等。
Output
对于每个问题，输出一行问题的编号（0开始编号，格式：case #0: 等）。
然后对应每个问题在一行中输出经过ROT13加密后的一段文字。
Sample Input
3
How can you tell an extrovert from an</description>
    </item>
    
    <item>
      <title>一个简单的输入输出算法题</title>
      <link>https://madneal.com/post/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <pubDate>Sat, 11 Apr 2015 10:04:08 +0000</pubDate>
      
      <guid>https://madneal.com/post/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <description>有一天同学给了一个非常简单的算题，我居然写了半天，这次我要把它记录下来，以此明志，以后应该要更加注重这方面的锻炼。
题目 ime Limit: 1000 MS Memory Limit: 32768 K 给定两个同样长度的整数数组a[n]和b[n]，按照公式c[n]=a[n] * 2 - b[n]生成数组c[n]，并输出。 输入格式： 共2行数据，每一行是以空格为分隔符的数组，第一个数是一个正整数n，表示数组元素的个数（2&amp;lt;=n&amp;lt;=100)， 接下来是n个正整数表示数组元素,每个整数不超过100。
输出格式： 共1行数据，第一行是以空格为分隔符的数组，第一个数是一个正整数n，表示数组元素的个数（2&amp;lt;=n&amp;lt;=100)，接下来是n个正整数表示数组元素,每个整数不超过100。
样例： 输入： 10 18 38 83 93 53 36 39 58 8 93 10 55 79 20 71 60 66 79 55 78 66 输出 10 -19 -3 146 115 46 6 -1 61 -62 120
代码 #include &amp;#34;stdafx.h&amp;#34; #include&amp;lt;iostream&amp;gt; using namespace std; int main() { int a[100],b[100],c[100]; int n,n_; cin &amp;gt;&amp;gt; n; int m,m_; for (int i = 0; i &amp;lt; n;++ i) { cin &amp;gt;&amp;gt; m; a[i] = m;	} cin &amp;gt;&amp;gt;n_; for (int i = 0;i &amp;lt; n; ++ i) { cin &amp;gt;&amp;gt; m_; b[i] = m_; } for (int i = 0;i &amp;lt;= n;i++) { if (i == 0) cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34; &amp;#34;; else cout &amp;lt;&amp;lt; a[i-1]*2 - b[i-1] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } return 0; } 这个程序很简单，只是数组的输入输出就好了，以后应该还是要找点OJ题目练习一下。</description>
    </item>
    
    <item>
      <title>NilAway：实用的 Go Nil Panic 检测方式</title>
      <link>https://madneal.com/post/nilayay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://madneal.com/post/nilayay/</guid>
      <description>原文：NilAway: Practical Nil Panic Detection for Go
译者：madneal
welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 Uber 由于 Go 语言的高性能，广泛采用其作为实现后端服务和库的主要编程语言。Uber 的 Go monorepo 是 Uber 最大的代码库，包含 9000 万行代码（并且还在增长）。这使得编写可靠 Go 代码的工具成为我们开发基础设施的重要组成部分。
指针（保存其他变量的内存地址而不是其实际值的变量）是 Go 编程语言的一个重要组成部分，有助于高效的内存管理和有效的数据操作。因此，程序员在编写 Go 程序时广泛使用指针，出于多种目的，如原地数据修改、并发编程、数据共享优化、内存使用优化以及支持接口和多态性。虽然指针功能强大且被广泛使用，但必须谨慎和明智地使用它们，以避免诸如空指针解引用导致的 nil panic 等常见陷阱。
nil panic 问题 nil panic 是指程序尝试解引用一个 nil 指针时发生的运行时 panic。当一个指针为 nil 时，意味着它不指向任何有效的内存地址，尝试访问它指向的值将导致 panic（即运行时错误），错误信息如图 1 所示。
图 2 显示了在实现 Go 标准库（特别是 net 包）中发现并解决的最近一次 nil panic 问题 的示例。由于在第 1859 行直接调用了方法 RemoteAddr() 的返回值上的 String() 方法，假设它总是非 nil 的，如图2所示，从而引发了 panic。当接口类型 net.</description>
    </item>
    
  </channel>
</rss>
