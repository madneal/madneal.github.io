<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sw on Neal&#39;s Blog</title>
    <link>https://cdn.jsdelivr.net/gh/neal1991/neal1991.github.io/tags/sw/</link>
    <description>Recent content in Sw on Neal&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Tue, 02 May 2017 12:21:13 +0000</lastBuildDate>
    
	<atom:link href="https://cdn.jsdelivr.net/gh/neal1991/neal1991.github.io/tags/sw/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>service worker介绍</title>
      <link>https://cdn.jsdelivr.net/gh/neal1991/neal1991.github.io/post/service-worker%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 02 May 2017 12:21:13 +0000</pubDate>
      
      <guid>https://cdn.jsdelivr.net/gh/neal1991/neal1991.github.io/post/service-worker%E4%BB%8B%E7%BB%8D/</guid>
      <description>原文：Service workers explained
译者：neal1991
welcome to star my articles-translator , providing you advanced articles translation. Any suggestion, please issue or contact me
LICENSE: MIT
 那么它是什么？ Service worker正是被开发用于解决web平台上经常出现的问题和疑虑，包括：
 无法解释（Extensible Web Manifesto 中）的HTTP缓存以及高级HTTP交互比如HTML5 AppCache。 难以自然地构建一个离线优先地web应用。 缺乏可以利用很多提出功能的上下文执行。  我们也注意到了声明解决方案(Google Gears, Dojo Offline以及HTML5 AppCache都没能实现他们的承诺。每个连续的仅有声明的方法都以相同的方式失败了，所以service worker采取了一个不同的设计方法：一个可以用开发者牢牢把控的重要系统：
Service worker就好像它的内部有一个有一个shared worker ：
 在它自己的全局脚本上下文中运行（通常是在它自己的线程中） 不会和特定的页面绑定 不能够访问DOM  不像shared worker，它：
 即使没有页面也能够运行 如果不使用的话可以终止，还可以再次运行当需要的时候（比如，他不是事件驱动的） 拥有一个定义的升级模式 只允许HTTPS（更多的是在这一点上）  我们可以利用service workers：
 利用网络拦截可以让让网站更快以及/或者支持离线使用 作为其它&amp;rsquo;background&amp;rsquo;功能的基础比如消息推送以及后台同步  开始 首先你需要注册一个service worker:</description>
    </item>
    
  </channel>
</rss>