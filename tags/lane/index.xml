<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lane on Neal&#39;s Blog</title>
    <link>https://madneal.com/tags/lane/</link>
    <description>Recent content in Lane on Neal&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Wed, 15 Apr 2015 09:55:48 +0000</lastBuildDate>
    <atom:link href="https://madneal.com/tags/lane/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>道路识别demo</title>
      <link>https://madneal.com/post/%E9%81%93%E8%B7%AF%E8%AF%86%E5%88%ABdemo/</link>
      <pubDate>Wed, 15 Apr 2015 09:55:48 +0000</pubDate>
      <guid>https://madneal.com/post/%E9%81%93%E8%B7%AF%E8%AF%86%E5%88%ABdemo/</guid>
      <description>&lt;p&gt;最近做的道路识别一开始终于弄懂了点东西，一开始在网上找到了一个简单的道路识别的opencvsharp的版本。我觉得opencvsharp真的是一个很好的东西，它封装了比opencv更多的数据结构和库，而且得益于.net平台的强大，使用起来也非常的便捷。唯一的缺点就是目前关于这方面的资料还是少之又少，后来我还是想一想把这个demo转换成cpp版本，也是一个非常简单的demo。&lt;/p&gt;&#xA;&lt;h2 id=&#34;opencvsharp版本&#34;&gt;opencvsharp版本&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using System.Windows.Forms;&#xA;&#xA;using OpenCvSharp;&#xA;&#xA;namespace LaneDetection&#xA;{&#xA;    class Program&#xA;    {&#xA;        [STAThread]&#xA;        static void Main()&#xA;        {&#xA;            CvCapture cap = CvCapture.FromFile(&amp;#34;test1.mp4&amp;#34;);&#xA;            CvWindow w = new CvWindow(&amp;#34;Lane Detection&amp;#34;);&#xA;            CvWindow canny = new CvWindow(&amp;#34;Canny&amp;#34;);&#xA;            IplImage src, gray, dstCanny, halfFrame, smallImg;&#xA;            CvMemStorage storage = new CvMemStorage();&#xA;            CvSeq lines;&#xA;&#xA;            while (CvWindow.WaitKey(10) &amp;lt; 0)&#xA;            {&#xA;                src = cap.QueryFrame();&#xA;                halfFrame = new IplImage(new CvSize(src.Size.Width / 2, src.Size.Height / 2), BitDepth.U8, 3);&#xA;                Cv.PyrDown(src, halfFrame, CvFilter.Gaussian5x5);&#xA;&#xA;                gray = new IplImage(src.Size, BitDepth.U8, 1);&#xA;                dstCanny = new IplImage(src.Size, BitDepth.U8, 1);&#xA;                storage.Clear();&#xA;                &#xA;                // Crop off top half of image since we&amp;#39;re only interested in the lower portion of the video&#xA;                int halfWidth = src.Width / 2;&#xA;                int halfHeight = src.Height / 2;&#xA;                int startX = halfWidth - (halfWidth / 2);&#xA;                src.SetROI(new CvRect(0, halfHeight - 0, src.Width - 1, src.Height - 1));&#xA;&#xA;                gray.SetROI(src.GetROI());&#xA;                dstCanny.SetROI(src.GetROI());&#xA;&#xA;                src.CvtColor(gray, ColorConversion.BgrToGray);&#xA;                Cv.Smooth(gray, gray, SmoothType.Gaussian, 5, 5);&#xA;                Cv.Canny(gray, dstCanny, 50, 200, ApertureSize.Size3);&#xA;                canny.Image = dstCanny;&#xA;                storage.Clear();&#xA;                lines = dstCanny.HoughLines2(storage, HoughLinesMethod.Probabilistic, 1, Math.PI / 180, 50, 50, 100);&#xA;&#xA;                for (int i = 0; i &amp;lt; lines.Total; i++)&#xA;                {&#xA;                    CvLineSegmentPoint elem = lines.GetSeqElem&amp;lt;CvLineSegmentPoint&amp;gt;(i).Value;&#xA;                    &#xA;                    int dx = elem.P2.X - elem.P1.X;&#xA;                    int dy = elem.P2.Y - elem.P1.Y;&#xA;                    double angle = Math.Atan2(dy, dx) * 180 / Math.PI;&#xA;&#xA;                    if (Math.Abs(angle) &amp;lt;= 10)&#xA;                        continue;&#xA;&#xA;                    if (elem.P1.Y &amp;gt; elem.P2.Y + 50  || elem.P1.Y &amp;lt; elem.P2.Y -50 )&#xA;                    {&#xA;                        src.Line(elem.P1, elem.P2, CvColor.Red, 2, LineType.AntiAlias, 0);&#xA;                    }&#xA;                }&#xA;                src.ResetROI();&#xA;                storage.Clear();&#xA;                w.Image = src;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;opencv版本&#34;&gt;opencv版本&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;#34;stdafx.h&amp;#34;&#xA;#include &amp;lt;highgui.h&amp;gt;&#xA;#include &amp;lt;cv.h&amp;gt;&#xA;#include &amp;lt;math.h&amp;gt;&#xA;&#xA;using namespace cv;&#xA;using namespace std;&#xA;&#xA;#define INF 99999999&#xA;CvCapture* g_capture = NULL;&#xA;&#xA;int g_slider_pos = 0 ;&#xA;int frame_count = 0;&#xA;CvSeq* lines;&#xA;&#xA;&#xA;int main(int argc,char* argv[])&#xA;{                  &#xA;    cvNamedWindow( &amp;#34;show&amp;#34;);      &#xA;&#x9;g_capture=cvCreateFileCapture( &amp;#34;D:\\road.avi&amp;#34;);&#xA;    IplImage* frame;&#xA;    while(1)&#xA;    {  &#xA;&#x9;&#x9;CvMemStorage* storage = cvCreateMemStorage();&#xA;&#x9;&#x9;frame=cvQueryFrame(g_capture);&#xA;&#xA;&#x9;&#x9;//set the ROI of the original image&#xA;&#x9;&#x9;int x = 0,y = frame-&amp;gt;height/2;&#xA;&#x9;&#x9;int width = frame-&amp;gt;width,height = frame-&amp;gt;height/2;&#xA;&#xA;&#x9;&#x9;if(!frame) &#xA;&#x9;&#x9;&#x9;break; &#xA;&#xA;&#x9;&#x9;cvSetImageROI(frame,cvRect(x,y,width,height));&#xA;&#x9;&#x9;IplImage* gray = cvCreateImage(cvGetSize(frame),8,1);&#xA;&#x9;&#x9;cvCvtColor(frame,gray,CV_BGR2GRAY);&#xA;&#xA;&#x9;&#x9;cvCanny(gray,gray,50,100);&#xA;&#x9;&#x9;cvShowImage(&amp;#34;canny&amp;#34;,gray);&#xA;&#x9;&#x9;cvSmooth(gray,gray,CV_GAUSSIAN,3,1,0);&#xA;&#xA;&#x9;&#x9;//Hough&#xA;&#x9;&#x9;lines = cvHoughLines2(gray,storage,CV_HOUGH_PROBABILISTIC,1,CV_PI/180,50,90,50);&#xA;&#xA;&#x9;&#x9;//select approprivate lines acoording to the slope&#xA;&#x9;&#x9;for (int i = 0;i &amp;lt; lines-&amp;gt;total;i ++)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;double k =INF;&#xA;&#x9;&#x9;&#x9;CvPoint* line = (CvPoint*)cvGetSeqElem(lines,i);&#xA;&#x9;&#x9;&#x9;int dx = line[1].x - line[0].x;&#xA;&#x9;&#x9;&#x9;int dy = line[1].x - line[0].y;&#xA;&#x9;&#x9;&#x9;double angle = atan2(dy,dx) * 180 /CV_PI;&#xA;&#x9;&#x9;&#x9;if (abs(angle) &amp;lt;= 10)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;if (line[0].y &amp;gt; line[1].y + 50 || line[0].y &amp;lt; line[1].y - 50)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;cvLine(frame,line[0],line[1],CV_RGB(255,0,0),2,CV_AA);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;cvResetImageROI(frame);&#x9;&#x9;&#xA;&#x9;&#x9;cvShowImage( &amp;#34;show&amp;#34;,frame);&#xA;        char c = cvWaitKey(33);            &#xA;        if(c==27)&#xA;            break;&#xA;    } &#xA;&#x9;cvReleaseCapture(&amp;amp;g_capture);&#xA;&#x9;cvDestroyWindow( &amp;#34;show&amp;#34;);               &#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;非常希望有弄这方面的人能和我讨论一下，若转载请注明出处，谢谢。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
